{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up project structure and dependencies",
        "description": "Initialize the backend and frontend project structures, install required libraries and tools as specified in the technical stack.",
        "details": "For backend: Use Roswell to set up SBCL Common Lisp project with ASDF system definition. Install Hunchentoot, Hunchensocket, cl-sqlite, Jonathan, Ironclad, Bordeaux-threads via Quicklisp. For frontend: Initialize Vite project with PixiJS v7, vanilla JavaScript ES6+. Create directory structures as per architecture (backend/src/, frontend/src/). Ensure Docker setup with Debian base.",
        "testStrategy": "Verify backend loads in REPL with (ql:quickload :collabcanvas). Check frontend builds with npm run build. Confirm all dependencies are installed without errors.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize backend project structure with Roswell and SBCL",
            "description": "Set up the Common Lisp project using Roswell to initialize SBCL with ASDF system definition and create the backend/src/ directory structure.",
            "dependencies": [],
            "details": "Use Roswell to create a new SBCL project named 'collabcanvas' with ASDF system definition. Ensure the project structure includes backend/src/ for source files. Verify that the ASDF system loads correctly in the REPL.",
            "status": "pending",
            "testStrategy": "Load the project in SBCL REPL and check that the ASDF system is defined without errors."
          },
          {
            "id": 2,
            "title": "Install backend dependencies via Quicklisp",
            "description": "Install the required Common Lisp libraries including Hunchentoot, Hunchensocket, cl-sqlite, Jonathan, Ironclad, and Bordeaux-threads using Quicklisp.",
            "dependencies": [
              1
            ],
            "details": "After setting up the backend project, use Quicklisp to install Hunchentoot for web server, Hunchensocket for WebSockets, cl-sqlite for database, Jonathan for JSON handling, Ironclad for cryptography, and Bordeaux-threads for threading. Ensure all packages are available and loadable.",
            "status": "pending",
            "testStrategy": "Run (ql:quickload :collabcanvas) in the REPL and confirm all dependencies load without errors."
          },
          {
            "id": 3,
            "title": "Initialize frontend project with Vite and PixiJS",
            "description": "Set up the frontend project using Vite for build tooling and initialize with PixiJS v7 and vanilla JavaScript ES6+, creating the frontend/src/ directory.",
            "dependencies": [],
            "details": "Use npm or yarn to initialize a Vite project in the frontend directory. Install PixiJS v7 as a dependency. Create the frontend/src/ structure for source files. Configure Vite for vanilla JS ES6+ development.",
            "status": "pending",
            "testStrategy": "Run npm run build in the frontend directory and verify that the build completes successfully with PixiJS integrated."
          },
          {
            "id": 4,
            "title": "Install frontend dependencies",
            "description": "Ensure all frontend dependencies are installed, focusing on PixiJS v7 and any additional tools required for the project.",
            "dependencies": [
              3
            ],
            "details": "After initializing the Vite project, install PixiJS v7 and confirm that the package.json includes all necessary dependencies for vanilla JS ES6+ development. Check for any peer dependencies and resolve them.",
            "status": "pending",
            "testStrategy": "Check that npm install completes without errors and that PixiJS can be imported in a test JS file."
          },
          {
            "id": 5,
            "title": "Set up Docker environment with Debian base",
            "description": "Create a Docker setup using Debian base image to containerize the project, ensuring both backend and frontend can run within the container.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Write a Dockerfile with Debian base image. Include instructions to install SBCL, Roswell, Node.js, and other necessary tools. Copy project files and set up commands to run the backend and frontend. Ensure the container can build and run the application.",
            "status": "pending",
            "testStrategy": "Build the Docker image and run the container, verifying that both backend and frontend start without errors."
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement database schema and setup",
        "description": "Create and initialize the SQLite database with the required tables for users, sessions, and canvas states.",
        "details": "Use cl-sqlite to execute the schema.sql file creating users, sessions, and canvas_states tables. Include indexes for performance. Ensure database file is created in data/ directory. Implement utility functions in database.lisp for connecting and executing queries.",
        "testStrategy": "Run SQLite commands to verify tables exist and constraints are enforced. Insert test data and query to confirm integrity.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create schema.sql file with table definitions",
            "description": "Define the SQL schema for users, sessions, and canvas_states tables including columns, data types, and constraints.",
            "dependencies": [],
            "details": "Write a schema.sql file that includes CREATE TABLE statements for users (id, email, username, password_hash), sessions (id, user_id, session_id, expires_at), and canvas_states (id, session_id, state_json). Add PRIMARY KEY and UNIQUE constraints, and indexes for performance on frequently queried columns like email and session_id.",
            "status": "pending",
            "testStrategy": "Validate the SQL syntax by attempting to execute it in a SQLite environment and check for errors."
          },
          {
            "id": 2,
            "title": "Implement database connection utility",
            "description": "Create functions in database.lisp to establish a connection to the SQLite database.",
            "dependencies": [
              1
            ],
            "details": "In database.lisp, define a function to connect to the SQLite database file located in the data/ directory, using cl-sqlite. Ensure the connection is reusable and handle any connection errors gracefully.",
            "status": "pending",
            "testStrategy": "Call the connection function and verify that the database file is created in data/ if it doesn't exist, and that subsequent calls reuse the connection."
          },
          {
            "id": 3,
            "title": "Execute schema.sql to initialize database",
            "description": "Run the schema.sql file to create the tables and indexes in the database.",
            "dependencies": [
              2
            ],
            "details": "Implement a function in database.lisp that reads and executes the schema.sql file using the established database connection. Ensure all tables are created with their indexes and constraints.",
            "status": "pending",
            "testStrategy": "After execution, query the database to confirm that tables users, sessions, and canvas_states exist with the correct columns and indexes."
          },
          {
            "id": 4,
            "title": "Implement query execution utilities",
            "description": "Add functions for executing SQL queries and statements in database.lisp.",
            "dependencies": [
              3
            ],
            "details": "Define utility functions for executing SELECT, INSERT, UPDATE, and DELETE queries, handling parameters securely to prevent SQL injection. Include functions for fetching results and handling transactions.",
            "status": "pending",
            "testStrategy": "Write and execute test queries to insert sample data into the tables and retrieve it, verifying that the utilities work correctly and data integrity is maintained."
          },
          {
            "id": 5,
            "title": "Verify database setup and file location",
            "description": "Ensure the database file is correctly placed and the setup is complete.",
            "dependencies": [
              4
            ],
            "details": "Check that the SQLite database file is created in the data/ directory. Run a final verification to ensure all tables, indexes, and constraints are properly set up and functional.",
            "status": "pending",
            "testStrategy": "Use SQLite commands to inspect the database file, confirm table structures, and perform basic operations to ensure everything is working as expected."
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement authentication backend",
        "description": "Develop the authentication system including user registration, login, logout, and session management using SHA-256 hashing.",
        "details": "In auth.lisp, implement functions for hashing passwords with Ironclad, creating sessions, validating logins. Add HTTP endpoints /api/register, /api/login, /api/logout using Hunchentoot. Store sessions in SQLite with 24-hour expiry. Handle unique constraints for email and username.",
        "testStrategy": "Use curl to test registration, login, and logout endpoints. Verify session persistence and expiry. Check database for correct data insertion.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up database schema for users and sessions",
            "description": "Create SQLite tables for users (with email, username, hashed password) and sessions (with session ID, user ID, expiry timestamp). Ensure unique constraints on email and username.",
            "dependencies": [],
            "details": "In the database setup, define a 'users' table with columns: id (primary key), email (unique), username (unique), password_hash (text). Define a 'sessions' table with columns: id (primary key), user_id (foreign key to users), session_id (unique), created_at (timestamp), expires_at (timestamp). Use SQLite pragmas for foreign keys.\n<info added on 2025-10-13T20:19:17.572Z>\nInstead of creating new tables, this subtask should confirm that Task 2 successfully created the users and sessions tables with the correct columns and constraints. Query the SQLite database schema using PRAGMA table_info or similar to validate the structure: users table with id (primary key), email (unique), username (unique), password_hash (text); sessions table with id (primary key), user_id (foreign key to users), session_id (unique), created_at (timestamp), expires_at (timestamp). Ensure foreign key constraints are enabled and unique constraints are in place on email and username. Raise errors if the schema does not match expectations.\n</info added on 2025-10-13T20:19:17.572Z>",
            "status": "pending",
            "testStrategy": "Verify table creation by querying the database schema and inserting test data to confirm unique constraints."
          },
          {
            "id": 2,
            "title": "Implement password hashing function",
            "description": "Develop a function to hash passwords using SHA-256 with Ironclad library.",
            "dependencies": [
              1
            ],
            "details": "In auth.lisp, define a function hash-password that takes a plain password string, uses Ironclad to compute SHA-256 hash, and returns the hex-encoded string. Ensure it handles UTF-8 encoding properly.",
            "status": "pending",
            "testStrategy": "Unit test the function with known inputs and verify outputs match expected SHA-256 hashes."
          },
          {
            "id": 3,
            "title": "Implement user registration endpoint",
            "description": "Create the /api/register HTTP endpoint to handle user registration with email, username, and password.",
            "dependencies": [
              1,
              2
            ],
            "details": "Using Hunchentoot, add a POST handler for /api/register that parses JSON body for email, username, password. Validate inputs, hash password, insert into users table, handle unique constraint violations by returning appropriate error responses.",
            "status": "pending",
            "testStrategy": "Use curl to send POST requests with valid and invalid data, check for successful registration and error messages for duplicates."
          },
          {
            "id": 4,
            "title": "Implement login endpoint with session creation",
            "description": "Create the /api/login HTTP endpoint to validate credentials and create a session.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Add a POST handler for /api/login that takes email/username and password. Query user by email or username, verify password hash, generate a unique session ID, insert into sessions table with 24-hour expiry, return session ID in response.",
            "status": "pending",
            "testStrategy": "Test login with correct and incorrect credentials using curl, verify session creation in database and response contains session ID."
          },
          {
            "id": 5,
            "title": "Implement logout endpoint and session management",
            "description": "Create the /api/logout HTTP endpoint to invalidate sessions.",
            "dependencies": [
              4
            ],
            "details": "Add a POST handler for /api/logout that takes session ID, deletes the session from the database. Optionally, implement session validation middleware for protected endpoints to check expiry.",
            "status": "pending",
            "testStrategy": "Login to get a session, call logout, verify session is removed from database, and test that expired sessions are invalidated."
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement authentication frontend",
        "description": "Create the login/register modal UI and logic for handling authentication on the client side.",
        "details": "In auth.js, build modal with tabs for login/register, fields for email, password, username. Use fetch API to call backend endpoints. Store sessionId in localStorage. Block canvas access until authenticated. Handle errors and display messages.",
        "testStrategy": "Open app, attempt registration and login. Verify modal blocks canvas, session persists on refresh. Test invalid credentials error handling.",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create modal UI structure with tabs",
            "description": "Build the basic HTML structure for the authentication modal including tabs for login and register.",
            "dependencies": [],
            "details": "In auth.js, create a modal element with two tabs: one for login and one for register. Use CSS to style the modal as an overlay that appears when authentication is required. Ensure the modal is hidden by default and can be toggled.",
            "status": "pending",
            "testStrategy": "Open the app and verify the modal appears with login and register tabs visible."
          },
          {
            "id": 2,
            "title": "Add form fields for login and register",
            "description": "Implement input fields for email, password, and username in the respective tabs.",
            "dependencies": [
              1
            ],
            "details": "In the login tab, add fields for email and password. In the register tab, add fields for email, password, and username. Include submit buttons for each form. Validate that required fields are filled before submission.",
            "status": "pending",
            "testStrategy": "Switch between tabs and confirm fields are present and functional."
          },
          {
            "id": 3,
            "title": "Implement fetch API calls to backend endpoints",
            "description": "Set up logic to send POST requests to /api/login and /api/register using fetch API.",
            "dependencies": [
              2
            ],
            "details": "On form submission, collect form data and use fetch to call the appropriate backend endpoint. Handle the response asynchronously. Prepare for storing sessionId on success.",
            "status": "pending",
            "testStrategy": "Submit forms with valid data and check network requests in browser dev tools."
          },
          {
            "id": 4,
            "title": "Handle authentication success and session storage",
            "description": "Process successful login/register responses by storing sessionId and unblocking canvas access.",
            "dependencies": [
              3
            ],
            "details": "Upon successful response, store the sessionId in localStorage. Hide the modal and allow access to the canvas. Check for existing sessionId on app load to skip modal if already authenticated.",
            "status": "pending",
            "testStrategy": "Register and login, then refresh the page to verify session persists and canvas is accessible."
          },
          {
            "id": 5,
            "title": "Implement error handling and message display",
            "description": "Add logic to display error messages for failed authentication attempts.",
            "dependencies": [
              3
            ],
            "details": "On failed responses, parse error messages from the backend and display them in the modal. Clear messages on successful attempts. Ensure the modal remains open on errors.",
            "status": "pending",
            "testStrategy": "Attempt login/register with invalid credentials and verify error messages appear."
          }
        ]
      },
      {
        "id": 5,
        "title": "Set up WebSocket server infrastructure",
        "description": "Establish the WebSocket server with room management for canvas collaboration.",
        "details": "In websocket.lisp, create canvas-room class with thread-safe client lists. Implement connection handling, message routing for auth, cursor, object operations. Use Hunchensocket for WebSocket acceptor. Add functions for broadcasting messages to room members.",
        "testStrategy": "Start server and connect via browser console WebSocket. Send test messages and verify routing and broadcasting. Check room creation and client addition/removal.",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Hunchensocket WebSocket acceptor",
            "description": "Initialize the WebSocket server using Hunchensocket library in websocket.lisp.",
            "dependencies": [],
            "details": "Configure Hunchensocket to create a WebSocket acceptor that listens on a specified port, handling the basic setup for WebSocket connections.",
            "status": "pending",
            "testStrategy": "Start the server and verify that it listens on the port without errors, using a simple connection test."
          },
          {
            "id": 2,
            "title": "Create canvas-room class with thread-safe client lists",
            "description": "Define the canvas-room class to manage rooms for canvas collaboration.",
            "dependencies": [
              1
            ],
            "details": "In websocket.lisp, implement a canvas-room class that includes thread-safe lists for managing connected clients, ensuring safe concurrent access.",
            "status": "pending",
            "testStrategy": "Instantiate the class and perform basic operations like adding/removing clients in a multi-threaded environment to check for race conditions."
          },
          {
            "id": 3,
            "title": "Implement WebSocket connection handling",
            "description": "Handle client connections and disconnections for the WebSocket server.",
            "dependencies": [
              2
            ],
            "details": "Add logic to accept incoming WebSocket connections, associate them with canvas rooms, and manage client addition/removal from room lists upon connect/disconnect.",
            "status": "pending",
            "testStrategy": "Connect multiple clients via browser console and verify they are added to the room; disconnect and check removal."
          },
          {
            "id": 4,
            "title": "Implement message routing for auth, cursor, and object operations",
            "description": "Set up routing for different types of WebSocket messages.",
            "dependencies": [
              3
            ],
            "details": "In websocket.lisp, create handlers for message types including authentication, cursor updates, and object operations, parsing incoming messages and dispatching to appropriate functions.",
            "status": "pending",
            "testStrategy": "Send test messages of each type from a client and verify they are routed correctly, logging the handling process."
          },
          {
            "id": 5,
            "title": "Add broadcasting functions for room members",
            "description": "Implement functions to broadcast messages to all clients in a room.",
            "dependencies": [
              4
            ],
            "details": "Create utility functions in websocket.lisp that iterate over the thread-safe client lists in a canvas-room and send messages to all connected members.",
            "status": "pending",
            "testStrategy": "Connect multiple clients to a room, send a broadcast message, and verify all clients receive it via console logs."
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement canvas rendering with PixiJS",
        "description": "Set up the PixiJS application for the infinite canvas with basic rendering.",
        "details": "In canvas.js, initialize PIXI.Application with full viewport. Create Container for world space. Implement grid rendering at 50px intervals. Set up event listeners for mouse interactions. Define screenToWorld and worldToScreen conversion functions.",
        "testStrategy": "Load canvas, verify PixiJS renders grid correctly. Check coordinate conversions with console logs. Ensure canvas fills viewport without scrollbars.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize PIXI.Application with full viewport",
            "description": "Set up the PIXI.Application instance to fill the entire viewport without scrollbars.",
            "dependencies": [],
            "details": "In canvas.js, create a new PIXI.Application with options for width and height set to window.innerWidth and window.innerHeight, and append its view to the document body. Ensure it resizes dynamically with window resize events.",
            "status": "pending",
            "testStrategy": "Load the canvas and verify that PixiJS application renders and fills the viewport completely without any scrollbars appearing."
          },
          {
            "id": 2,
            "title": "Create Container for world space",
            "description": "Establish a PIXI.Container to represent the infinite world space for objects.",
            "dependencies": [
              1
            ],
            "details": "After initializing the PIXI.Application, create a new PIXI.Container instance and add it to the application's stage. This container will hold all world-space objects and transformations.",
            "status": "pending",
            "testStrategy": "Check that the container is added to the stage and can hold child objects by adding a test sprite and confirming it renders."
          },
          {
            "id": 3,
            "title": "Implement grid rendering at 50px intervals",
            "description": "Render a visual grid on the canvas to aid in object placement and navigation.",
            "dependencies": [
              2
            ],
            "details": "In the world container, create PIXI.Graphics to draw horizontal and vertical lines at 50px intervals in world coordinates. Update the grid rendering on zoom and pan events to maintain visibility.",
            "status": "pending",
            "testStrategy": "Zoom and pan the canvas, verify the grid lines appear at correct 50px intervals and adjust dynamically with transformations."
          },
          {
            "id": 4,
            "title": "Set up event listeners for mouse interactions",
            "description": "Add mouse event handlers for basic interactions like clicking and dragging.",
            "dependencies": [
              1
            ],
            "details": "Attach event listeners to the PIXI.Application view for 'mousedown', 'mousemove', and 'mouseup' events. Store mouse positions and states to handle interactions such as panning or selecting.",
            "status": "pending",
            "testStrategy": "Click and drag on the canvas, use console logs to verify that mouse events are captured and positions are recorded accurately."
          },
          {
            "id": 5,
            "title": "Define screenToWorld and worldToScreen conversion functions",
            "description": "Implement utility functions to convert between screen and world coordinates.",
            "dependencies": [
              2
            ],
            "details": "Create functions screenToWorld(x, y) and worldToScreen(x, y) that account for the world container's position, scale, and rotation. Use these for accurate object placement and interaction in world space.",
            "status": "pending",
            "testStrategy": "Use console logs to test coordinate conversions by logging screen positions and their world equivalents, ensuring accuracy during zoom and pan."
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement pan and zoom functionality",
        "description": "Add pan and zoom controls to the canvas for navigation.",
        "details": "In canvas.js, handle middle-click or Alt+left-click drag for pan. Implement mouse wheel zoom with cursor centering, range 0.1x to 10x. Update viewport tracking. Ensure 60 FPS performance using requestAnimationFrame.",
        "testStrategy": "Test pan with middle-click and Alt+drag, verify smooth movement. Zoom in/out with wheel, check cursor centering and FPS via DevTools. Confirm no frame drops with rapid interactions.",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up event listeners for pan and zoom",
            "description": "Initialize event listeners in canvas.js for mouse events to handle pan and zoom interactions.",
            "dependencies": [],
            "details": "Add event listeners for mousedown, mousemove, mouseup, and wheel events on the canvas element. Track mouse state variables like isPanning, lastMouseX, lastMouseY, and zoomLevel. Ensure listeners are attached when the canvas is initialized.",
            "status": "pending",
            "testStrategy": "Verify that event listeners are attached by checking console logs on mouse interactions."
          },
          {
            "id": 2,
            "title": "Implement pan functionality",
            "description": "Handle middle-click or Alt+left-click drag to pan the canvas view.",
            "dependencies": [
              1
            ],
            "details": "In the mousedown event, check for middle button or Alt+left-click to set isPanning to true and record initial mouse position. In mousemove, if isPanning, calculate delta movement and update the viewport offset. Reset on mouseup. Prevent default drag behavior.",
            "status": "pending",
            "testStrategy": "Test middle-click drag and Alt+left-click drag to ensure the canvas pans smoothly without selecting text or other elements."
          },
          {
            "id": 3,
            "title": "Implement zoom functionality",
            "description": "Add mouse wheel zoom with cursor centering and enforce zoom range from 0.1x to 10x.",
            "dependencies": [
              1
            ],
            "details": "In the wheel event, calculate zoom factor based on deltaY, clamp between 0.1 and 10. Adjust zoom level and recompute viewport to center on cursor position. Use transform or scale on the canvas rendering context. Update zoomLevel variable.",
            "status": "pending",
            "testStrategy": "Scroll mouse wheel in and out, check that zoom scales from 0.1x to 10x and centers on cursor. Verify zoom stops at limits."
          },
          {
            "id": 4,
            "title": "Update viewport tracking",
            "description": "Maintain and update viewport properties like offset and zoom level for accurate rendering.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create a viewport object with properties: offsetX, offsetY, zoom. Update these in pan and zoom handlers. Use these to transform world coordinates to screen coordinates in rendering functions. Ensure viewport is reset or initialized properly.",
            "status": "pending",
            "testStrategy": "After pan and zoom, inspect viewport values and confirm they match expected changes based on mouse movements."
          },
          {
            "id": 5,
            "title": "Optimize for 60 FPS performance",
            "description": "Ensure smooth performance using requestAnimationFrame for updates.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Wrap pan and zoom updates in requestAnimationFrame to limit to 60 FPS. Debounce rapid events if necessary. Profile with DevTools to confirm no frame drops during interactions. Optimize rendering by only updating changed parts if possible.",
            "status": "pending",
            "testStrategy": "Use DevTools Performance tab to record interactions, verify frame rate stays at 60 FPS with no drops during rapid pan and zoom."
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement object creation",
        "description": "Enable creation of rectangles and circles on the canvas via click-and-drag.",
        "details": "In canvas.js, add tool modes for rectangle ('R') and circle ('C'). On mouse down, start creation; on mouse up, finalize object with properties (id, type, x, y, width/height/radius, color). Use PIXI.Graphics for rendering. Generate unique IDs.",
        "testStrategy": "Switch to rectangle tool, click-drag to create. Repeat for circle. Verify objects appear with correct properties. Check keyboard shortcuts switch modes.",
        "priority": "high",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add tool modes for rectangle and circle creation",
            "description": "Implement tool modes in canvas.js to switch between rectangle ('R') and circle ('C') creation modes using keyboard shortcuts.",
            "dependencies": [],
            "details": "Modify the canvas.js file to include a mode variable that can be set to 'rectangle' or 'circle' based on key presses 'R' and 'C'. Ensure the mode affects the creation behavior.",
            "status": "pending",
            "testStrategy": "Press 'R' and 'C' keys and verify the mode changes via console logs or UI indicators."
          },
          {
            "id": 2,
            "title": "Handle mouse down event to start object creation",
            "description": "Add event listener for mouse down to initiate the creation of a rectangle or circle based on the current tool mode.",
            "dependencies": [
              1
            ],
            "details": "In canvas.js, attach a mousedown event listener to the canvas. On mousedown, record the starting point (x, y) and create a temporary PIXI.Graphics object for previewing the shape being drawn.",
            "status": "pending",
            "testStrategy": "Switch to rectangle mode, click on canvas, and check if a temporary graphic appears at the click position."
          },
          {
            "id": 3,
            "title": "Handle mouse move event to update shape during drag",
            "description": "Implement mouse move event to dynamically update the dimensions of the rectangle or circle as the user drags.",
            "dependencies": [
              2
            ],
            "details": "Add a mousemove event listener that, while dragging, calculates width/height for rectangle or radius for circle based on current mouse position and starting point, then redraws the temporary PIXI.Graphics object.",
            "status": "pending",
            "testStrategy": "Start dragging after mousedown, move mouse, and verify the shape resizes in real-time on the canvas."
          },
          {
            "id": 4,
            "title": "Handle mouse up event to finalize object creation",
            "description": "On mouse up, finalize the object by assigning properties and adding it to the canvas permanently.",
            "dependencies": [
              3
            ],
            "details": "In the mouseup event listener, remove the temporary graphic, create a new PIXI.Graphics object with final dimensions, assign properties like id, type, x, y, width/height/radius, color, and add it to the canvas stage.",
            "status": "pending",
            "testStrategy": "Complete a click-drag action, release mouse, and confirm a permanent object appears with correct size and properties."
          },
          {
            "id": 5,
            "title": "Implement unique ID generation for objects",
            "description": "Add functionality to generate unique IDs for each created object to ensure no duplicates.",
            "dependencies": [
              4
            ],
            "details": "Create a function in canvas.js that generates unique IDs, perhaps using a counter or timestamp-based method. Assign this ID to each new object upon finalization in the mouseup handler.",
            "status": "pending",
            "testStrategy": "Create multiple objects and verify each has a unique ID by inspecting object properties or logging them."
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement object manipulation",
        "description": "Add selection, dragging, multi-select, and deletion for objects.",
        "details": "In canvas.js, implement select mode ('V') for clicking to select, Shift+click for multi-select. Enable dragging selected objects. Add Delete key handler for removal. Update object positions in world coordinates.",
        "testStrategy": "Create objects, select single/multiple, drag to new positions. Verify positions update correctly. Delete selected objects and confirm removal.",
        "priority": "high",
        "dependencies": [
          "8"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement select mode activation",
            "description": "Add keyboard shortcut 'V' to activate select mode in canvas.js.",
            "dependencies": [],
            "details": "Modify canvas.js to listen for the 'V' key press event and set the current tool mode to 'select'. Ensure this mode allows for object selection without creating new objects.",
            "status": "pending",
            "testStrategy": "Press 'V' key and verify select mode is activated, preventing object creation."
          },
          {
            "id": 2,
            "title": "Implement single object selection",
            "description": "Enable clicking on objects to select them in select mode.",
            "dependencies": [
              1
            ],
            "details": "In canvas.js, add mouse click event handler in select mode to detect clicks on objects using PIXI's hit detection. Mark the clicked object as selected and visually indicate selection (e.g., highlight).",
            "status": "pending",
            "testStrategy": "Create an object, enter select mode, click on it, and verify it is selected and highlighted."
          },
          {
            "id": 3,
            "title": "Implement multi-select with Shift+click",
            "description": "Allow selecting multiple objects by holding Shift and clicking.",
            "dependencies": [
              2
            ],
            "details": "Extend the click handler in canvas.js to check for Shift key during click. If Shift is held, add the clicked object to the selection without deselecting others. Maintain a list of selected objects.",
            "status": "pending",
            "testStrategy": "Create multiple objects, select one, then Shift+click another, and verify both are selected."
          },
          {
            "id": 4,
            "title": "Implement dragging of selected objects",
            "description": "Enable dragging selected objects to new positions.",
            "dependencies": [
              3
            ],
            "details": "In canvas.js, add mouse down, move, and up event handlers for dragging. On mouse down on selected objects, initiate drag. Update positions during move and finalize on mouse up, converting screen coordinates to world coordinates.",
            "status": "pending",
            "testStrategy": "Select an object, drag it to a new position, and verify the position updates correctly in world coordinates."
          },
          {
            "id": 5,
            "title": "Implement deletion of selected objects",
            "description": "Add Delete key handler to remove selected objects.",
            "dependencies": [
              3
            ],
            "details": "In canvas.js, add a keydown event listener for the Delete key. When pressed, remove all selected objects from the canvas and update the object list. Ensure positions are handled in world coordinates if needed.",
            "status": "pending",
            "testStrategy": "Select one or more objects, press Delete key, and verify they are removed from the canvas."
          }
        ]
      },
      {
        "id": 10,
        "title": "Implement WebSocket client",
        "description": "Develop the client-side WebSocket connection and message handling.",
        "details": "In websocket.js, create WebSocketClient class to connect to ws://host/ws/{canvas-id}. Handle auth message on connect. Implement send/receive for cursor, object operations. Add reconnection logic and throttling for cursor updates (30/sec).",
        "testStrategy": "Connect to server, send auth, verify auth-success. Send test object-create message and check server response. Test reconnection after disconnect.",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create WebSocketClient class structure",
            "description": "Set up the basic WebSocketClient class in websocket.js with constructor and initial properties.",
            "dependencies": [],
            "details": "In websocket.js, define a WebSocketClient class with a constructor that takes host, canvasId, and authToken. Initialize properties like ws (WebSocket instance), isConnected (boolean), and message handlers. Ensure the class is exportable for use in other modules.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 2,
            "title": "Implement WebSocket connection and authentication",
            "description": "Establish the WebSocket connection to the server and handle the initial authentication message.",
            "dependencies": [
              1
            ],
            "details": "In the WebSocketClient class, add a connect() method that creates a new WebSocket connection to ws://host/ws/{canvas-id}. On connection open, send an auth message with the authToken. Listen for auth-success or auth-failure responses and handle accordingly, updating connection status.",
            "status": "pending",
            "testStrategy": "Connect to a test server, verify WebSocket opens, send auth message, and check for auth-success response."
          },
          {
            "id": 3,
            "title": "Implement message sending and receiving for cursor and object operations",
            "description": "Add methods to send and receive messages for cursor updates and object manipulations.",
            "dependencies": [
              2
            ],
            "details": "In the WebSocketClient class, implement sendMessage() method to send JSON messages for cursor positions and object operations (create, update, delete). Add onMessage handler to parse incoming messages and dispatch to appropriate handlers for cursor updates and object changes. Ensure messages are properly formatted as JSON.",
            "status": "pending",
            "testStrategy": "Send a test cursor update message and verify it's received. Send an object-create message and check the response."
          },
          {
            "id": 4,
            "title": "Add reconnection logic",
            "description": "Implement automatic reconnection when the WebSocket connection is lost.",
            "dependencies": [
              2
            ],
            "details": "In the WebSocketClient class, add an onClose handler that attempts to reconnect after a delay (e.g., exponential backoff). Track reconnection attempts and stop after a maximum number. Re-authenticate upon successful reconnection. Provide a method to manually disconnect.",
            "status": "pending",
            "testStrategy": "Disconnect the WebSocket manually, verify automatic reconnection occurs, and auth is re-sent."
          },
          {
            "id": 5,
            "title": "Implement throttling for cursor updates",
            "description": "Add throttling to limit cursor update messages to 30 per second.",
            "dependencies": [
              3
            ],
            "details": "In the WebSocketClient class, implement a throttling mechanism using a timer or library to ensure cursor position updates are sent at most 30 times per second. Buffer or drop excess updates. Integrate this into the cursor sending logic to prevent flooding the server.",
            "status": "pending",
            "testStrategy": "Simulate rapid cursor movements and verify that no more than 30 updates are sent per second."
          }
        ]
      },
      {
        "id": 11,
        "title": "Implement real-time synchronization for objects",
        "description": "Sync object creation, updates, and deletions across all connected clients.",
        "details": "Integrate WebSocketClient with CanvasManager: on local object create/update/delete, send message. On receive, update canvas. Broadcast via server. Use last-write-wins for conflicts.",
        "testStrategy": "Open two browser windows, create/update/delete objects in one, verify immediate sync in the other. Check latency <100ms with network tools.",
        "priority": "high",
        "dependencies": [
          "9",
          "10"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate WebSocketClient for sending object change messages",
            "description": "Modify CanvasManager to send WebSocket messages whenever an object is created, updated, or deleted locally.",
            "dependencies": [],
            "details": "In CanvasManager, hook into object creation, update, and deletion events to serialize the object data (id, type, position, etc.) into a JSON message and send it via WebSocketClient to the server.",
            "status": "pending",
            "testStrategy": "Use browser console to verify messages are sent on object actions, check network tab for WebSocket frames."
          },
          {
            "id": 2,
            "title": "Implement handling of incoming WebSocket messages for canvas updates",
            "description": "Update CanvasManager to listen for incoming WebSocket messages and apply the received object changes to the canvas.",
            "dependencies": [
              1
            ],
            "details": "Add a WebSocket message handler in CanvasManager that parses incoming JSON messages for object create, update, or delete operations, and updates the local canvas state accordingly, ensuring UI reflects changes.",
            "status": "pending",
            "testStrategy": "Send manual WebSocket messages from server and observe canvas updates in real-time without local actions."
          },
          {
            "id": 3,
            "title": "Set up server-side broadcasting of object change messages",
            "description": "Implement server logic to broadcast received WebSocket messages to all connected clients except the sender.",
            "dependencies": [
              2
            ],
            "details": "In the server code, upon receiving a message from a client, relay it to all other connected WebSocket clients, ensuring efficient broadcasting without echoing back to the originator.",
            "status": "pending",
            "testStrategy": "Connect multiple clients, perform an action on one, and verify the message is received by others via server logs or client-side logs."
          },
          {
            "id": 4,
            "title": "Implement last-write-wins conflict resolution",
            "description": "Add logic to handle concurrent updates by prioritizing the latest timestamped change.",
            "dependencies": [
              3
            ],
            "details": "Attach timestamps to all object change messages. In the message handler, compare timestamps on conflicts (e.g., simultaneous updates to the same object) and apply the most recent one, discarding older changes.",
            "status": "pending",
            "testStrategy": "Simulate conflicts by rapidly updating the same object from two clients and verify only the latest change persists."
          },
          {
            "id": 5,
            "title": "Test end-to-end real-time synchronization",
            "description": "Perform comprehensive testing to ensure synchronization works across clients with low latency.",
            "dependencies": [
              4
            ],
            "details": "Open multiple browser windows, create, update, and delete objects in one, and verify immediate reflection in others. Use network tools to confirm latency under 100ms and handle edge cases like disconnections.",
            "status": "pending",
            "testStrategy": "Follow the test strategy from the parent task: Open two browser windows, perform actions in one, check sync in the other, measure latency."
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement cursor synchronization",
        "description": "Enable real-time cursor position sharing with presence.",
        "details": "In websocket.js, send cursor updates on mouse move (throttled). On receive, render remote cursors with username labels in unique colors. Update presence list on connect/disconnect.",
        "testStrategy": "Move mouse in one window, verify cursor appears in others with <50ms latency. Check presence list updates on join/leave.",
        "priority": "medium",
        "dependencies": [
          "10"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up mouse move event listener with throttling",
            "description": "Implement a throttled mouse move event listener in the canvas to capture cursor positions efficiently.",
            "dependencies": [],
            "details": "In canvas.js, add an event listener for mousemove events on the canvas element. Use a throttling mechanism (e.g., lodash.throttle or custom implementation) to limit updates to every 50ms or less to avoid excessive sending.",
            "status": "pending",
            "testStrategy": "Move mouse rapidly and verify that position updates are throttled, not sent on every pixel movement."
          },
          {
            "id": 2,
            "title": "Send cursor position updates via WebSocket",
            "description": "Modify websocket.js to send cursor position data on throttled mouse moves.",
            "dependencies": [
              1
            ],
            "details": "In websocket.js, on each throttled mouse move, send a message containing the current cursor x, y coordinates, username, and a unique color identifier via the WebSocket connection.",
            "status": "pending",
            "testStrategy": "Move mouse and use browser dev tools to inspect WebSocket messages, confirming position data is sent with username and color."
          },
          {
            "id": 3,
            "title": "Receive and parse cursor updates from WebSocket",
            "description": "Handle incoming WebSocket messages for cursor positions from other users.",
            "dependencies": [
              2
            ],
            "details": "In websocket.js, add a message handler to receive cursor update messages, parse the JSON payload to extract position, username, and color, and store or update a list of remote cursors.",
            "status": "pending",
            "testStrategy": "Open multiple browser windows, move mouse in one, and check console logs in others for received messages with correct data."
          },
          {
            "id": 4,
            "title": "Render remote cursors with username labels and unique colors",
            "description": "Display remote cursors on the canvas with labels and colors.",
            "dependencies": [
              3
            ],
            "details": "In canvas.js, for each remote cursor in the list, render a cursor icon (e.g., a small arrow or dot) at the received position, add a text label with the username, and apply the unique color. Update positions in real-time as new messages arrive.",
            "status": "pending",
            "testStrategy": "With multiple users, move cursors and verify they appear in other windows with labels, colors, and <50ms latency using browser performance tools."
          },
          {
            "id": 5,
            "title": "Update presence list on user connect and disconnect",
            "description": "Maintain and display a list of online users based on WebSocket connections.",
            "dependencies": [
              3
            ],
            "details": "In websocket.js, on WebSocket open (connect), send a join message with username. On close (disconnect), send a leave message. Maintain a presence list and update the UI (e.g., a sidebar) to show current online users.",
            "status": "pending",
            "testStrategy": "Open/close browser windows and check that the presence list updates immediately on join/leave, reflecting accurate user counts."
          }
        ]
      },
      {
        "id": 13,
        "title": "Implement state persistence",
        "description": "Save and load canvas state to/from SQLite database.",
        "details": "In canvas-state.lisp, implement save function with debounced updates (500ms). Load state on connection via GET /api/canvas/state. Store as JSON blob in canvas_states table.",
        "testStrategy": "Create objects, refresh page, verify state persists. Disconnect all users, reconnect, check state loads. Confirm debouncing prevents excessive saves.",
        "priority": "high",
        "dependencies": [
          "2",
          "11"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create canvas_states table in SQLite",
            "description": "Set up the database schema for storing canvas state as JSON blobs.",
            "dependencies": [],
            "details": "Create a table named 'canvas_states' with columns: id (primary key, auto-increment), state_json (text for JSON blob), and timestamp (datetime for last update). Ensure the table is created in the SQLite database used by the application.",
            "status": "pending",
            "testStrategy": "Run a database query to verify the table exists with correct columns."
          },
          {
            "id": 2,
            "title": "Implement debounced save function in canvas-state.lisp",
            "description": "Develop a function to save the current canvas state to the database with debouncing to prevent excessive saves.",
            "dependencies": [
              1
            ],
            "details": "In canvas-state.lisp, create a save-canvas-state function that serializes the canvas state to JSON and inserts/updates it in the canvas_states table. Implement debouncing using a timer (500ms delay) to batch saves and avoid overloading the database on rapid changes.",
            "status": "pending",
            "testStrategy": "Simulate rapid canvas changes and check that saves occur only after 500ms of inactivity, verifying database entries."
          },
          {
            "id": 3,
            "title": "Implement load state function for GET /api/canvas/state",
            "description": "Create a backend endpoint to retrieve and return the persisted canvas state.",
            "dependencies": [
              1
            ],
            "details": "In canvas-state.lisp, add a handler for GET /api/canvas/state that queries the canvas_states table for the latest state JSON, parses it, and returns it in the response. Handle cases where no state exists (return empty or default state).",
            "status": "pending",
            "testStrategy": "Use curl or a browser to call the endpoint and verify it returns the correct JSON state or default when no data is present."
          },
          {
            "id": 4,
            "title": "Integrate saving on canvas state changes",
            "description": "Connect the save function to trigger whenever the canvas state is modified.",
            "dependencies": [
              2
            ],
            "details": "Modify the canvas manipulation code (e.g., in canvas.js or related Lisp functions) to call the debounced save function whenever objects are created, moved, or deleted. Ensure the state includes all necessary object properties for accurate restoration.",
            "status": "pending",
            "testStrategy": "Create and modify objects on the canvas, then check the database to confirm the state is saved correctly after debouncing."
          },
          {
            "id": 5,
            "title": "Integrate loading on client connection",
            "description": "Ensure the canvas state is loaded from the database when a user connects or refreshes the page.",
            "dependencies": [
              3
            ],
            "details": "In the client-side code (e.g., canvas.js), add logic to fetch the state via GET /api/canvas/state on page load or connection, and populate the canvas with the loaded objects. Handle authentication if required, and merge or replace existing state appropriately.",
            "status": "pending",
            "testStrategy": "Refresh the page after making changes, verify that the canvas reloads with the persisted state. Test with multiple users or disconnections."
          }
        ]
      },
      {
        "id": 14,
        "title": "Implement user interface components",
        "description": "Build the UI for toolbar, presence list, and status bar.",
        "details": "In HTML/CSS/JS, create toolbar for tools (select, rectangle, circle), color picker. Add presence list in top-right. Implement status bar for tool, position, zoom. Ensure dark theme consistency.",
        "testStrategy": "Verify toolbar switches tools, presence shows online users, status updates correctly. Check UI doesn't obstruct canvas and is responsive.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create toolbar with tool buttons and color picker",
            "description": "Design and implement the toolbar containing buttons for select, rectangle, and circle tools, along with a color picker component.",
            "dependencies": [],
            "details": "In HTML, add a div for the toolbar. Use CSS for styling with dark theme. In JS, create buttons for each tool and a color input. Attach event listeners to switch tool modes in canvas.js.",
            "status": "pending",
            "testStrategy": "Click each tool button and verify the active tool changes. Select a color and confirm it applies to new objects."
          },
          {
            "id": 2,
            "title": "Implement presence list in top-right corner",
            "description": "Build the presence list component to display online users in the top-right area of the interface.",
            "dependencies": [
              1
            ],
            "details": "Add a div in the top-right of the page layout. Use JS to fetch and display user list from backend. Style with dark theme CSS. Update list on user join/leave events.",
            "status": "pending",
            "testStrategy": "Simulate multiple users logging in and verify the list updates in real-time. Check positioning doesn't overlap with other UI elements."
          },
          {
            "id": 3,
            "title": "Develop status bar for tool, position, and zoom info",
            "description": "Create the status bar at the bottom to show current tool, mouse position, and zoom level.",
            "dependencies": [
              1
            ],
            "details": "Insert a status bar div at the bottom of the page. In JS, update text content based on current tool, mouse coordinates, and zoom factor. Ensure responsive design and dark theme.",
            "status": "pending",
            "testStrategy": "Switch tools and move mouse; verify status bar updates accurately. Zoom in/out and check zoom display changes."
          },
          {
            "id": 4,
            "title": "Apply dark theme consistency across UI components",
            "description": "Ensure all toolbar, presence list, and status bar elements adhere to the dark theme color scheme.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Define CSS variables for dark theme colors (e.g., background, text, borders). Apply these to all UI elements created. Test for consistency in visibility and aesthetics.",
            "status": "pending",
            "testStrategy": "Inspect UI in browser dev tools for color consistency. Verify readability and contrast in dark mode."
          },
          {
            "id": 5,
            "title": "Integrate UI components into main layout",
            "description": "Position and integrate the toolbar, presence list, and status bar into the overall page layout without obstructing the canvas.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Use CSS flexbox or grid to arrange components: toolbar top-left, presence top-right, status bottom. Ensure canvas remains central and unobstructed. Make layout responsive.",
            "status": "pending",
            "testStrategy": "Resize browser window and confirm UI elements adjust properly. Verify canvas interaction isn't blocked by UI overlays."
          }
        ]
      },
      {
        "id": 15,
        "title": "Deploy application to Fly.io",
        "description": "Containerize and deploy the application to Fly.io for public access.",
        "details": "Create Dockerfile as specified. Build frontend and backend. Configure fly.toml. Use fly deploy. Ensure health check endpoint.",
        "testStrategy": "Access deployed URL, test full flow: register, login, create objects, sync with another user. Verify performance and no errors in logs.",
        "priority": "high",
        "dependencies": [
          "13",
          "14"
        ],
        "status": "deferred",
        "subtasks": [],
        "updatedAt": "2025-10-13T19:29:12.767Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-13T19:29:12.767Z",
      "taskCount": 15,
      "completedCount": 0,
      "tags": [
        "master"
      ],
      "created": "2025-10-13T19:51:34.818Z",
      "description": "Tasks for master context"
    }
  }
}