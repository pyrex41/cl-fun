{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up project structure and dependencies",
        "description": "Initialize the backend and frontend project structures, install required libraries and tools as specified in the technical stack.",
        "details": "For backend: Use Roswell to set up SBCL Common Lisp project with ASDF system definition. Install Hunchentoot, Hunchensocket, cl-sqlite, Jonathan, Ironclad, Bordeaux-threads via Quicklisp. For frontend: Initialize Vite project with PixiJS v7, vanilla JavaScript ES6+. Create directory structures as per architecture (backend/src/, frontend/src/). Ensure Docker setup with Debian base.",
        "testStrategy": "Verify backend loads in REPL with (ql:quickload :collabcanvas). Check frontend builds with npm run build. Confirm all dependencies are installed without errors.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize backend project structure with Roswell and SBCL",
            "description": "Set up the Common Lisp project using Roswell to initialize SBCL with ASDF system definition and create the backend/src/ directory structure.",
            "dependencies": [],
            "details": "Use Roswell to create a new SBCL project named 'collabcanvas' with ASDF system definition. Ensure the project structure includes backend/src/ for source files. Verify that the ASDF system loads correctly in the REPL.",
            "status": "done",
            "testStrategy": "Load the project in SBCL REPL and check that the ASDF system is defined without errors.",
            "updatedAt": "2025-10-13T21:24:51.583Z"
          },
          {
            "id": 2,
            "title": "Install backend dependencies via Quicklisp",
            "description": "Install the required Common Lisp libraries including Hunchentoot, Hunchensocket, cl-sqlite, Jonathan, Ironclad, and Bordeaux-threads using Quicklisp.",
            "dependencies": [
              1
            ],
            "details": "After setting up the backend project, use Quicklisp to install Hunchentoot for web server, Hunchensocket for WebSockets, cl-sqlite for database, Jonathan for JSON handling, Ironclad for cryptography, and Bordeaux-threads for threading. Ensure all packages are available and loadable.",
            "status": "done",
            "testStrategy": "Run (ql:quickload :collabcanvas) in the REPL and confirm all dependencies load without errors.",
            "updatedAt": "2025-10-13T21:24:52.880Z"
          },
          {
            "id": 3,
            "title": "Initialize frontend project with Vite and PixiJS",
            "description": "Set up the frontend project using Vite for build tooling and initialize with PixiJS v7 and vanilla JavaScript ES6+, creating the frontend/src/ directory.",
            "dependencies": [],
            "details": "Use npm or yarn to initialize a Vite project in the frontend directory. Install PixiJS v7 as a dependency. Create the frontend/src/ structure for source files. Configure Vite for vanilla JS ES6+ development.",
            "status": "done",
            "testStrategy": "Run npm run build in the frontend directory and verify that the build completes successfully with PixiJS integrated.",
            "updatedAt": "2025-10-13T21:24:54.220Z"
          },
          {
            "id": 4,
            "title": "Install frontend dependencies",
            "description": "Ensure all frontend dependencies are installed, focusing on PixiJS v7 and any additional tools required for the project.",
            "dependencies": [],
            "details": "After initializing the Vite project, install PixiJS v7 and confirm that the package.json includes all necessary dependencies for vanilla JS ES6+ development. Check for any peer dependencies and resolve them.",
            "status": "done",
            "testStrategy": "Check that npm install completes without errors and that PixiJS can be imported in a test JS file.",
            "updatedAt": "2025-10-13T21:24:55.568Z"
          },
          {
            "id": 5,
            "title": "Set up Docker environment with Debian base",
            "description": "Create a Docker setup using Debian base image to containerize the project, ensuring both backend and frontend can run within the container.",
            "dependencies": [
              1,
              2
            ],
            "details": "Write a Dockerfile with Debian base image. Include instructions to install SBCL, Roswell, Node.js, and other necessary tools. Copy project files and set up commands to run the backend and frontend. Ensure the container can build and run the application.",
            "status": "done",
            "testStrategy": "Build the Docker image and run the container, verifying that both backend and frontend start without errors.",
            "updatedAt": "2025-10-13T21:24:56.916Z"
          }
        ],
        "updatedAt": "2025-10-13T21:24:56.916Z"
      },
      {
        "id": 2,
        "title": "Implement database schema and setup",
        "description": "Create and initialize the SQLite database with the required tables for users, sessions, and canvas states.",
        "details": "Use cl-sqlite to execute the schema.sql file creating users, sessions, and canvas_states tables. Include indexes for performance. Ensure database file is created in data/ directory. Implement utility functions in database.lisp for connecting and executing queries.",
        "testStrategy": "Run SQLite commands to verify tables exist and constraints are enforced. Insert test data and query to confirm integrity.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Create schema.sql file with table definitions",
            "description": "Define the SQL schema for users, sessions, and canvas_states tables including columns, data types, and constraints.",
            "dependencies": [],
            "details": "Write a schema.sql file that includes CREATE TABLE statements for users (id, email, username, password_hash), sessions (id, user_id, session_id, expires_at), and canvas_states (id, session_id, state_json). Add PRIMARY KEY and UNIQUE constraints, and indexes for performance on frequently queried columns like email and session_id.",
            "status": "pending",
            "testStrategy": "Validate the SQL syntax by attempting to execute it in a SQLite environment and check for errors."
          },
          {
            "id": 2,
            "title": "Implement database connection utility",
            "description": "Create functions in database.lisp to establish a connection to the SQLite database.",
            "dependencies": [
              1
            ],
            "details": "In database.lisp, define a function to connect to the SQLite database file located in the data/ directory, using cl-sqlite. Ensure the connection is reusable and handle any connection errors gracefully.",
            "status": "pending",
            "testStrategy": "Call the connection function and verify that the database file is created in data/ if it doesn't exist, and that subsequent calls reuse the connection."
          },
          {
            "id": 3,
            "title": "Execute schema.sql to initialize database",
            "description": "Run the schema.sql file to create the tables and indexes in the database.",
            "dependencies": [
              2
            ],
            "details": "Implement a function in database.lisp that reads and executes the schema.sql file using the established database connection. Ensure all tables are created with their indexes and constraints.",
            "status": "pending",
            "testStrategy": "After execution, query the database to confirm that tables users, sessions, and canvas_states exist with the correct columns and indexes."
          },
          {
            "id": 4,
            "title": "Implement query execution utilities",
            "description": "Add functions for executing SQL queries and statements in database.lisp.",
            "dependencies": [
              3
            ],
            "details": "Define utility functions for executing SELECT, INSERT, UPDATE, and DELETE queries, handling parameters securely to prevent SQL injection. Include functions for fetching results and handling transactions.",
            "status": "pending",
            "testStrategy": "Write and execute test queries to insert sample data into the tables and retrieve it, verifying that the utilities work correctly and data integrity is maintained."
          },
          {
            "id": 5,
            "title": "Verify database setup and file location",
            "description": "Ensure the database file is correctly placed and the setup is complete.",
            "dependencies": [
              4
            ],
            "details": "Check that the SQLite database file is created in the data/ directory. Run a final verification to ensure all tables, indexes, and constraints are properly set up and functional.",
            "status": "pending",
            "testStrategy": "Use SQLite commands to inspect the database file, confirm table structures, and perform basic operations to ensure everything is working as expected."
          }
        ],
        "updatedAt": "2025-10-13T21:24:58.407Z"
      },
      {
        "id": 3,
        "title": "Implement authentication backend",
        "description": "Develop the authentication system including user registration, login, logout, and session management using SHA-256 hashing.",
        "details": "In auth.lisp, implement functions for hashing passwords with Ironclad, creating sessions, validating logins. Add HTTP endpoints /api/register, /api/login, /api/logout using Hunchentoot. Store sessions in SQLite with 24-hour expiry. Handle unique constraints for email and username.",
        "testStrategy": "Use curl to test registration, login, and logout endpoints. Verify session persistence and expiry. Check database for correct data insertion.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up database schema for users and sessions",
            "description": "Create SQLite tables for users (with email, username, hashed password) and sessions (with session ID, user ID, expiry timestamp). Ensure unique constraints on email and username.",
            "dependencies": [],
            "details": "In the database setup, define a 'users' table with columns: id (primary key), email (unique), username (unique), password_hash (text). Define a 'sessions' table with columns: id (primary key), user_id (foreign key to users), session_id (unique), created_at (timestamp), expires_at (timestamp). Use SQLite pragmas for foreign keys.\n<info added on 2025-10-13T20:19:17.572Z>\nInstead of creating new tables, this subtask should confirm that Task 2 successfully created the users and sessions tables with the correct columns and constraints. Query the SQLite database schema using PRAGMA table_info or similar to validate the structure: users table with id (primary key), email (unique), username (unique), password_hash (text); sessions table with id (primary key), user_id (foreign key to users), session_id (unique), created_at (timestamp), expires_at (timestamp). Ensure foreign key constraints are enabled and unique constraints are in place on email and username. Raise errors if the schema does not match expectations.\n</info added on 2025-10-13T20:19:17.572Z>",
            "status": "pending",
            "testStrategy": "Verify table creation by querying the database schema and inserting test data to confirm unique constraints."
          },
          {
            "id": 2,
            "title": "Implement password hashing function",
            "description": "Develop a function to hash passwords using SHA-256 with Ironclad library.",
            "dependencies": [
              1
            ],
            "details": "In auth.lisp, define a function hash-password that takes a plain password string, uses Ironclad to compute SHA-256 hash, and returns the hex-encoded string. Ensure it handles UTF-8 encoding properly.",
            "status": "pending",
            "testStrategy": "Unit test the function with known inputs and verify outputs match expected SHA-256 hashes."
          },
          {
            "id": 3,
            "title": "Implement user registration endpoint",
            "description": "Create the /api/register HTTP endpoint to handle user registration with email, username, and password.",
            "dependencies": [
              1,
              2
            ],
            "details": "Using Hunchentoot, add a POST handler for /api/register that parses JSON body for email, username, password. Validate inputs, hash password, insert into users table, handle unique constraint violations by returning appropriate error responses.",
            "status": "pending",
            "testStrategy": "Use curl to send POST requests with valid and invalid data, check for successful registration and error messages for duplicates."
          },
          {
            "id": 4,
            "title": "Implement login endpoint with session creation",
            "description": "Create the /api/login HTTP endpoint to validate credentials and create a session.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Add a POST handler for /api/login that takes email/username and password. Query user by email or username, verify password hash, generate a unique session ID, insert into sessions table with 24-hour expiry, return session ID in response.",
            "status": "pending",
            "testStrategy": "Test login with correct and incorrect credentials using curl, verify session creation in database and response contains session ID."
          },
          {
            "id": 5,
            "title": "Implement logout endpoint and session management",
            "description": "Create the /api/logout HTTP endpoint to invalidate sessions.",
            "dependencies": [
              4
            ],
            "details": "Add a POST handler for /api/logout that takes session ID, deletes the session from the database. Optionally, implement session validation middleware for protected endpoints to check expiry.",
            "status": "pending",
            "testStrategy": "Login to get a session, call logout, verify session is removed from database, and test that expired sessions are invalidated."
          }
        ],
        "updatedAt": "2025-10-13T21:24:59.652Z"
      },
      {
        "id": 4,
        "title": "Implement authentication frontend",
        "description": "Create the login/register modal UI and logic for handling authentication on the client side.",
        "details": "In auth.js, build modal with tabs for login/register, fields for email, password, username. Use fetch API to call backend endpoints. Store sessionId in localStorage. Block canvas access until authenticated. Handle errors and display messages.",
        "testStrategy": "Open app, attempt registration and login. Verify modal blocks canvas, session persists on refresh. Test invalid credentials error handling.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create modal UI structure with tabs",
            "description": "Build the basic HTML structure for the authentication modal including tabs for login and register.",
            "dependencies": [],
            "details": "In auth.js, create a modal element with two tabs: one for login and one for register. Use CSS to style the modal as an overlay that appears when authentication is required. Ensure the modal is hidden by default and can be toggled.",
            "status": "done",
            "testStrategy": "Open the app and verify the modal appears with login and register tabs visible.",
            "updatedAt": "2025-10-13T21:27:24.151Z"
          },
          {
            "id": 2,
            "title": "Add form fields for login and register",
            "description": "Implement input fields for email, password, and username in the respective tabs.",
            "dependencies": [
              1
            ],
            "details": "In the login tab, add fields for email and password. In the register tab, add fields for email, password, and username. Include submit buttons for each form. Validate that required fields are filled before submission.",
            "status": "done",
            "testStrategy": "Switch between tabs and confirm fields are present and functional.",
            "updatedAt": "2025-10-13T21:28:10.289Z"
          },
          {
            "id": 3,
            "title": "Implement fetch API calls to backend endpoints",
            "description": "Set up logic to send POST requests to /api/login and /api/register using fetch API.",
            "dependencies": [
              2
            ],
            "details": "On form submission, collect form data and use fetch to call the appropriate backend endpoint. Handle the response asynchronously. Prepare for storing sessionId on success.",
            "status": "done",
            "testStrategy": "Submit forms with valid data and check network requests in browser dev tools.",
            "updatedAt": "2025-10-13T21:28:11.618Z"
          },
          {
            "id": 4,
            "title": "Handle authentication success and session storage",
            "description": "Process successful login/register responses by storing sessionId and unblocking canvas access.",
            "dependencies": [
              3
            ],
            "details": "Upon successful response, store the sessionId in localStorage. Hide the modal and allow access to the canvas. Check for existing sessionId on app load to skip modal if already authenticated.",
            "status": "done",
            "testStrategy": "Register and login, then refresh the page to verify session persists and canvas is accessible.",
            "updatedAt": "2025-10-13T21:28:12.950Z"
          },
          {
            "id": 5,
            "title": "Implement error handling and message display",
            "description": "Add logic to display error messages for failed authentication attempts.",
            "dependencies": [
              3
            ],
            "details": "On failed responses, parse error messages from the backend and display them in the modal. Clear messages on successful attempts. Ensure the modal remains open on errors.",
            "status": "done",
            "testStrategy": "Attempt login/register with invalid credentials and verify error messages appear.",
            "updatedAt": "2025-10-13T21:28:14.350Z"
          }
        ],
        "updatedAt": "2025-10-13T21:28:14.350Z"
      },
      {
        "id": 5,
        "title": "Set up WebSocket server infrastructure",
        "description": "Establish the WebSocket server with room management for canvas collaboration.",
        "details": "In websocket.lisp, create canvas-room class with thread-safe client lists. Implement connection handling, message routing for auth, cursor, object operations. Use Hunchensocket for WebSocket acceptor. Add functions for broadcasting messages to room members.",
        "testStrategy": "Start server and connect via browser console WebSocket. Send test messages and verify routing and broadcasting. Check room creation and client addition/removal.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Hunchensocket WebSocket acceptor",
            "description": "Initialize the WebSocket server using Hunchensocket library in websocket.lisp.",
            "dependencies": [],
            "details": "Configure Hunchensocket to create a WebSocket acceptor that listens on a specified port, handling the basic setup for WebSocket connections.",
            "status": "pending",
            "testStrategy": "Start the server and verify that it listens on the port without errors, using a simple connection test."
          },
          {
            "id": 2,
            "title": "Create canvas-room class with thread-safe client lists",
            "description": "Define the canvas-room class to manage rooms for canvas collaboration.",
            "dependencies": [
              1
            ],
            "details": "In websocket.lisp, implement a canvas-room class that includes thread-safe lists for managing connected clients, ensuring safe concurrent access.",
            "status": "pending",
            "testStrategy": "Instantiate the class and perform basic operations like adding/removing clients in a multi-threaded environment to check for race conditions."
          },
          {
            "id": 3,
            "title": "Implement WebSocket connection handling",
            "description": "Handle client connections and disconnections for the WebSocket server.",
            "dependencies": [
              2
            ],
            "details": "Add logic to accept incoming WebSocket connections, associate them with canvas rooms, and manage client addition/removal from room lists upon connect/disconnect.",
            "status": "pending",
            "testStrategy": "Connect multiple clients via browser console and verify they are added to the room; disconnect and check removal."
          },
          {
            "id": 4,
            "title": "Implement message routing for auth, cursor, and object operations",
            "description": "Set up routing for different types of WebSocket messages.",
            "dependencies": [
              3
            ],
            "details": "In websocket.lisp, create handlers for message types including authentication, cursor updates, and object operations, parsing incoming messages and dispatching to appropriate functions.",
            "status": "pending",
            "testStrategy": "Send test messages of each type from a client and verify they are routed correctly, logging the handling process."
          },
          {
            "id": 5,
            "title": "Add broadcasting functions for room members",
            "description": "Implement functions to broadcast messages to all clients in a room.",
            "dependencies": [
              4
            ],
            "details": "Create utility functions in websocket.lisp that iterate over the thread-safe client lists in a canvas-room and send messages to all connected members.",
            "status": "pending",
            "testStrategy": "Connect multiple clients to a room, send a broadcast message, and verify all clients receive it via console logs."
          }
        ],
        "updatedAt": "2025-10-13T21:25:01.037Z"
      },
      {
        "id": 6,
        "title": "Implement canvas rendering with PixiJS",
        "description": "Set up the PixiJS application for the infinite canvas with basic rendering.",
        "details": "In canvas.js, initialize PIXI.Application with full viewport. Create Container for world space. Implement grid rendering at 50px intervals. Set up event listeners for mouse interactions. Define screenToWorld and worldToScreen conversion functions.",
        "testStrategy": "Load canvas, verify PixiJS renders grid correctly. Check coordinate conversions with console logs. Ensure canvas fills viewport without scrollbars.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize PIXI.Application with full viewport",
            "description": "Set up the PIXI.Application instance to fill the entire viewport without scrollbars.",
            "dependencies": [],
            "details": "In canvas.js, create a new PIXI.Application with options for width and height set to window.innerWidth and window.innerHeight, and append its view to the document body. Ensure it resizes dynamically with window resize events.",
            "status": "pending",
            "testStrategy": "Load the canvas and verify that PixiJS application renders and fills the viewport completely without any scrollbars appearing."
          },
          {
            "id": 2,
            "title": "Create Container for world space",
            "description": "Establish a PIXI.Container to represent the infinite world space for objects.",
            "dependencies": [
              1
            ],
            "details": "After initializing the PIXI.Application, create a new PIXI.Container instance and add it to the application's stage. This container will hold all world-space objects and transformations.",
            "status": "pending",
            "testStrategy": "Check that the container is added to the stage and can hold child objects by adding a test sprite and confirming it renders."
          },
          {
            "id": 3,
            "title": "Implement grid rendering at 50px intervals",
            "description": "Render a visual grid on the canvas to aid in object placement and navigation.",
            "dependencies": [
              2
            ],
            "details": "In the world container, create PIXI.Graphics to draw horizontal and vertical lines at 50px intervals in world coordinates. Update the grid rendering on zoom and pan events to maintain visibility.",
            "status": "pending",
            "testStrategy": "Zoom and pan the canvas, verify the grid lines appear at correct 50px intervals and adjust dynamically with transformations."
          },
          {
            "id": 4,
            "title": "Set up event listeners for mouse interactions",
            "description": "Add mouse event handlers for basic interactions like clicking and dragging.",
            "dependencies": [
              1
            ],
            "details": "Attach event listeners to the PIXI.Application view for 'mousedown', 'mousemove', and 'mouseup' events. Store mouse positions and states to handle interactions such as panning or selecting.",
            "status": "pending",
            "testStrategy": "Click and drag on the canvas, use console logs to verify that mouse events are captured and positions are recorded accurately."
          },
          {
            "id": 5,
            "title": "Define screenToWorld and worldToScreen conversion functions",
            "description": "Implement utility functions to convert between screen and world coordinates.",
            "dependencies": [
              2
            ],
            "details": "Create functions screenToWorld(x, y) and worldToScreen(x, y) that account for the world container's position, scale, and rotation. Use these for accurate object placement and interaction in world space.",
            "status": "pending",
            "testStrategy": "Use console logs to test coordinate conversions by logging screen positions and their world equivalents, ensuring accuracy during zoom and pan."
          }
        ],
        "updatedAt": "2025-10-13T21:25:02.354Z"
      },
      {
        "id": 7,
        "title": "Implement pan and zoom functionality",
        "description": "Add pan and zoom controls to the canvas for navigation.",
        "details": "In canvas.js, handle middle-click or Alt+left-click drag for pan. Implement mouse wheel zoom with cursor centering, range 0.1x to 10x. Update viewport tracking. Ensure 60 FPS performance using requestAnimationFrame.",
        "testStrategy": "Test pan with middle-click and Alt+drag, verify smooth movement. Zoom in/out with wheel, check cursor centering and FPS via DevTools. Confirm no frame drops with rapid interactions.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up event listeners for pan and zoom",
            "description": "Initialize event listeners in canvas.js for mouse events to handle pan and zoom interactions.",
            "dependencies": [],
            "details": "Add event listeners for mousedown, mousemove, mouseup, and wheel events on the canvas element. Track mouse state variables like isPanning, lastMouseX, lastMouseY, and zoomLevel. Ensure listeners are attached when the canvas is initialized.",
            "status": "done",
            "testStrategy": "Verify that event listeners are attached by checking console logs on mouse interactions.",
            "updatedAt": "2025-10-13T21:27:39.201Z"
          },
          {
            "id": 2,
            "title": "Implement pan functionality",
            "description": "Handle middle-click or Alt+left-click drag to pan the canvas view.",
            "dependencies": [
              1
            ],
            "details": "In the mousedown event, check for middle button or Alt+left-click to set isPanning to true and record initial mouse position. In mousemove, if isPanning, calculate delta movement and update the viewport offset. Reset on mouseup. Prevent default drag behavior.",
            "status": "done",
            "testStrategy": "Test middle-click drag and Alt+left-click drag to ensure the canvas pans smoothly without selecting text or other elements.",
            "updatedAt": "2025-10-13T21:28:15.758Z"
          },
          {
            "id": 3,
            "title": "Implement zoom functionality",
            "description": "Add mouse wheel zoom with cursor centering and enforce zoom range from 0.1x to 10x.",
            "dependencies": [
              1
            ],
            "details": "In the wheel event, calculate zoom factor based on deltaY, clamp between 0.1 and 10. Adjust zoom level and recompute viewport to center on cursor position. Use transform or scale on the canvas rendering context. Update zoomLevel variable.",
            "status": "done",
            "testStrategy": "Scroll mouse wheel in and out, check that zoom scales from 0.1x to 10x and centers on cursor. Verify zoom stops at limits.",
            "updatedAt": "2025-10-13T21:28:17.092Z"
          },
          {
            "id": 4,
            "title": "Update viewport tracking",
            "description": "Maintain and update viewport properties like offset and zoom level for accurate rendering.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create a viewport object with properties: offsetX, offsetY, zoom. Update these in pan and zoom handlers. Use these to transform world coordinates to screen coordinates in rendering functions. Ensure viewport is reset or initialized properly.",
            "status": "done",
            "testStrategy": "After pan and zoom, inspect viewport values and confirm they match expected changes based on mouse movements.",
            "updatedAt": "2025-10-13T21:28:18.386Z"
          },
          {
            "id": 5,
            "title": "Optimize for 60 FPS performance",
            "description": "Ensure smooth performance using requestAnimationFrame for updates.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Wrap pan and zoom updates in requestAnimationFrame to limit to 60 FPS. Debounce rapid events if necessary. Profile with DevTools to confirm no frame drops during interactions. Optimize rendering by only updating changed parts if possible.",
            "status": "done",
            "testStrategy": "Use DevTools Performance tab to record interactions, verify frame rate stays at 60 FPS with no drops during rapid pan and zoom.",
            "updatedAt": "2025-10-13T21:28:20.031Z"
          }
        ],
        "updatedAt": "2025-10-13T21:28:20.031Z"
      },
      {
        "id": 8,
        "title": "Implement object creation",
        "description": "Enable creation of rectangles and circles on the canvas via click-and-drag.",
        "details": "In canvas.js, add tool modes for rectangle ('R') and circle ('C'). On mouse down, start creation; on mouse up, finalize object with properties (id, type, x, y, width/height/radius, color). Use PIXI.Graphics for rendering. Generate unique IDs.",
        "testStrategy": "Switch to rectangle tool, click-drag to create. Repeat for circle. Verify objects appear with correct properties. Check keyboard shortcuts switch modes.",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Add tool modes for rectangle and circle creation",
            "description": "Implement tool modes in canvas.js to switch between rectangle ('R') and circle ('C') creation modes using keyboard shortcuts.",
            "dependencies": [],
            "details": "Modify the canvas.js file to include a mode variable that can be set to 'rectangle' or 'circle' based on key presses 'R' and 'C'. Ensure the mode affects the creation behavior.",
            "status": "pending",
            "testStrategy": "Press 'R' and 'C' keys and verify the mode changes via console logs or UI indicators."
          },
          {
            "id": 2,
            "title": "Handle mouse down event to start object creation",
            "description": "Add event listener for mouse down to initiate the creation of a rectangle or circle based on the current tool mode.",
            "dependencies": [
              1
            ],
            "details": "In canvas.js, attach a mousedown event listener to the canvas. On mousedown, record the starting point (x, y) and create a temporary PIXI.Graphics object for previewing the shape being drawn.",
            "status": "pending",
            "testStrategy": "Switch to rectangle mode, click on canvas, and check if a temporary graphic appears at the click position."
          },
          {
            "id": 3,
            "title": "Handle mouse move event to update shape during drag",
            "description": "Implement mouse move event to dynamically update the dimensions of the rectangle or circle as the user drags.",
            "dependencies": [
              2
            ],
            "details": "Add a mousemove event listener that, while dragging, calculates width/height for rectangle or radius for circle based on current mouse position and starting point, then redraws the temporary PIXI.Graphics object.",
            "status": "pending",
            "testStrategy": "Start dragging after mousedown, move mouse, and verify the shape resizes in real-time on the canvas."
          },
          {
            "id": 4,
            "title": "Handle mouse up event to finalize object creation",
            "description": "On mouse up, finalize the object by assigning properties and adding it to the canvas permanently.",
            "dependencies": [
              3
            ],
            "details": "In the mouseup event listener, remove the temporary graphic, create a new PIXI.Graphics object with final dimensions, assign properties like id, type, x, y, width/height/radius, color, and add it to the canvas stage.",
            "status": "pending",
            "testStrategy": "Complete a click-drag action, release mouse, and confirm a permanent object appears with correct size and properties."
          },
          {
            "id": 5,
            "title": "Implement unique ID generation for objects",
            "description": "Add functionality to generate unique IDs for each created object to ensure no duplicates.",
            "dependencies": [
              4
            ],
            "details": "Create a function in canvas.js that generates unique IDs, perhaps using a counter or timestamp-based method. Assign this ID to each new object upon finalization in the mouseup handler.",
            "status": "pending",
            "testStrategy": "Create multiple objects and verify each has a unique ID by inspecting object properties or logging them."
          }
        ],
        "updatedAt": "2025-10-14T02:52:42.112Z"
      },
      {
        "id": 9,
        "title": "Implement object manipulation",
        "description": "Add selection, dragging, multi-select, and deletion for objects.",
        "details": "In canvas.js, implement select mode ('V') for clicking to select, Shift+click for multi-select. Enable dragging selected objects. Add Delete key handler for removal. Update object positions in world coordinates.",
        "testStrategy": "Create objects, select single/multiple, drag to new positions. Verify positions update correctly. Delete selected objects and confirm removal.",
        "priority": "high",
        "dependencies": [
          8
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement select mode activation",
            "description": "Add keyboard shortcut 'V' to activate select mode in canvas.js.",
            "dependencies": [],
            "details": "Modify canvas.js to listen for the 'V' key press event and set the current tool mode to 'select'. Ensure this mode allows for object selection without creating new objects.",
            "status": "pending",
            "testStrategy": "Press 'V' key and verify select mode is activated, preventing object creation."
          },
          {
            "id": 2,
            "title": "Implement single object selection",
            "description": "Enable clicking on objects to select them in select mode.",
            "dependencies": [
              1
            ],
            "details": "In canvas.js, add mouse click event handler in select mode to detect clicks on objects using PIXI's hit detection. Mark the clicked object as selected and visually indicate selection (e.g., highlight).",
            "status": "pending",
            "testStrategy": "Create an object, enter select mode, click on it, and verify it is selected and highlighted."
          },
          {
            "id": 3,
            "title": "Implement multi-select with Shift+click",
            "description": "Allow selecting multiple objects by holding Shift and clicking.",
            "dependencies": [
              2
            ],
            "details": "Extend the click handler in canvas.js to check for Shift key during click. If Shift is held, add the clicked object to the selection without deselecting others. Maintain a list of selected objects.",
            "status": "pending",
            "testStrategy": "Create multiple objects, select one, then Shift+click another, and verify both are selected."
          },
          {
            "id": 4,
            "title": "Implement dragging of selected objects",
            "description": "Enable dragging selected objects to new positions.",
            "dependencies": [
              3
            ],
            "details": "In canvas.js, add mouse down, move, and up event handlers for dragging. On mouse down on selected objects, initiate drag. Update positions during move and finalize on mouse up, converting screen coordinates to world coordinates.",
            "status": "pending",
            "testStrategy": "Select an object, drag it to a new position, and verify the position updates correctly in world coordinates."
          },
          {
            "id": 5,
            "title": "Implement deletion of selected objects",
            "description": "Add Delete key handler to remove selected objects.",
            "dependencies": [
              3
            ],
            "details": "In canvas.js, add a keydown event listener for the Delete key. When pressed, remove all selected objects from the canvas and update the object list. Ensure positions are handled in world coordinates if needed.",
            "status": "pending",
            "testStrategy": "Select one or more objects, press Delete key, and verify they are removed from the canvas."
          }
        ],
        "updatedAt": "2025-10-14T02:52:43.333Z"
      },
      {
        "id": 10,
        "title": "Implement WebSocket client",
        "description": "Develop the client-side WebSocket connection and message handling.",
        "details": "In websocket.js, create WebSocketClient class to connect to ws://host/ws/{canvas-id}. Handle auth message on connect. Implement send/receive for cursor, object operations. Add reconnection logic and throttling for cursor updates (30/sec).",
        "testStrategy": "Connect to server, send auth, verify auth-success. Send test object-create message and check server response. Test reconnection after disconnect.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create WebSocketClient class structure",
            "description": "Set up the basic WebSocketClient class in websocket.js with constructor and initial properties.",
            "dependencies": [],
            "details": "In websocket.js, define a WebSocketClient class with a constructor that takes host, canvasId, and authToken. Initialize properties like ws (WebSocket instance), isConnected (boolean), and message handlers. Ensure the class is exportable for use in other modules.",
            "status": "done",
            "testStrategy": "Basic verification: run and ensure no errors.",
            "updatedAt": "2025-10-13T21:27:55.378Z"
          },
          {
            "id": 2,
            "title": "Implement WebSocket connection and authentication",
            "description": "Establish the WebSocket connection to the server and handle the initial authentication message.",
            "dependencies": [
              1
            ],
            "details": "In the WebSocketClient class, add a connect() method that creates a new WebSocket connection to ws://host/ws/{canvas-id}. On connection open, send an auth message with the authToken. Listen for auth-success or auth-failure responses and handle accordingly, updating connection status.",
            "status": "done",
            "testStrategy": "Connect to a test server, verify WebSocket opens, send auth message, and check for auth-success response.",
            "updatedAt": "2025-10-13T21:28:21.428Z"
          },
          {
            "id": 3,
            "title": "Implement message sending and receiving for cursor and object operations",
            "description": "Add methods to send and receive messages for cursor updates and object manipulations.",
            "dependencies": [
              2
            ],
            "details": "In the WebSocketClient class, implement sendMessage() method to send JSON messages for cursor positions and object operations (create, update, delete). Add onMessage handler to parse incoming messages and dispatch to appropriate handlers for cursor updates and object changes. Ensure messages are properly formatted as JSON.",
            "status": "done",
            "testStrategy": "Send a test cursor update message and verify it's received. Send an object-create message and check the response.",
            "updatedAt": "2025-10-13T21:28:22.890Z"
          },
          {
            "id": 4,
            "title": "Add reconnection logic",
            "description": "Implement automatic reconnection when the WebSocket connection is lost.",
            "dependencies": [
              2
            ],
            "details": "In the WebSocketClient class, add an onClose handler that attempts to reconnect after a delay (e.g., exponential backoff). Track reconnection attempts and stop after a maximum number. Re-authenticate upon successful reconnection. Provide a method to manually disconnect.",
            "status": "done",
            "testStrategy": "Disconnect the WebSocket manually, verify automatic reconnection occurs, and auth is re-sent.",
            "updatedAt": "2025-10-13T21:28:24.212Z"
          },
          {
            "id": 5,
            "title": "Implement throttling for cursor updates",
            "description": "Add throttling to limit cursor update messages to 30 per second.",
            "dependencies": [
              3
            ],
            "details": "In the WebSocketClient class, implement a throttling mechanism using a timer or library to ensure cursor position updates are sent at most 30 times per second. Buffer or drop excess updates. Integrate this into the cursor sending logic to prevent flooding the server.",
            "status": "done",
            "testStrategy": "Simulate rapid cursor movements and verify that no more than 30 updates are sent per second.",
            "updatedAt": "2025-10-13T21:28:25.505Z"
          }
        ],
        "updatedAt": "2025-10-13T21:28:25.505Z"
      },
      {
        "id": 11,
        "title": "Implement real-time synchronization for objects",
        "description": "Sync object creation, updates, and deletions across all connected clients.",
        "details": "Integrate WebSocketClient with CanvasManager: on local object create/update/delete, send message. On receive, update canvas. Broadcast via server. Use last-write-wins for conflicts.",
        "testStrategy": "Open two browser windows, create/update/delete objects in one, verify immediate sync in the other. Check latency <100ms with network tools.",
        "priority": "high",
        "dependencies": [
          9,
          10
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate WebSocketClient for sending object change messages",
            "description": "Modify CanvasManager to send WebSocket messages whenever an object is created, updated, or deleted locally.",
            "dependencies": [],
            "details": "In CanvasManager, hook into object creation, update, and deletion events to serialize the object data (id, type, position, etc.) into a JSON message and send it via WebSocketClient to the server.",
            "status": "pending",
            "testStrategy": "Use browser console to verify messages are sent on object actions, check network tab for WebSocket frames."
          },
          {
            "id": 2,
            "title": "Implement handling of incoming WebSocket messages for canvas updates",
            "description": "Update CanvasManager to listen for incoming WebSocket messages and apply the received object changes to the canvas.",
            "dependencies": [
              1
            ],
            "details": "Add a WebSocket message handler in CanvasManager that parses incoming JSON messages for object create, update, or delete operations, and updates the local canvas state accordingly, ensuring UI reflects changes.",
            "status": "pending",
            "testStrategy": "Send manual WebSocket messages from server and observe canvas updates in real-time without local actions."
          },
          {
            "id": 3,
            "title": "Set up server-side broadcasting of object change messages",
            "description": "Implement server logic to broadcast received WebSocket messages to all connected clients except the sender.",
            "dependencies": [
              2
            ],
            "details": "In the server code, upon receiving a message from a client, relay it to all other connected WebSocket clients, ensuring efficient broadcasting without echoing back to the originator.",
            "status": "pending",
            "testStrategy": "Connect multiple clients, perform an action on one, and verify the message is received by others via server logs or client-side logs."
          },
          {
            "id": 4,
            "title": "Implement last-write-wins conflict resolution",
            "description": "Add logic to handle concurrent updates by prioritizing the latest timestamped change.",
            "dependencies": [
              3
            ],
            "details": "Attach timestamps to all object change messages. In the message handler, compare timestamps on conflicts (e.g., simultaneous updates to the same object) and apply the most recent one, discarding older changes.",
            "status": "pending",
            "testStrategy": "Simulate conflicts by rapidly updating the same object from two clients and verify only the latest change persists."
          },
          {
            "id": 5,
            "title": "Test end-to-end real-time synchronization",
            "description": "Perform comprehensive testing to ensure synchronization works across clients with low latency.",
            "dependencies": [
              4
            ],
            "details": "Open multiple browser windows, create, update, and delete objects in one, and verify immediate reflection in others. Use network tools to confirm latency under 100ms and handle edge cases like disconnections.",
            "status": "pending",
            "testStrategy": "Follow the test strategy from the parent task: Open two browser windows, perform actions in one, check sync in the other, measure latency."
          }
        ],
        "updatedAt": "2025-10-14T02:52:44.596Z"
      },
      {
        "id": 12,
        "title": "Implement cursor synchronization",
        "description": "Enable real-time cursor position sharing with presence.",
        "details": "In websocket.js, send cursor updates on mouse move (throttled). On receive, render remote cursors with username labels in unique colors. Update presence list on connect/disconnect.",
        "testStrategy": "Move mouse in one window, verify cursor appears in others with <50ms latency. Check presence list updates on join/leave.",
        "priority": "medium",
        "dependencies": [
          10
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up mouse move event listener with throttling",
            "description": "Implement a throttled mouse move event listener in the canvas to capture cursor positions efficiently.",
            "dependencies": [],
            "details": "In canvas.js, add an event listener for mousemove events on the canvas element. Use a throttling mechanism (e.g., lodash.throttle or custom implementation) to limit updates to every 50ms or less to avoid excessive sending.",
            "status": "pending",
            "testStrategy": "Move mouse rapidly and verify that position updates are throttled, not sent on every pixel movement."
          },
          {
            "id": 2,
            "title": "Send cursor position updates via WebSocket",
            "description": "Modify websocket.js to send cursor position data on throttled mouse moves.",
            "dependencies": [
              1
            ],
            "details": "In websocket.js, on each throttled mouse move, send a message containing the current cursor x, y coordinates, username, and a unique color identifier via the WebSocket connection.",
            "status": "pending",
            "testStrategy": "Move mouse and use browser dev tools to inspect WebSocket messages, confirming position data is sent with username and color."
          },
          {
            "id": 3,
            "title": "Receive and parse cursor updates from WebSocket",
            "description": "Handle incoming WebSocket messages for cursor positions from other users.",
            "dependencies": [
              2
            ],
            "details": "In websocket.js, add a message handler to receive cursor update messages, parse the JSON payload to extract position, username, and color, and store or update a list of remote cursors.",
            "status": "pending",
            "testStrategy": "Open multiple browser windows, move mouse in one, and check console logs in others for received messages with correct data."
          },
          {
            "id": 4,
            "title": "Render remote cursors with username labels and unique colors",
            "description": "Display remote cursors on the canvas with labels and colors.",
            "dependencies": [
              3
            ],
            "details": "In canvas.js, for each remote cursor in the list, render a cursor icon (e.g., a small arrow or dot) at the received position, add a text label with the username, and apply the unique color. Update positions in real-time as new messages arrive.",
            "status": "pending",
            "testStrategy": "With multiple users, move cursors and verify they appear in other windows with labels, colors, and <50ms latency using browser performance tools."
          },
          {
            "id": 5,
            "title": "Update presence list on user connect and disconnect",
            "description": "Maintain and display a list of online users based on WebSocket connections.",
            "dependencies": [
              3
            ],
            "details": "In websocket.js, on WebSocket open (connect), send a join message with username. On close (disconnect), send a leave message. Maintain a presence list and update the UI (e.g., a sidebar) to show current online users.",
            "status": "pending",
            "testStrategy": "Open/close browser windows and check that the presence list updates immediately on join/leave, reflecting accurate user counts."
          }
        ],
        "updatedAt": "2025-10-14T02:52:45.813Z"
      },
      {
        "id": 13,
        "title": "Implement state persistence",
        "description": "Save and load canvas state to/from SQLite database.",
        "details": "In canvas-state.lisp, implement save function with debounced updates (500ms). Load state on connection via GET /api/canvas/state. Store as JSON blob in canvas_states table.",
        "testStrategy": "Create objects, refresh page, verify state persists. Disconnect all users, reconnect, check state loads. Confirm debouncing prevents excessive saves.",
        "priority": "high",
        "dependencies": [
          2,
          11
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Create canvas_states table in SQLite",
            "description": "Set up the database schema for storing canvas state as JSON blobs.",
            "dependencies": [],
            "details": "Create a table named 'canvas_states' with columns: id (primary key, auto-increment), state_json (text for JSON blob), and timestamp (datetime for last update). Ensure the table is created in the SQLite database used by the application.",
            "status": "pending",
            "testStrategy": "Run a database query to verify the table exists with correct columns."
          },
          {
            "id": 2,
            "title": "Implement debounced save function in canvas-state.lisp",
            "description": "Develop a function to save the current canvas state to the database with debouncing to prevent excessive saves.",
            "dependencies": [
              1
            ],
            "details": "In canvas-state.lisp, create a save-canvas-state function that serializes the canvas state to JSON and inserts/updates it in the canvas_states table. Implement debouncing using a timer (500ms delay) to batch saves and avoid overloading the database on rapid changes.",
            "status": "pending",
            "testStrategy": "Simulate rapid canvas changes and check that saves occur only after 500ms of inactivity, verifying database entries."
          },
          {
            "id": 3,
            "title": "Implement load state function for GET /api/canvas/state",
            "description": "Create a backend endpoint to retrieve and return the persisted canvas state.",
            "dependencies": [
              1
            ],
            "details": "In canvas-state.lisp, add a handler for GET /api/canvas/state that queries the canvas_states table for the latest state JSON, parses it, and returns it in the response. Handle cases where no state exists (return empty or default state).",
            "status": "pending",
            "testStrategy": "Use curl or a browser to call the endpoint and verify it returns the correct JSON state or default when no data is present."
          },
          {
            "id": 4,
            "title": "Integrate saving on canvas state changes",
            "description": "Connect the save function to trigger whenever the canvas state is modified.",
            "dependencies": [
              2
            ],
            "details": "Modify the canvas manipulation code (e.g., in canvas.js or related Lisp functions) to call the debounced save function whenever objects are created, moved, or deleted. Ensure the state includes all necessary object properties for accurate restoration.",
            "status": "pending",
            "testStrategy": "Create and modify objects on the canvas, then check the database to confirm the state is saved correctly after debouncing."
          },
          {
            "id": 5,
            "title": "Integrate loading on client connection",
            "description": "Ensure the canvas state is loaded from the database when a user connects or refreshes the page.",
            "dependencies": [
              3
            ],
            "details": "In the client-side code (e.g., canvas.js), add logic to fetch the state via GET /api/canvas/state on page load or connection, and populate the canvas with the loaded objects. Handle authentication if required, and merge or replace existing state appropriately.",
            "status": "pending",
            "testStrategy": "Refresh the page after making changes, verify that the canvas reloads with the persisted state. Test with multiple users or disconnections."
          }
        ],
        "updatedAt": "2025-10-14T02:52:47.049Z"
      },
      {
        "id": 14,
        "title": "Implement user interface components",
        "description": "Build the UI for toolbar, presence list, and status bar.",
        "details": "In HTML/CSS/JS, create toolbar for tools (select, rectangle, circle), color picker. Add presence list in top-right. Implement status bar for tool, position, zoom. Ensure dark theme consistency.",
        "testStrategy": "Verify toolbar switches tools, presence shows online users, status updates correctly. Check UI doesn't obstruct canvas and is responsive.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Create toolbar with tool buttons and color picker",
            "description": "Design and implement the toolbar containing buttons for select, rectangle, and circle tools, along with a color picker component.",
            "dependencies": [],
            "details": "In HTML, add a div for the toolbar. Use CSS for styling with dark theme. In JS, create buttons for each tool and a color input. Attach event listeners to switch tool modes in canvas.js.",
            "status": "pending",
            "testStrategy": "Click each tool button and verify the active tool changes. Select a color and confirm it applies to new objects."
          },
          {
            "id": 2,
            "title": "Implement presence list in top-right corner",
            "description": "Build the presence list component to display online users in the top-right area of the interface.",
            "dependencies": [
              1
            ],
            "details": "Add a div in the top-right of the page layout. Use JS to fetch and display user list from backend. Style with dark theme CSS. Update list on user join/leave events.",
            "status": "pending",
            "testStrategy": "Simulate multiple users logging in and verify the list updates in real-time. Check positioning doesn't overlap with other UI elements."
          },
          {
            "id": 3,
            "title": "Develop status bar for tool, position, and zoom info",
            "description": "Create the status bar at the bottom to show current tool, mouse position, and zoom level.",
            "dependencies": [
              1
            ],
            "details": "Insert a status bar div at the bottom of the page. In JS, update text content based on current tool, mouse coordinates, and zoom factor. Ensure responsive design and dark theme.",
            "status": "pending",
            "testStrategy": "Switch tools and move mouse; verify status bar updates accurately. Zoom in/out and check zoom display changes."
          },
          {
            "id": 4,
            "title": "Apply dark theme consistency across UI components",
            "description": "Ensure all toolbar, presence list, and status bar elements adhere to the dark theme color scheme.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Define CSS variables for dark theme colors (e.g., background, text, borders). Apply these to all UI elements created. Test for consistency in visibility and aesthetics.",
            "status": "pending",
            "testStrategy": "Inspect UI in browser dev tools for color consistency. Verify readability and contrast in dark mode."
          },
          {
            "id": 5,
            "title": "Integrate UI components into main layout",
            "description": "Position and integrate the toolbar, presence list, and status bar into the overall page layout without obstructing the canvas.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Use CSS flexbox or grid to arrange components: toolbar top-left, presence top-right, status bottom. Ensure canvas remains central and unobstructed. Make layout responsive.",
            "status": "pending",
            "testStrategy": "Resize browser window and confirm UI elements adjust properly. Verify canvas interaction isn't blocked by UI overlays."
          }
        ],
        "updatedAt": "2025-10-14T02:52:48.264Z"
      },
      {
        "id": 15,
        "title": "Deploy application to Fly.io",
        "description": "Containerize and deploy the application to Fly.io for public access.",
        "details": "Create Dockerfile as specified. Build frontend and backend. Configure fly.toml. Use fly deploy. Ensure health check endpoint.",
        "testStrategy": "Access deployed URL, test full flow: register, login, create objects, sync with another user. Verify performance and no errors in logs.",
        "priority": "high",
        "dependencies": [
          13,
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Dockerfile and containerize the application",
            "description": "Develop a Dockerfile to containerize both the frontend and backend components of the application, ensuring all dependencies are included and the app can run in a containerized environment.",
            "dependencies": [],
            "details": "Use a Debian base image, install necessary tools like SBCL, Quicklisp, Node.js for Vite build. Copy backend and frontend code, run builds for both, expose necessary ports (e.g., 8080 for backend), and set the entrypoint to start the server. Ensure the Dockerfile follows best practices for multi-stage builds if applicable.",
            "status": "pending",
            "testStrategy": "Build the Docker image locally and run it to verify the application starts without errors, checking logs for successful initialization."
          },
          {
            "id": 2,
            "title": "Configure Fly.io deployment settings",
            "description": "Set up the fly.toml configuration file with necessary settings for deploying the containerized application to Fly.io, including app name, region, and health checks.",
            "dependencies": [
              1
            ],
            "details": "Create or edit fly.toml to specify the app name, source directory, build command (if needed), services with internal port mapping, health check endpoint (e.g., /health), and any environment variables required for the application. Ensure compatibility with Fly.io's deployment requirements.",
            "status": "pending",
            "testStrategy": "Validate the fly.toml file using Fly CLI commands like 'fly config validate' to ensure no syntax errors and proper configuration."
          },
          {
            "id": 3,
            "title": "Deploy to Fly.io and verify functionality",
            "description": "Execute the deployment to Fly.io using the configured settings and perform end-to-end testing to ensure the application is publicly accessible and fully functional.",
            "dependencies": [
              2
            ],
            "details": "Run 'fly deploy' to push the containerized app to Fly.io. Monitor the deployment logs for success. Once deployed, access the public URL and test the full application flow including user registration, login, canvas object creation, and synchronization between users. Check application logs for any errors.",
            "status": "pending",
            "testStrategy": "Access the deployed URL and perform manual tests: register a user, log in, create and manipulate canvas objects, verify real-time sync with another user session. Monitor performance and check for no errors in Fly.io logs or console."
          }
        ],
        "updatedAt": "2025-10-14T02:52:04.930Z"
      },
      {
        "id": 16,
        "title": "Database Schema Updates for Version Tracking",
        "description": "Modify the database schema to add version tracking fields to canvas objects and create a conflict log table as specified in the PRD.",
        "details": "Execute the provided SQL statements to alter the canvas_objects table by adding 'version' (INTEGER DEFAULT 1), 'last_modified_by' (INTEGER REFERENCES users(id)), and 'last_modified_at' (TIMESTAMP DEFAULT CURRENT_TIMESTAMP) columns. Create the object_conflicts table with the specified schema including id (SERIAL PRIMARY KEY), canvas_id (TEXT NOT NULL), object_id (TEXT NOT NULL), user_id (INTEGER REFERENCES users(id)), client_version (INTEGER NOT NULL), server_version (INTEGER NOT NULL), attempted_changes (JSON), conflict_type (TEXT), resolved_at (TIMESTAMP), and resolution_type (TEXT). Ensure the database supports JSON for attempted_changes. Use transactions to apply changes safely.",
        "testStrategy": "Unit test the schema changes by inserting sample data into canvas_objects and object_conflicts tables, verifying that version increments correctly and foreign key constraints are enforced. Integration test with existing queries to ensure no performance regression.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Alter canvas_objects table and create object_conflicts table",
            "description": "Modify the database schema by adding version tracking fields to the canvas_objects table and creating the new object_conflicts table as specified.",
            "dependencies": [],
            "details": "Execute SQL statements to alter the canvas_objects table by adding 'version' (INTEGER DEFAULT 1), 'last_modified_by' (INTEGER REFERENCES users(id)), and 'last_modified_at' (TIMESTAMP DEFAULT CURRENT_TIMESTAMP) columns. Create the object_conflicts table with id (SERIAL PRIMARY KEY), canvas_id (TEXT NOT NULL), object_id (TEXT NOT NULL), user_id (INTEGER REFERENCES users(id)), client_version (INTEGER NOT NULL), server_version (INTEGER NOT NULL), attempted_changes (JSON), conflict_type (TEXT), resolved_at (TIMESTAMP), and resolution_type (TEXT). Ensure JSON support for attempted_changes. Use transactions for safe application.",
            "status": "pending",
            "testStrategy": "Insert sample data into both tables and verify constraints and data integrity."
          },
          {
            "id": 2,
            "title": "Validate database schema changes",
            "description": "Ensure the schema modifications are correct and do not introduce regressions in the database.",
            "dependencies": [
              1
            ],
            "details": "After applying the schema changes, run validation checks including verifying table structures, foreign key constraints, and JSON support. Test with sample inserts and queries to confirm the database behaves as expected without performance issues.",
            "status": "pending",
            "testStrategy": "Perform unit tests by inserting data and checking version increments, and integration tests with existing queries to ensure no regressions."
          }
        ]
      },
      {
        "id": 17,
        "title": "Implement Object Version Management in Backend",
        "description": "Extend the backend canvas-state.lisp to handle version tracking for canvas objects, ensuring versions increment on updates.",
        "details": "In canvas-state.lisp, modify the object update functions to read and increment the version field. For each object, store the version in memory cache and persist to database. Implement a function to retrieve the current version of an object. Use optimistic locking by checking the version before applying changes. Pseudo-code: (defun update-object (object-id updates client-version) (let ((current-version (get-object-version object-id))) (if (= client-version current-version) (progn (apply-updates object-id updates) (increment-version object-id) t) nil)))",
        "testStrategy": "Unit tests for version increment logic and retrieval. Mock database interactions to verify version checks prevent stale updates.",
        "priority": "high",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Modify Object Update Functions for Version Tracking",
            "description": "Update the object update functions in canvas-state.lisp to read and increment the version field for each canvas object.",
            "dependencies": [],
            "details": "In canvas-state.lisp, locate the existing update functions (e.g., for position, properties). Add logic to retrieve the current version, increment it after successful updates, and persist the new version to the database. Ensure the version is stored as an integer field in the object structure.",
            "status": "pending",
            "testStrategy": "Unit tests to verify version increments correctly on updates, using mock objects and database interactions."
          },
          {
            "id": 2,
            "title": "Implement Version Caching in Memory",
            "description": "Add in-memory caching for object versions to improve performance and reduce database queries.",
            "dependencies": [
              1
            ],
            "details": "Integrate a memory cache (e.g., using a hash table in Lisp) to store object versions. On updates, update the cache synchronously with database persistence. Implement cache invalidation or refresh mechanisms if needed for consistency.",
            "status": "pending",
            "testStrategy": "Integration tests to check cache updates on version changes, simulating multiple updates and verifying cache accuracy."
          },
          {
            "id": 3,
            "title": "Add Optimistic Locking Logic",
            "description": "Implement optimistic locking by checking client-provided versions against current versions before applying updates.",
            "dependencies": [
              1,
              2
            ],
            "details": "Modify the update-object function as per the pseudo-code: check if client-version matches current-version, apply updates only if they match, then increment version. Return success/failure indicators. Handle version mismatches by rejecting stale updates.",
            "status": "pending",
            "testStrategy": "Unit tests for locking logic, including scenarios with matching and mismatching versions, ensuring no updates on conflicts."
          }
        ]
      },
      {
        "id": 18,
        "title": "Update WebSocket Protocol for Version Fields",
        "description": "Modify websocket.lisp to include version fields in update messages and handle new conflict-related message types.",
        "details": "Update the WebSocket message handlers in websocket.lisp to parse and send version fields in 'object-update' messages. Add handlers for 'object-conflict' and 'resolve-conflict' message types. Implement sending 'object-update-success' and 'object-conflict' responses. Pseudo-code: (defun handle-object-update (message) (let ((object-id (getf message :object-id)) (version (getf message :version)) (updates (getf message :updates))) (if (update-object object-id updates version) (send-success object-id (1+ version)) (send-conflict object-id version (get-server-version object-id) ...))))",
        "testStrategy": "Integration tests for WebSocket message flows, simulating client-server interactions with version mismatches to ensure correct conflict detection and notifications.",
        "priority": "high",
        "dependencies": [
          17
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update WebSocket Message Handlers for Version Fields",
            "description": "Modify the existing WebSocket message handlers in websocket.lisp to parse and include version fields in 'object-update' messages, ensuring proper extraction of object-id, version, and updates from incoming messages.",
            "dependencies": [],
            "details": "In websocket.lisp, update the handle-object-update function to extract the :version field from the message plist. Modify the update-object function call to pass the version parameter for version checking. Ensure the handler correctly processes the message structure as per the pseudo-code provided, integrating with the existing message routing logic.",
            "status": "pending",
            "testStrategy": "Unit tests for message parsing, verifying that version fields are correctly extracted and passed to update functions. Simulate incoming messages with version data to check handler behavior."
          },
          {
            "id": 2,
            "title": "Add Handlers for New Conflict-Related Message Types",
            "description": "Implement new message handlers in websocket.lisp for 'object-conflict' and 'resolve-conflict' message types to manage version conflicts in collaborative updates.",
            "dependencies": [
              1
            ],
            "details": "Add functions like handle-object-conflict and handle-resolve-conflict in websocket.lisp. For 'object-conflict', parse incoming conflict notifications and prepare for resolution. For 'resolve-conflict', handle client-side resolution messages by updating the server state accordingly. Integrate these into the main message routing dispatcher, ensuring they work with the room management system.",
            "status": "pending",
            "testStrategy": "Integration tests simulating conflict scenarios: send conflicting updates and verify that 'object-conflict' messages are triggered and handled correctly. Test resolution flows to ensure state consistency."
          },
          {
            "id": 3,
            "title": "Implement Sending of Update Success and Conflict Responses",
            "description": "Add functionality to send 'object-update-success' and 'object-conflict' response messages from the server in websocket.lisp based on update outcomes.",
            "dependencies": [
              2
            ],
            "details": "Implement send-success and send-conflict functions that broadcast or send targeted messages to clients. For success, include the updated object-id and new version (e.g., 1+ version). For conflicts, send the object-id, client version, and server version. Ensure these are called from the handle-object-update function as per the pseudo-code, using the WebSocket broadcasting mechanisms established in the server infrastructure.",
            "status": "pending",
            "testStrategy": "End-to-end tests for message flows: Simulate successful updates and verify 'object-update-success' is sent. Trigger version mismatches to confirm 'object-conflict' responses are dispatched correctly, checking client-side receipt."
          }
        ]
      },
      {
        "id": 19,
        "title": "Develop Conflict Detection Engine",
        "description": "Create a conflict detection engine that compares versions and logs conflicts when detected.",
        "details": "In a new or extended module (e.g., conflict-engine.lisp), implement version comparison logic. When an update is attempted with a stale version, log the conflict to the object_conflicts table with details like client_version, server_version, attempted_changes, and conflict_type. Pseudo-code: (defun detect-conflict (object-id client-version) (let ((server-version (get-server-version object-id))) (unless (= client-version server-version) (log-conflict object-id client-version server-version ...) t))) Integrate this into the update process.",
        "testStrategy": "Unit tests for conflict detection algorithm, ensuring it correctly identifies version mismatches. Test logging by verifying database entries after simulated conflicts.",
        "priority": "high",
        "dependencies": [
          16,
          17,
          18
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Version Comparison Logic",
            "description": "Develop the core logic to compare client and server versions for detecting conflicts in the conflict detection engine.",
            "dependencies": [],
            "details": "In the conflict-engine.lisp module, implement a function to retrieve the server version for a given object ID and compare it with the client version. Use the provided pseudo-code as a basis: (defun detect-conflict (object-id client-version) (let ((server-version (get-server-version object-id))) (unless (= client-version server-version) ... t))). Ensure the comparison handles integer versions accurately and returns true if a conflict is detected.",
            "status": "pending",
            "testStrategy": "Unit tests to verify correct detection of version mismatches, including edge cases like equal versions and large version numbers."
          },
          {
            "id": 2,
            "title": "Implement Conflict Logging",
            "description": "Create functionality to log detected conflicts to the database with necessary details.",
            "dependencies": [
              1
            ],
            "details": "Extend the conflict-engine.lisp module to include a log-conflict function that inserts records into the object_conflicts table. Include fields such as object_id, client_version, server_version, attempted_changes, and conflict_type. Use database utilities from database.lisp to execute the insert query securely, handling any potential database errors.",
            "status": "pending",
            "testStrategy": "Integration tests simulating conflicts and verifying that database entries are created correctly with all required fields populated."
          },
          {
            "id": 3,
            "title": "Integrate Conflict Detection with Update Process",
            "description": "Incorporate the conflict detection engine into the existing update workflow to check for conflicts before applying changes.",
            "dependencies": [
              1,
              2
            ],
            "details": "Modify the update process in the relevant module (likely canvas.lisp or similar) to call the detect-conflict function before proceeding with any object updates. If a conflict is detected, prevent the update and ensure the conflict is logged. Integrate seamlessly with WebSocket message handling for real-time conflict detection during collaborative operations.",
            "status": "pending",
            "testStrategy": "End-to-end tests using WebSocket connections to simulate update attempts with stale versions, confirming conflicts are detected, logged, and updates are blocked appropriately."
          }
        ]
      },
      {
        "id": 20,
        "title": "Implement Conflict Notification System",
        "description": "Set up real-time notifications for conflicts to affected clients via WebSocket.",
        "details": "Extend websocket.lisp to send 'object-conflict' messages to the client when a conflict is detected, including serverState, attemptedChanges, and conflictingUser. Ensure notifications are pushed immediately. For successful updates, broadcast 'object-update-success' to all connected clients for real-time sync. Pseudo-code: (defun notify-conflict (client-socket object-id ...) (send-message client-socket (make-conflict-message object-id ...)))",
        "testStrategy": "Integration tests with multiple WebSocket clients to verify conflict notifications are sent correctly and only to affected users. End-to-end tests for real-time sync of non-conflicting updates.",
        "priority": "high",
        "dependencies": [
          18,
          19
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Extend WebSocket for Conflict Messages",
            "description": "Modify websocket.lisp to send 'object-conflict' messages to the affected client when a conflict is detected, including details like serverState, attemptedChanges, and conflictingUser.",
            "dependencies": [],
            "details": "Update the WebSocket implementation in websocket.lisp to include a function that detects conflicts and immediately sends targeted 'object-conflict' messages to the specific client socket involved in the conflict. Ensure the message format includes object-id, serverState, attemptedChanges, and conflictingUser for proper client-side handling.",
            "status": "pending",
            "testStrategy": "Integration tests with multiple WebSocket clients to verify conflict notifications are sent correctly and only to affected users."
          },
          {
            "id": 2,
            "title": "Implement Broadcasting of Update Successes",
            "description": "Add functionality to broadcast 'object-update-success' messages to all connected clients when an update succeeds, ensuring real-time synchronization.",
            "dependencies": [
              1
            ],
            "details": "Extend websocket.lisp to broadcast 'object-update-success' messages to all connected WebSocket clients upon successful object updates. This should include the updated object details to allow clients to sync their states in real-time without conflicts.",
            "status": "pending",
            "testStrategy": "End-to-end tests for real-time sync of non-conflicting updates across multiple clients."
          }
        ]
      },
      {
        "id": 21,
        "title": "Design and Implement Conflict Resolution UI",
        "description": "Create frontend UI components for detecting and resolving conflicts, including visual indicators and resolution modal.",
        "details": "In the frontend JavaScript, add a modal or sidebar that appears on receiving 'object-conflict' WebSocket message. Display side-by-side diffs of client and server states. Provide buttons for 'overwrite', 'discard', or 'merge' resolutions. On resolution, send 'resolve-conflict' message. Add visual indicators (e.g., red border) on conflicting objects. Use libraries like React for UI components if applicable. Pseudo-code: (function handleConflict(message) { showModal(message.objectId, message.serverState, message.attemptedChanges); }) (function resolveConflict(resolution) { sendWebSocket({type: 'resolve-conflict', resolution: resolution, ...}); })",
        "testStrategy": "UI unit tests for modal rendering and button interactions. Integration tests simulating WebSocket conflicts to verify UI appears and resolutions are sent correctly.",
        "priority": "high",
        "dependencies": [
          20
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design the Conflict Resolution Modal",
            "description": "Design the UI layout and structure for the modal or sidebar that appears when a conflict is detected, including placeholders for diff display and buttons.",
            "dependencies": [],
            "details": "Create wireframes or mockups for the modal, ensuring it is responsive and user-friendly. Include areas for displaying object ID, side-by-side diffs, and resolution options. Use React components if applicable, and ensure accessibility standards are met.",
            "status": "pending",
            "testStrategy": "UI design reviews and mockup validations with stakeholders to ensure usability."
          },
          {
            "id": 2,
            "title": "Implement Side-by-Side Diff Display",
            "description": "Implement the functionality to display side-by-side diffs of client and server states within the modal.",
            "dependencies": [],
            "details": "Develop code to render differences between client and server states, highlighting changes in color (e.g., green for additions, red for deletions). Integrate with the modal component, using libraries like diff-match-patch if needed. Ensure the display is scrollable for large diffs.",
            "status": "pending",
            "testStrategy": "Unit tests for diff rendering with sample data, verifying correct highlighting and layout."
          },
          {
            "id": 3,
            "title": "Add Resolution Buttons and Actions",
            "description": "Add buttons for 'overwrite', 'discard', or 'merge' resolutions, and handle user interactions.",
            "dependencies": [],
            "details": "Implement buttons in the modal that trigger resolution actions. For merge, provide a simple interface if needed. On button click, prepare the resolution data. Ensure buttons are disabled during processing to prevent multiple submissions.",
            "status": "pending",
            "testStrategy": "UI interaction tests to verify button clicks trigger correct actions and modal updates."
          },
          {
            "id": 4,
            "title": "Integrate with WebSocket for Conflict Handling",
            "description": "Integrate the UI components with WebSocket messages for receiving conflicts and sending resolutions.",
            "dependencies": [],
            "details": "Add event listeners for 'object-conflict' WebSocket messages to trigger the modal display. Implement sending 'resolve-conflict' messages upon resolution. Also, add visual indicators like red borders on conflicting objects in the canvas.",
            "status": "pending",
            "testStrategy": "Integration tests simulating WebSocket messages to ensure modal appears, indicators show, and resolutions are sent correctly."
          }
        ]
      },
      {
        "id": 22,
        "title": "Add Object Locking Visualization",
        "description": "Implement frontend features to show which objects are being edited by others, with user avatars or names.",
        "details": "Extend the frontend to display user information on objects currently being edited. Subscribe to WebSocket updates for lock status. Show avatars/names on locked objects in real-time. Use CSS overlays or tooltips. Pseudo-code: (function updateLockStatus(objectId, user) { addOverlay(objectId, user.avatar, user.name); }) Integrate with existing canvas rendering.",
        "testStrategy": "UI tests for overlay display on locked objects. End-to-end tests with multiple users to verify real-time updates of lock statuses.",
        "priority": "medium",
        "dependencies": [
          21
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Subscribe to WebSocket Updates for Lock Status",
            "description": "Implement WebSocket subscription to receive real-time updates on object lock statuses from the server.",
            "dependencies": [],
            "details": "Extend the WebSocketClient to listen for lock status messages. On receiving updates, parse the objectId and user information (avatar, name). Store lock states in a local map for quick access. Ensure subscription handles connection drops and reconnections gracefully.",
            "status": "pending",
            "testStrategy": "Unit tests for WebSocket message parsing and state updates. Integration tests to simulate server messages and verify local lock map updates."
          },
          {
            "id": 2,
            "title": "Implement CSS Overlays for Locked Objects",
            "description": "Create CSS overlays or tooltips to display user avatars and names on locked objects.",
            "dependencies": [
              1
            ],
            "details": "Design and implement CSS classes for overlays (e.g., positioned absolutely over canvas objects). Include elements for user avatar images and names. Use JavaScript to dynamically add/remove overlays based on lock status updates from the WebSocket subscription.",
            "status": "pending",
            "testStrategy": "UI tests to verify overlays appear correctly on locked objects with proper avatar and name display. Test overlay positioning and removal when locks are released."
          },
          {
            "id": 3,
            "title": "Integrate Lock Visualization with Canvas Rendering",
            "description": "Integrate the lock overlays into the existing canvas rendering system to show real-time lock status.",
            "dependencies": [
              2
            ],
            "details": "Modify the canvas rendering logic in canvas.js to check lock status before rendering each object. Call the updateLockStatus function to apply overlays. Ensure overlays update in real-time without disrupting canvas performance, using efficient DOM manipulation.",
            "status": "pending",
            "testStrategy": "End-to-end tests with multiple users: Create objects, lock them, and verify overlays appear in real-time across clients. Performance tests to ensure no rendering lag."
          }
        ]
      },
      {
        "id": 23,
        "title": "Implement Resolution Workflows and Undo",
        "description": "Enhance the conflict resolution UI with preview, undo, and advanced merge options.",
        "details": "Add preview functionality before applying resolutions, allowing users to see the final state. Implement undo after resolution by storing previous states. For merges, provide a manual merge interface for compatible changes. Pseudo-code: (function previewResolution(resolution) { renderPreview(mergeStates(clientState, serverState, resolution)); }) (function undoResolution(objectId) { revertToPreviousState(objectId); })",
        "testStrategy": "UI interaction tests for preview and undo features. Scenario-based tests for merge workflows, ensuring data integrity post-resolution.",
        "priority": "medium",
        "dependencies": [
          21
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Preview Functionality for Resolutions",
            "description": "Add preview functionality before applying resolutions to allow users to see the final merged state.",
            "dependencies": [],
            "details": "In the conflict resolution UI, implement a previewResolution function that takes a resolution object and renders a preview of the merged states using clientState, serverState, and the resolution. Use the provided pseudo-code as a base: (function previewResolution(resolution) { renderPreview(mergeStates(clientState, serverState, resolution)); }). Ensure the preview is non-destructive and updates in real-time as users adjust resolutions.",
            "status": "pending",
            "testStrategy": "UI tests to verify preview renders correctly and matches expected merged state without applying changes."
          },
          {
            "id": 2,
            "title": "Implement Undo Mechanism for Resolutions",
            "description": "Implement undo functionality after resolution by storing and reverting to previous states.",
            "dependencies": [
              1
            ],
            "details": "Add an undoResolution function that stores previous states before applying resolutions and allows reverting to them using objectId. Base on pseudo-code: (function undoResolution(objectId) { revertToPreviousState(objectId); }). Integrate state storage in the backend or client-side to maintain data integrity, ensuring undo works even after page refreshes if needed.",
            "status": "pending",
            "testStrategy": "Scenario tests: Apply resolution, undo, and verify state reverts correctly. Check data integrity post-undo."
          },
          {
            "id": 3,
            "title": "Create Manual Merge Interface for Compatible Changes",
            "description": "Provide a manual merge interface for compatible changes in conflict resolution.",
            "dependencies": [
              1
            ],
            "details": "Develop a UI component for manual merging of compatible changes, allowing users to select and combine elements from client and server states. Include options for side-by-side comparison and manual editing. Ensure it integrates with the preview functionality for a seamless workflow.",
            "status": "pending",
            "testStrategy": "Interaction tests: Simulate compatible conflicts, use merge interface to combine changes, and verify the merged result is accurate."
          },
          {
            "id": 4,
            "title": "Integrate Preview, Undo, and Merge into Conflict Resolution UI",
            "description": "Integrate all new features (preview, undo, merge) into the overall conflict resolution UI workflow.",
            "dependencies": [
              2,
              3
            ],
            "details": "Update the conflict resolution UI to incorporate the preview, undo, and manual merge features. Ensure the UI handles user interactions smoothly, such as triggering previews on resolution changes, enabling undo buttons post-resolution, and displaying merge options for compatible conflicts. Maintain high user experience and data integrity as per complexity analysis.",
            "status": "pending",
            "testStrategy": "End-to-end UI tests covering the full workflow: preview changes, apply resolution, undo if needed, and use merge options. Verify no data loss or corruption."
          }
        ]
      },
      {
        "id": 24,
        "title": "Conduct Comprehensive Testing",
        "description": "Perform unit, integration, and end-to-end testing for the object-level locking system, including load and edge case testing.",
        "details": "Run unit tests for all new functions (version management, conflict detection). Integration tests for WebSocket and database interactions. End-to-end tests simulating concurrent editing, conflicts, and resolutions with 100+ users. Test network failures and race conditions. Use tools like Jest for frontend and Lisp testing frameworks for backend.",
        "testStrategy": "Achieve 100% coverage on critical paths. Measure performance metrics like <10ms conflict checks and <100ms latency. Validate success criteria: 80% reduction in blocking, zero silent overwrites.",
        "priority": "high",
        "dependencies": [
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Unit Testing for Object-Level Locking Functions",
            "description": "Run unit tests for all new functions related to version management and conflict detection in the object-level locking system.",
            "dependencies": [],
            "details": "Use Jest for frontend unit tests and Lisp testing frameworks for backend. Cover functions like version management, conflict detection, ensuring 100% coverage on critical paths. Measure performance metrics such as <10ms for conflict checks.",
            "status": "pending",
            "testStrategy": "Achieve 100% code coverage on unit tests for new functions, validate success criteria like zero silent overwrites."
          },
          {
            "id": 2,
            "title": "Integration Testing for WebSocket and Database Interactions",
            "description": "Perform integration tests to verify interactions between WebSocket communications and database operations in the locking system.",
            "dependencies": [
              1
            ],
            "details": "Test WebSocket and database integrations for lock acquisition, release, and conflict resolution. Ensure seamless data flow and handle race conditions. Use profiling tools to maintain <100ms latency.",
            "status": "pending",
            "testStrategy": "Integration tests with mocked environments to verify correct handling of concurrent operations and data consistency."
          },
          {
            "id": 3,
            "title": "End-to-End Testing for Concurrent Editing Scenarios",
            "description": "Conduct end-to-end tests simulating real-world usage with concurrent editing, conflicts, and resolutions involving multiple users.",
            "dependencies": [
              2
            ],
            "details": "Simulate 100+ users performing concurrent edits, triggering conflicts and resolutions. Test real-time sync via WebSocket broadcasts for successful updates and conflict notifications. Validate 80% reduction in blocking.",
            "status": "pending",
            "testStrategy": "End-to-end tests with multiple browser instances or simulated clients to confirm real-time updates and conflict handling."
          },
          {
            "id": 4,
            "title": "Load Testing for Scalability and Performance",
            "description": "Execute load tests to assess the system's performance under high user load and object volume.",
            "dependencies": [
              3
            ],
            "details": "Test with 1000+ objects and 100+ users to verify scalability. Monitor conflict rates, resolution times, and ensure <5% latency increase. Implement caching and indexing as needed for optimization.",
            "status": "pending",
            "testStrategy": "Load tests in a production-like environment, measuring metrics like memory usage (<20% increase) and query performance."
          },
          {
            "id": 5,
            "title": "Edge Case Validation for Network Failures and Race Conditions",
            "description": "Validate the system against edge cases including network failures, race conditions, and unusual user behaviors.",
            "dependencies": [
              4
            ],
            "details": "Test scenarios like network disconnections, rapid successive edits causing race conditions, and invalid inputs. Ensure the system handles these gracefully without data loss or silent overwrites.",
            "status": "pending",
            "testStrategy": "Edge case tests simulating failures and anomalies, verifying system resilience and adherence to success criteria."
          }
        ]
      },
      {
        "id": 25,
        "title": "Performance Optimization and Monitoring",
        "description": "Optimize the system for performance and add monitoring for conflicts and usage metrics.",
        "details": "Implement caching for version data to reduce database queries. Add indexing on version and last_modified_at columns. Monitor conflict rates, resolution times, and performance degradation. Use profiling tools to ensure <5% latency increase. Pseudo-code: (defun cache-version (object-id version) (setf (gethash object-id *version-cache*) version)) Integrate analytics for collaboration patterns.",
        "testStrategy": "Load tests with 1000+ objects and 100+ users to verify scalability. Monitor metrics in production-like environment to confirm <20% memory increase and maintained query performance.",
        "priority": "medium",
        "dependencies": [
          24
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Caching for Version Data",
            "description": "Implement caching mechanism for version data to reduce database queries, including adding indexing on version and last_modified_at columns.",
            "dependencies": [],
            "details": "In the system module, add a cache structure (e.g., hash table) for storing version data keyed by object-id. Implement functions to cache and retrieve versions, ensuring thread-safety. Add database indexing on version and last_modified_at columns to optimize queries. Integrate the pseudo-code provided: (defun cache-version (object-id version) (setf (gethash object-id *version-cache*) version)). Ensure cache invalidation on updates.",
            "status": "pending",
            "testStrategy": "Unit tests for cache operations including hit/miss ratios and database query reduction verification."
          },
          {
            "id": 2,
            "title": "Add Monitoring for Conflicts and Usage Metrics",
            "description": "Set up monitoring for conflict rates, resolution times, performance degradation, and integrate analytics for collaboration patterns.",
            "dependencies": [
              1
            ],
            "details": "Extend the conflict detection module to log metrics such as conflict rates, resolution times, and performance degradation. Integrate analytics to track collaboration patterns, such as user interactions and update frequencies. Use tools to collect and store these metrics in a database or external service. Ensure real-time monitoring capabilities for production environments.",
            "status": "pending",
            "testStrategy": "Load tests with 1000+ objects and 100+ users to monitor metrics in a production-like environment, confirming maintained query performance and <20% memory increase."
          },
          {
            "id": 3,
            "title": "Profile Performance to Ensure Latency Goals",
            "description": "Use profiling tools to analyze system performance and ensure no more than 5% latency increase after optimizations.",
            "dependencies": [
              1,
              2
            ],
            "details": "Employ profiling tools (e.g., built-in Lisp profilers or external tools) to measure latency before and after implementing caching and monitoring. Run benchmarks on key operations like version retrieval and conflict detection. Adjust implementations as needed to meet the <5% latency increase threshold. Document profiling results and integrate continuous profiling in the development pipeline.",
            "status": "pending",
            "testStrategy": "Benchmark tests comparing pre- and post-optimization latency on core functions, ensuring <5% increase and verifying scalability under load."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-10-14T14:40:42.116Z",
      "updated": "2025-10-16T20:18:53.900Z",
      "description": "Tasks for master context"
    }
  },
  "perf": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement Cursor Update Batching",
        "description": "Batch cursor updates on the backend and throttle sending on the frontend to reduce network traffic and ensure <50ms latency.",
        "details": "On the backend, create a message-queue struct with cursor-batch and object-batch. Implement queue-cursor-update to add updates to the batch and flush-cursor-batch to send batched updates every 50ms. On the frontend, create a CursorThrottle class that throttles updates to max 20/sec using setInterval. Ensure batch messages include all cursor positions and latency remains <50ms.",
        "testStrategy": "Unit test the batching logic to verify updates are queued and flushed correctly. Integration test with multiple clients to measure latency and ensure it stays under 50ms. Load test with 5 concurrent users to confirm no lag.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Backend Message Queue for Cursor Batching",
            "description": "Create a backend message-queue struct that includes cursor-batch and object-batch components. Implement functions to queue cursor updates and flush batches every 50ms to reduce network traffic.",
            "dependencies": [],
            "details": "On the backend, define a message-queue struct with arrays for cursor-batch and object-batch. Implement queue-cursor-update to append updates to the cursor-batch. Implement flush-cursor-batch to send the batched updates via WebSocket or similar every 50ms using a timer. Ensure the batch includes all cursor positions and handles multiple updates efficiently.",
            "status": "done",
            "testStrategy": "Unit test the queue and flush functions to verify updates are batched and sent at the correct intervals.",
            "updatedAt": "2025-10-14T15:59:40.899Z"
          },
          {
            "id": 2,
            "title": "Implement Frontend Cursor Throttling Logic",
            "description": "Create a CursorThrottle class on the frontend to limit cursor updates to a maximum of 20 per second using setInterval, ensuring low latency.",
            "dependencies": [],
            "details": "On the frontend, develop a CursorThrottle class that uses setInterval to throttle cursor position updates to no more than 20 per second. Capture cursor movements, buffer them, and send batched updates at the throttled rate. Integrate with the backend batching to maintain overall latency under 50ms.",
            "status": "done",
            "testStrategy": "Unit test the throttling mechanism to ensure it limits updates to 20/sec and handles rapid cursor movements without exceeding the rate.",
            "updatedAt": "2025-10-14T15:59:42.195Z"
          },
          {
            "id": 3,
            "title": "Conduct Comprehensive Testing Including Latency Measurements",
            "description": "Perform unit, integration, and load testing to verify batching and throttling work correctly, with a focus on measuring and ensuring latency remains under 50ms.",
            "dependencies": [],
            "details": "Execute unit tests for backend batching and frontend throttling. Run integration tests with multiple clients to simulate real-world usage. Conduct load tests with 5 concurrent users to measure latency using tools like performance.now(). Ensure all tests confirm latency <50ms and no network overload.",
            "status": "done",
            "testStrategy": "Use automated testing frameworks for unit and integration tests; employ load testing tools to measure latency percentiles and verify compliance with <50ms requirement under various conditions.",
            "updatedAt": "2025-10-14T15:59:43.450Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down the task into backend queue implementation, frontend throttling logic, and comprehensive testing including latency measurements.",
        "updatedAt": "2025-10-14T15:59:43.450Z"
      },
      {
        "id": 2,
        "title": "Implement Delta Compression for Object Updates",
        "description": "Send only changed fields for object updates to reduce bandwidth by 60-80%.",
        "details": "On the backend, create create-object-delta function to compare old and new objects and return only changed properties like x, y, width, height, rotation, color. On the frontend, implement applyDelta method to update only the changed properties on the object. Send full object state on creation and deltas thereafter.",
        "testStrategy": "Unit test delta creation to ensure only changed fields are included. Integration test to verify deltas are applied correctly across clients. Measure bandwidth usage before and after implementation to confirm 60-80% reduction.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Backend Delta Creation Function",
            "description": "Create the create-object-delta function on the backend to compare old and new objects and return only changed properties such as x, y, width, height, rotation, and color.",
            "dependencies": [],
            "details": "On the backend, implement a function that takes old and new object states, performs a deep comparison to identify changed fields, and returns a delta object containing only the modified properties. Ensure the function handles nested objects if necessary and is efficient for real-time updates.",
            "status": "done",
            "testStrategy": "Unit test the delta creation to ensure only changed fields are included and no unchanged fields are present."
          },
          {
            "id": 2,
            "title": "Implement Frontend Delta Application and Bandwidth Testing",
            "description": "Implement the applyDelta method on the frontend to update only the changed properties on objects and measure bandwidth reduction.",
            "dependencies": [
              1
            ],
            "details": "On the frontend, create an applyDelta method that merges the delta into the existing object state without overwriting unchanged fields. Send full object state on creation and deltas thereafter. Conduct bandwidth measurement tests by comparing network usage before and after implementation to confirm 60-80% reduction.",
            "status": "done",
            "testStrategy": "Integration test to verify deltas are applied correctly across clients. Measure bandwidth usage before and after implementation using network profiling tools to confirm the 60-80% reduction."
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Separate into backend delta creation, frontend delta application, and bandwidth measurement testing."
      },
      {
        "id": 3,
        "title": "Implement Priority Queue for Messages",
        "description": "Prioritize cursor and presence updates over object updates to prevent cursor lag.",
        "details": "On the backend, create a priority-queue struct with high-priority (cursors, presence), normal-priority (object updates), and low-priority queues. Implement process-message-queue to process high-priority first, then normal with a limit. Ensure message ordering within priorities.",
        "testStrategy": "Unit test queue processing to verify priority order. Integration test during heavy object updates to ensure cursor updates are not delayed. Performance test to confirm no cursor lag with high object update frequency.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Priority Queue Structure",
            "description": "Create a priority-queue struct with three levels: high-priority for cursors and presence updates, normal-priority for object updates, and low-priority queues to manage message ordering.",
            "dependencies": [],
            "details": "Implement a data structure using arrays or linked lists for each priority level, ensuring FIFO ordering within each priority. Include methods to enqueue messages with their priority and dequeue based on priority order.",
            "status": "done",
            "testStrategy": "Unit test the queue structure to verify correct enqueuing and dequeuing across priorities."
          },
          {
            "id": 2,
            "title": "Implement Message Processing Logic",
            "description": "Develop process-message-queue function to process high-priority messages first, then normal-priority with a limit, ensuring no lag in cursor updates.",
            "dependencies": [
              1
            ],
            "details": "Write logic to iterate through high-priority queue completely, then process up to a configurable limit from normal-priority, and optionally low-priority. Maintain message ordering within priorities using timestamps or sequence numbers.",
            "status": "done",
            "testStrategy": "Unit test the processing logic to confirm priority order and limits are respected."
          },
          {
            "id": 3,
            "title": "Test Priority Handling Under High Load",
            "description": "Perform testing to ensure priority queue prevents cursor lag during heavy object updates and concurrent presence changes.",
            "dependencies": [
              1,
              2
            ],
            "details": "Set up load tests simulating high-frequency object updates while monitoring cursor and presence update delays. Use performance metrics to verify that high-priority messages are processed without significant lag.",
            "status": "done",
            "testStrategy": "Integration and performance tests under simulated high load to measure latency and confirm no cursor lag."
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Divide into queue structure design, processing logic, and priority testing under high load."
      },
      {
        "id": 4,
        "title": "Implement Object Culling for Rendering",
        "description": "Only render objects visible in the viewport plus padding to maintain 60 FPS with 500+ objects.",
        "details": "In CanvasManager, add setupViewportCulling to listen for viewport moved/zoomed events and call updateVisibleObjects. Implement updateVisibleObjects to calculate visible bounds with 200px padding and set obj.visible and obj.renderable based on intersection. Use getVisibleBounds and isIntersecting helper functions.",
        "testStrategy": "Unit test bounds calculation and intersection logic. Integration test by creating 500+ objects and verifying only visible ones are rendered. Performance test to ensure 60 FPS during pan/zoom operations.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Viewport Calculation and Culling Logic",
            "description": "Add setupViewportCulling to listen for viewport events and implement updateVisibleObjects to calculate bounds with padding and set object visibility.",
            "dependencies": [],
            "details": "In CanvasManager, add setupViewportCulling method to listen for viewport moved/zoomed events and call updateVisibleObjects. Implement updateVisibleObjects to calculate visible bounds with 200px padding using getVisibleBounds, and set obj.visible and obj.renderable based on intersection using isIntersecting helper functions.",
            "status": "done",
            "testStrategy": "Unit test bounds calculation and intersection logic."
          },
          {
            "id": 2,
            "title": "Performance Testing with Many Objects",
            "description": "Test rendering performance with 500+ objects to ensure 60 FPS during pan/zoom operations.",
            "dependencies": [
              1
            ],
            "details": "Create integration tests by generating 500+ objects and verifying only visible ones are rendered. Perform performance tests to measure FPS during pan/zoom operations, ensuring it maintains 60 FPS with the culling logic in place.",
            "status": "done",
            "testStrategy": "Integration test with 500+ objects to verify visibility. Performance test for 60 FPS during pan/zoom.",
            "updatedAt": "2025-10-14T16:02:47.879Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Split into viewport calculation, culling logic, and performance testing with many objects.",
        "updatedAt": "2025-10-14T16:02:47.879Z"
      },
      {
        "id": 5,
        "title": "Add FPS Monitoring",
        "description": "Track and log FPS to detect drops below 55 and provide performance stats.",
        "details": "Create PerformanceMonitor class that uses app.ticker to track FPS in a history array of max 60 entries. Log warnings when FPS < 55, including object count and average FPS. Provide getStats method for current, average, min, max FPS.",
        "testStrategy": "Unit test FPS tracking accuracy. Integration test by simulating load and checking logs for warnings. Manual test to access stats via console and verify no performance impact from monitoring.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create PerformanceMonitor Class Structure",
            "description": "Set up the basic PerformanceMonitor class with necessary properties and initialization.",
            "dependencies": [],
            "details": "Define the PerformanceMonitor class with properties for FPS history array (max 60 entries), current FPS, and methods stubs for tracking and stats. Ensure it integrates with app.ticker for updates.",
            "status": "done",
            "testStrategy": "Unit test class instantiation and property initialization.",
            "updatedAt": "2025-10-14T16:18:10.090Z"
          },
          {
            "id": 2,
            "title": "Implement FPS Tracking with Ticker",
            "description": "Use app.ticker to calculate and track FPS in real-time.",
            "dependencies": [
              1
            ],
            "details": "In the PerformanceMonitor class, add a ticker listener that calculates FPS based on delta time from the ticker. Update the current FPS value on each tick and prepare for adding to history.",
            "status": "done",
            "testStrategy": "Unit test FPS calculation accuracy by mocking ticker events.",
            "updatedAt": "2025-10-14T16:18:11.375Z"
          },
          {
            "id": 3,
            "title": "Add FPS History Array Management",
            "description": "Maintain a history array of FPS values with a maximum of 60 entries.",
            "dependencies": [
              2
            ],
            "details": "Implement logic to add current FPS to the history array on each update, ensuring the array does not exceed 60 entries by removing oldest values. Calculate average FPS from the history.",
            "status": "done",
            "testStrategy": "Unit test array management, including adding, removing, and average calculation.",
            "updatedAt": "2025-10-14T16:18:12.803Z"
          },
          {
            "id": 4,
            "title": "Implement Warning Logging for Low FPS",
            "description": "Log warnings when FPS drops below 55, including object count and average FPS.",
            "dependencies": [
              3
            ],
            "details": "Add logic to check if current FPS is below 55, and if so, log a warning message that includes the current object count (assuming access to object count) and the average FPS from history. Use console.warn or similar.",
            "status": "done",
            "testStrategy": "Integration test by simulating low FPS scenarios and verifying logs are generated correctly.",
            "updatedAt": "2025-10-14T16:18:14.154Z"
          },
          {
            "id": 5,
            "title": "Provide getStats Method for FPS Statistics",
            "description": "Implement getStats method to return current, average, min, and max FPS.",
            "dependencies": [
              3
            ],
            "details": "Create the getStats method that computes and returns an object with current FPS, average FPS (from history), minimum FPS, and maximum FPS from the history array. Ensure calculations are accurate and efficient.",
            "status": "done",
            "testStrategy": "Unit test the getStats method with various history arrays to verify correct stats output.",
            "updatedAt": "2025-10-14T16:18:15.523Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": "2025-10-14T16:18:15.523Z"
      },
      {
        "id": 6,
        "title": "Optimize Remote Cursor Rendering",
        "description": "Use shared textures for cursors to improve performance with multiple remote cursors.",
        "details": "In createRemoteCursor, create a shared cursorTexture once using PIXI.Graphics for the cursor shape. Use PIXI.Sprite with tint for color instead of individual graphics. Add username label as PIXI.Text. Ensure smooth movement at 60 FPS with 10+ cursors.",
        "testStrategy": "Unit test texture sharing and sprite creation. Performance test rendering 10+ cursors to confirm no FPS drop. Visual test to ensure cursors are readable and performant.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Shared Cursor Texture",
            "description": "Generate a single shared texture for the cursor shape using PIXI.Graphics to avoid recreating graphics for each cursor.",
            "dependencies": [],
            "details": "In the PIXI application, create a function to draw a cursor shape (e.g., arrow or pointer) using PIXI.Graphics, render it to a texture once, and store it as a shared resource. This texture will be reused for all remote cursors to optimize memory and rendering performance.",
            "status": "done",
            "testStrategy": "Unit test to verify the texture is created correctly and can be reused without errors."
          },
          {
            "id": 2,
            "title": "Refactor createRemoteCursor to Use Shared Texture and Sprite",
            "description": "Update the createRemoteCursor function to use the shared texture with PIXI.Sprite and apply tint for color variations instead of individual graphics.",
            "dependencies": [
              1
            ],
            "details": "Modify createRemoteCursor to instantiate a PIXI.Sprite using the shared cursorTexture, set its tint property for different colors based on user, and position it accordingly. Remove any code that creates individual PIXI.Graphics for each cursor to reduce overhead.",
            "status": "done",
            "testStrategy": "Unit test sprite creation and tint application to ensure colors are applied correctly."
          },
          {
            "id": 3,
            "title": "Add Username Label to Remote Cursors",
            "description": "Attach a PIXI.Text label displaying the username to each remote cursor for identification.",
            "dependencies": [
              2
            ],
            "details": "In createRemoteCursor, create a PIXI.Text object with the username, style it appropriately (e.g., font size, color), and add it as a child to the cursor sprite. Position the text relative to the cursor (e.g., above or beside it) to ensure readability.",
            "status": "done",
            "testStrategy": "Visual test to confirm labels are displayed correctly and do not overlap or obscure the cursor."
          },
          {
            "id": 4,
            "title": "Implement Smooth Cursor Movement",
            "description": "Ensure cursor positions are updated smoothly to achieve 60 FPS movement with multiple cursors.",
            "dependencies": [
              2
            ],
            "details": "Update the cursor update logic to interpolate positions between received updates for fluid animation. Use requestAnimationFrame or PIXI's ticker to animate cursor movement, ensuring it handles 10+ cursors without dropping below 60 FPS.",
            "status": "done",
            "testStrategy": "Performance test rendering and animating 10+ cursors to measure FPS and confirm smooth movement."
          },
          {
            "id": 5,
            "title": "Optimize and Test Overall Rendering Performance",
            "description": "Conduct performance optimizations and tests to ensure the system maintains 60 FPS with 10+ remote cursors.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Profile the rendering pipeline, optimize any bottlenecks in texture usage, sprite management, and animation. Run comprehensive tests including unit tests for components, performance benchmarks for FPS, and visual checks for readability and performance.",
            "status": "done",
            "testStrategy": "Performance test with 10+ cursors to confirm no FPS drop; visual test for readability; integration test to ensure all components work together seamlessly."
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": ""
      },
      {
        "id": 7,
        "title": "Implement Memory Cleanup on Disconnect",
        "description": "Properly clean up user data and objects on disconnect to prevent memory leaks.",
        "details": "On backend, in handle-client-disconnect, remove client from room, broadcast user-left, and clean up user data. On frontend, handleUserLeft to destroy cursors (keeping shared texture), remove from activeUsers, and update UI. Add startPeriodicCleanup to remove orphaned objects every minute.",
        "testStrategy": "Unit test cleanup functions. Integration test connect/disconnect cycles to verify memory stability. Run 24-hour session test to ensure no memory growth.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Backend Disconnect Handling",
            "description": "Handle client disconnection on the backend by removing the client from the room, broadcasting user-left events, and cleaning up associated user data to prevent memory leaks.",
            "dependencies": [],
            "details": "In the handle-client-disconnect function, ensure the client is removed from the room structure, broadcast a user-left event to other clients, and perform thorough cleanup of user-specific data such as session variables and temporary caches. This prevents orphaned references that could lead to memory accumulation.",
            "status": "done",
            "testStrategy": "Unit test the cleanup functions to verify that user data is properly removed upon disconnect.",
            "updatedAt": "2025-10-14T16:16:03.329Z"
          },
          {
            "id": 2,
            "title": "Implement Frontend Memory Cleanup",
            "description": "On the frontend, handle user-left events to destroy cursors while preserving shared textures, remove users from active lists, and update the UI accordingly.",
            "dependencies": [],
            "details": "In the handleUserLeft function, destroy individual cursor objects but keep shared textures intact to avoid unnecessary reloading. Remove the disconnected user from the activeUsers array and update any UI elements that display user presence. Ensure no references to the user remain in the DOM or memory.",
            "status": "done",
            "testStrategy": "Integration test connect/disconnect cycles to verify that frontend memory is stable and no leaks occur during repeated user joins and leaves.",
            "updatedAt": "2025-10-14T16:16:04.616Z"
          },
          {
            "id": 3,
            "title": "Add Periodic Memory Cleanup and Long-Term Testing",
            "description": "Implement a periodic cleanup mechanism to remove orphaned objects every minute and conduct thorough testing to ensure no memory growth over time.",
            "dependencies": [],
            "details": "Add a startPeriodicCleanup function that runs every minute to scan for and remove orphaned objects, such as unused PIXI elements or stale data structures. Integrate this into the application's main loop. Conduct a 24-hour session test to monitor memory usage and confirm no gradual leaks occur under sustained load.",
            "status": "done",
            "testStrategy": "Run a 24-hour session test to ensure no memory growth, combined with memory profiling to detect any leaks during periodic cleanup operations.",
            "updatedAt": "2025-10-14T16:16:05.909Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Separate into backend disconnect handling, frontend cleanup, and long-term memory testing.",
        "updatedAt": "2025-10-14T16:16:05.909Z"
      },
      {
        "id": 8,
        "title": "Implement Object Deletion with Proper Cleanup",
        "description": "Ensure deleted objects are fully removed from memory and textures are managed.",
        "details": "In deleteObject, use obj.destroy with options to destroy children but keep shared textures. Remove from objects and selectedObjects maps. For bulk delete, process multiple IDs and broadcast deletions once. Ensure no orphaned PIXI objects.",
        "testStrategy": "Unit test deletion and bulk operations. Memory profiling test to confirm no leaks after deletions. Integration test to verify objects are removed across clients.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Single and Bulk Object Deletion Logic",
            "description": "Develop the core logic for deleting individual objects and handling bulk deletions, ensuring proper cleanup of PIXI objects and removal from maps.",
            "dependencies": [],
            "details": "In the deleteObject function, use obj.destroy with options to destroy children but preserve shared textures. Remove the object from both objects and selectedObjects maps. For bulk delete, process an array of IDs, perform deletions, and broadcast the deletions once to avoid multiple broadcasts. Ensure no orphaned PIXI objects remain in the scene graph.",
            "status": "done",
            "testStrategy": "Unit tests for deleteObject and bulkDelete functions to verify objects are removed from maps and destroyed correctly. Integration tests to confirm broadcasts are sent properly for bulk operations."
          },
          {
            "id": 2,
            "title": "Implement Memory Leak Verification for Object Deletion",
            "description": "Add mechanisms to verify that deleted objects are fully removed from memory and no leaks occur, including texture management checks.",
            "dependencies": [
              1
            ],
            "details": "After deletion, implement checks to ensure PIXI objects are not retained in memory. Use memory profiling tools or custom checks to confirm textures are managed properly (shared ones kept, others released). Add logging or assertions to detect orphaned objects. Integrate with the deletion logic to run verifications post-deletion.",
            "status": "done",
            "testStrategy": "Memory profiling tests using tools like Chrome DevTools to confirm no leaks after deletions. Unit tests for verification functions to ensure they detect potential issues. Integration tests to verify no orphaned objects in the PIXI stage after bulk deletions."
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break into deletion logic, bulk operations, and memory leak verification."
      },
      {
        "id": 9,
        "title": "Add Rate Limiting and Input Validation",
        "description": "Protect against abuse with rate limiting and validate input to prevent invalid data.",
        "details": "On backend, create rate-limiter struct with message count and window. Implement check-rate-limit to allow max 100 messages/sec, resetting window. Add validate-object-update and validate-canvas-state for bounds checking. Reject invalid data with errors.",
        "testStrategy": "Unit test rate limiter and validation functions. Load test to attempt DoS and verify limits are enforced. Integration test invalid inputs are rejected with error messages.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Rate Limiter Struct and Logic",
            "description": "Create a rate-limiter struct with message count and window, and implement check-rate-limit to allow max 100 messages/sec, resetting the window as needed.",
            "dependencies": [],
            "details": "On the backend, define a rate-limiter struct that tracks message counts within a time window. Implement the check-rate-limit function to enforce a maximum of 100 messages per second, automatically resetting the window when the time period expires. Ensure thread-safety for concurrent access.",
            "status": "done",
            "testStrategy": "Unit test the rate limiter to verify it correctly allows up to 100 messages per second and resets the window appropriately."
          },
          {
            "id": 2,
            "title": "Add Input Validation Functions",
            "description": "Implement validate-object-update and validate-canvas-state functions to perform bounds checking on input data.",
            "dependencies": [],
            "details": "Add validation functions on the backend to check bounds for object updates and canvas states. These functions should verify that provided values are within acceptable ranges, such as position coordinates, sizes, and other properties, to prevent invalid data from being processed.",
            "status": "done",
            "testStrategy": "Unit test the validation functions to ensure they correctly identify and flag invalid inputs based on defined bounds."
          },
          {
            "id": 3,
            "title": "Conduct Abuse and DoS Testing",
            "description": "Perform load testing to simulate abuse scenarios, including attempts at DoS attacks, and verify that rate limits are enforced.",
            "dependencies": [
              1
            ],
            "details": "Set up load tests that attempt to exceed the rate limits by sending high volumes of messages. Monitor the system to ensure the rate limiter blocks excessive requests and prevents DoS conditions. Use tools to simulate concurrent high-traffic scenarios.",
            "status": "done",
            "testStrategy": "Load test to attempt DoS and verify that limits are enforced, preventing system overload."
          },
          {
            "id": 4,
            "title": "Implement Error Handling for Invalid Data",
            "description": "Add error handling mechanisms to reject invalid data and return appropriate error messages to clients.",
            "dependencies": [
              2
            ],
            "details": "Integrate error responses into the validation functions so that when invalid data is detected, the system rejects it and sends back clear error messages indicating what was wrong (e.g., out-of-bounds values). Ensure errors are logged and communicated properly without exposing sensitive information.",
            "status": "done",
            "testStrategy": "Integration test to verify that invalid inputs are rejected with appropriate error messages."
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Divide into rate limiter implementation, validation functions, abuse testing, and error handling."
      },
      {
        "id": 10,
        "title": "Optimize Database Access with Pooling and Indexing",
        "description": "Implement connection pooling and add indexes to improve query performance.",
        "details": "Create db-pool struct with 10 connections and thread-safe access using bt:make-lock. Implement with-db-connection macro for reusing connections. Add SQL indexes on canvas_id, session_id, user_id, email. Optimize save-canvas-state-optimized with transactions and INSERT OR REPLACE.",
        "testStrategy": "Unit test connection pooling for reuse and thread-safety. Performance test query execution times to ensure <10ms. Load test database operations to confirm no contention or leaks.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Database Connection Pooling",
            "description": "Set up a connection pool to manage database connections efficiently with thread-safe access.",
            "dependencies": [],
            "details": "Create a db-pool struct with 10 connections and ensure thread-safe access using bt:make-lock. Implement the with-db-connection macro to allow reusing connections from the pool, preventing connection exhaustion and improving concurrency.",
            "status": "done",
            "testStrategy": "Unit test connection pooling for reuse and thread-safety, verifying that connections are properly acquired and released without leaks.",
            "updatedAt": "2025-10-14T16:24:32.583Z"
          },
          {
            "id": 2,
            "title": "Add SQL Indexes on Key Columns",
            "description": "Create indexes on frequently queried columns to speed up database lookups.",
            "dependencies": [],
            "details": "Add SQL indexes on canvas_id, session_id, user_id, and email columns in the relevant database tables. This will reduce query execution time by allowing faster searches and joins on these fields.",
            "status": "done",
            "testStrategy": "Performance test query execution times after indexing to ensure they remain under 10ms, comparing before and after metrics.",
            "updatedAt": "2025-10-14T16:24:33.878Z"
          },
          {
            "id": 3,
            "title": "Optimize Canvas State Saving with Transactions",
            "description": "Enhance the save-canvas-state-optimized function using transactions and efficient insert operations.",
            "dependencies": [],
            "details": "Modify save-canvas-state-optimized to use database transactions for atomic operations and employ INSERT OR REPLACE statements to handle updates and inserts efficiently, minimizing overhead and ensuring data consistency.",
            "status": "done",
            "testStrategy": "Unit test the transaction logic to verify atomicity and correctness of INSERT OR REPLACE operations under various scenarios.",
            "updatedAt": "2025-10-14T16:24:35.189Z"
          },
          {
            "id": 4,
            "title": "Perform Performance and Load Testing",
            "description": "Conduct comprehensive testing to validate database performance under load and ensure no issues.",
            "dependencies": [],
            "details": "Execute load tests on database operations to confirm there is no contention, connection leaks, or performance degradation. Monitor query times to maintain sub-10ms performance even under high concurrency.",
            "status": "done",
            "testStrategy": "Load test database operations to confirm no contention or leaks, and performance test query execution times to ensure they stay under 10ms with simulated high-load conditions.",
            "updatedAt": "2025-10-14T16:24:36.586Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Split into pooling setup, indexing, transaction optimization, and performance/load testing.",
        "updatedAt": "2025-10-14T16:24:36.586Z"
      },
      {
        "id": 11,
        "title": "Implement Performance Monitoring for Latency",
        "description": "Track message latency and provide stats for optimization.",
        "details": "Create LatencyMonitor class to track round-trip latency for messages using performance.now() and messageId. Record latencies in history, warn on >100ms. Provide getStats for percentiles (p50, p95, p99).",
        "testStrategy": "Unit test latency tracking. Integration test with message sending to verify stats accuracy. Performance profiling to ensure monitoring adds minimal overhead.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define LatencyMonitor Class Structure",
            "description": "Create the basic LatencyMonitor class with constructor, properties for storing latency history, and initial setup.",
            "dependencies": [],
            "details": "Initialize the class with a Map or array to store message IDs and their start times. Include a history array to record completed latencies. Set up any necessary imports for performance.now().",
            "status": "done",
            "testStrategy": "Unit test the class instantiation and basic properties.",
            "updatedAt": "2025-10-14T16:29:30.329Z"
          },
          {
            "id": 2,
            "title": "Implement Latency Start Tracking",
            "description": "Add a method to start tracking latency for a message using performance.now() and messageId.",
            "dependencies": [
              1
            ],
            "details": "Create a startLatency(messageId) method that records the current performance.now() timestamp associated with the messageId in the tracking map.",
            "status": "done",
            "testStrategy": "Unit test the startLatency method to verify timestamps are recorded correctly.",
            "updatedAt": "2025-10-14T16:29:31.795Z"
          },
          {
            "id": 3,
            "title": "Implement Latency End Tracking and Recording",
            "description": "Add a method to stop tracking and calculate round-trip latency, then record it in history.",
            "dependencies": [
              2
            ],
            "details": "Create an endLatency(messageId) method that calculates the latency by subtracting the start time from current performance.now(), removes the entry from tracking map, and pushes the latency to the history array.",
            "status": "done",
            "testStrategy": "Unit test the endLatency method to ensure accurate latency calculation and recording.",
            "updatedAt": "2025-10-14T16:29:33.524Z"
          },
          {
            "id": 4,
            "title": "Add Warning for High Latency",
            "description": "Implement logic to warn when recorded latency exceeds 100ms.",
            "dependencies": [
              3
            ],
            "details": "In the endLatency method or a separate check, compare the calculated latency against 100ms and log a warning if exceeded. Use console.warn or a custom logging mechanism.",
            "status": "done",
            "testStrategy": "Unit test the warning logic by simulating latencies above and below 100ms.",
            "updatedAt": "2025-10-14T16:29:35.440Z"
          },
          {
            "id": 5,
            "title": "Implement getStats Method for Percentiles",
            "description": "Create a getStats method that computes and returns p50, p95, and p99 percentiles from the latency history.",
            "dependencies": [
              4
            ],
            "details": "Implement getStats() to sort the history array, calculate the percentiles using appropriate formulas (e.g., for p50, median; for p95, 95th percentile), and return an object with p50, p95, p99 values.",
            "status": "done",
            "testStrategy": "Unit test getStats with sample latency data to verify correct percentile calculations.",
            "updatedAt": "2025-10-14T16:29:36.829Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": "2025-10-14T16:29:36.829Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-16T20:18:53.900Z",
      "taskCount": 11,
      "completedCount": 11,
      "tags": [
        "perf"
      ],
      "created": "2025-10-14T16:32:33.526Z",
      "description": "Tasks for perf context",
      "updated": "2025-10-16T20:18:53.900Z"
    }
  },
  "pixi-upgrade": {
    "tasks": [
      {
        "id": 1,
        "title": "Backup Current Codebase",
        "description": "Verify the current codebase backup on the 'pixi-upgrade' branch and commit any pending changes before starting the upgrade.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "We are already on a separate branch 'pixi-upgrade' in a dedicated worktree. Verify repository status and commit any pending changes before starting the upgrade.",
        "testStrategy": "Verify that we are on the 'pixi-upgrade' branch and no uncommitted changes remain.",
        "subtasks": [
          {
            "id": 1,
            "title": "Verify Branch and Repository State",
            "description": "Verify that we are on the correct 'pixi-upgrade' branch in the worktree and that the repository is in a clean state ready for the upgrade work.",
            "dependencies": [],
            "details": "Run 'git status' to check if there are any uncommitted changes, confirm the current branch is 'pixi-upgrade', and ensure we are in the dedicated worktree.",
            "status": "done",
            "testStrategy": "Ensure no uncommitted changes are present, the branch is 'pixi-upgrade', and we are in the correct worktree."
          },
          {
            "id": 2,
            "title": "Commit Pending Changes",
            "description": "Commit any outstanding changes to the repository before starting the upgrade.",
            "dependencies": [
              1
            ],
            "details": "If there are uncommitted changes, stage them with 'git add .' and commit with 'git commit -m \"Commit before upgrade\"'.",
            "status": "done",
            "testStrategy": "Run 'git status' again to confirm no changes are pending."
          },
          {
            "id": 3,
            "title": "Verify Backup Integrity",
            "description": "Confirm the backup on the 'pixi-upgrade' branch is intact and contains the codebase.",
            "dependencies": [
              2
            ],
            "details": "Run 'git log --oneline' to verify the branch history and ensure the codebase is intact.",
            "status": "done",
            "testStrategy": "Attempt to build or run a basic check on the branch to ensure no issues."
          }
        ],
        "complexity": 2,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this is a straightforward Git operation.",
        "updatedAt": "2025-10-15T20:44:31.501Z"
      },
      {
        "id": 2,
        "title": "Update Package Dependencies",
        "description": "Update package.json to use PixiJS v8 and remove individual sub-packages.",
        "details": "Remove all @pixi/* dependencies from package.json. Add a single 'pixi.js': '^8.x.x'. Run npm install to update node_modules.",
        "testStrategy": "Check package.json for correct dependencies and ensure npm install completes without errors.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Backup current package.json",
            "description": "Create a backup of the current package.json file to allow for easy rollback if needed.",
            "dependencies": [],
            "details": "Make a copy of package.json in the project root, naming it package.json.backup or similar, to preserve the original state before modifications.",
            "status": "done",
            "testStrategy": "Verify that the backup file exists and matches the original package.json content."
          },
          {
            "id": 2,
            "title": "Remove @pixi/* dependencies",
            "description": "Remove all individual @pixi/* package dependencies from the package.json file.",
            "dependencies": [
              1
            ],
            "details": "Open package.json and delete all lines or entries for packages starting with @pixi/, such as @pixi/app, @pixi/graphics, etc., ensuring no remnants are left.",
            "status": "done",
            "testStrategy": "Check package.json to confirm no @pixi/* entries remain in the dependencies or devDependencies sections."
          },
          {
            "id": 3,
            "title": "Add pixi.js v8 dependency",
            "description": "Add the single 'pixi.js' dependency with version '^8.x.x' to package.json.",
            "dependencies": [
              2
            ],
            "details": "In the dependencies section of package.json, add a new entry: \"pixi.js\": \"^8.x.x\", ensuring it is properly formatted as valid JSON.",
            "status": "done",
            "testStrategy": "Inspect package.json to verify the 'pixi.js' entry is present with the correct version specifier."
          },
          {
            "id": 4,
            "title": "Save updated package.json",
            "description": "Save the modified package.json file after removing old dependencies and adding the new one.",
            "dependencies": [
              3
            ],
            "details": "After editing, save the file in the project root, ensuring the JSON syntax is valid by running a quick validation if possible.",
            "status": "done",
            "testStrategy": "Use a JSON validator or attempt to parse the file to confirm it is syntactically correct."
          },
          {
            "id": 5,
            "title": "Run npm install",
            "description": "Execute npm install to update node_modules with the new PixiJS v8 dependency.",
            "dependencies": [
              4
            ],
            "details": "In the terminal, navigate to the project root and run 'npm install', waiting for the command to complete successfully without errors.",
            "status": "done",
            "testStrategy": "Check that npm install finishes without errors, and verify that node_modules contains the updated pixi.js package."
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this involves editing a single file and running a command.",
        "updatedAt": "2025-10-15T20:59:48.115Z"
      },
      {
        "id": 3,
        "title": "Refactor Imports Across Codebase",
        "description": "Change all PixiJS imports from individual sub-packages to single 'pixi.js' import.",
        "details": "Search and replace all imports like 'import { Application } from '@pixi/app'' with 'import { Application } from 'pixi.js''. Update in main.js, canvas.js, and any other files using PixiJS.",
        "testStrategy": "Run the application and check for import errors in the console. Ensure no @pixi/* imports remain.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Refactor PixiJS Imports in main.js",
            "description": "Update all PixiJS imports in main.js from individual sub-packages to the single 'pixi.js' import.",
            "dependencies": [],
            "details": "Locate all import statements in main.js that use '@pixi/*' sub-packages, such as 'import { Application } from '@pixi/app'', and replace them with 'import { Application } from 'pixi.js''. Ensure all necessary exports are available from the single import.",
            "status": "done",
            "testStrategy": "Run the application and check the console for any import errors related to PixiJS in main.js."
          },
          {
            "id": 2,
            "title": "Refactor PixiJS Imports in canvas.js",
            "description": "Update all PixiJS imports in canvas.js from individual sub-packages to the single 'pixi.js' import.",
            "dependencies": [],
            "details": "Search for and replace all imports in canvas.js that reference '@pixi/*' packages, like 'import { Graphics } from '@pixi/graphics'', with 'import { Graphics } from 'pixi.js''. Verify that the file compiles without import issues after changes.",
            "status": "done",
            "testStrategy": "Execute the app and inspect the console for import-related errors in canvas.js, ensuring PixiJS objects are accessible."
          },
          {
            "id": 3,
            "title": "Refactor PixiJS Imports in Other Files",
            "description": "Update PixiJS imports in any remaining files across the codebase that use individual sub-packages.",
            "dependencies": [],
            "details": "Perform a global search across the project for any files importing from '@pixi/*' packages and replace them with imports from 'pixi.js'. This includes checking all JavaScript or TypeScript files not covered in main.js or canvas.js to ensure complete refactoring.",
            "status": "done",
            "testStrategy": "Run the application and monitor the console for any remaining @pixi/* import errors, confirming all PixiJS imports are now from 'pixi.js'."
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Generate subtasks for searching and replacing imports in each specific file (e.g., main.js, canvas.js, and any other PixiJS-using files).",
        "updatedAt": "2025-10-15T20:59:50.717Z"
      },
      {
        "id": 4,
        "title": "Implement Asynchronous Initialization",
        "description": "Refactor main.js to use async initialization for PixiJS Application.",
        "details": "Convert the main function to async. Separate Application constructor from init(). Await app.init() with options before creating PixiJS objects.",
        "testStrategy": "Run the app and verify it initializes without errors. Check console for async-related issues.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze Current main.js Structure",
            "description": "Review the existing main.js file to understand the current synchronous initialization of the PixiJS Application, identifying where the Application constructor is called and how PixiJS objects are created.",
            "dependencies": [],
            "details": "Examine the code in main.js to map out the current flow, noting any synchronous calls to Application() and the sequence of object creation. This will provide a baseline for refactoring.",
            "status": "done",
            "testStrategy": "Manually inspect the code and document the current structure in comments or a separate note."
          },
          {
            "id": 2,
            "title": "Convert Main Function to Async",
            "description": "Modify the main function in main.js to be declared as an async function to support asynchronous operations.",
            "dependencies": [
              1
            ],
            "details": "Change the function declaration from 'function main()' or similar to 'async function main()' in main.js. Ensure the function signature is updated correctly to allow awaiting promises inside it.",
            "status": "done",
            "testStrategy": "Run a syntax check or linter to verify the async keyword is properly applied without syntax errors."
          },
          {
            "id": 3,
            "title": "Separate Application Constructor from Init",
            "description": "Refactor the code to create the PixiJS Application instance without immediately initializing it, preparing for a separate init call.",
            "dependencies": [
              2
            ],
            "details": "Locate the Application constructor call in main.js and separate it from any immediate initialization. Store the app instance in a variable, ensuring no objects are created until after init() is awaited.",
            "status": "done",
            "testStrategy": "Execute the code up to this point and confirm that the Application is instantiated but not yet initialized, checking for any runtime errors."
          },
          {
            "id": 4,
            "title": "Await app.init() with Options",
            "description": "Add an await call to app.init() with the necessary options before proceeding to create PixiJS objects.",
            "dependencies": [
              3
            ],
            "details": "After the Application constructor, insert 'await app.init(options);' where options include any required configuration like canvas settings. Ensure this is placed before any PixiJS object creation to comply with PixiJS v8 async requirements.",
            "status": "done",
            "testStrategy": "Run the application and monitor the console for successful initialization messages or errors related to async init."
          },
          {
            "id": 5,
            "title": "Create PixiJS Objects After Init",
            "description": "Move or ensure that all PixiJS object creation (like sprites, containers) happens after the awaited app.init() call.",
            "dependencies": [
              4
            ],
            "details": "Review and adjust the code in main.js so that any creation of PixiJS objects, such as adding children to the stage or setting up viewports, occurs only after app.init() has resolved. This prevents initialization issues in PixiJS v8.",
            "status": "done",
            "testStrategy": "Run the app and verify it initializes without errors, checking console for async-related issues and ensuring PixiJS objects render correctly."
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this focuses on refactoring a single file's initialization logic.",
        "updatedAt": "2025-10-15T20:59:53.678Z"
      },
      {
        "id": 5,
        "title": "Replace app.view with app.canvas",
        "description": "Update all references to app.view to use app.canvas instead.",
        "details": "Search for app.view in the codebase and replace with app.canvas, primarily in main.js and canvas.js.",
        "testStrategy": "Inspect the DOM to ensure the canvas element is correctly referenced. Test canvas rendering.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Search for all app.view references in the codebase",
            "description": "Perform a comprehensive search across the entire codebase to locate every instance of 'app.view' that needs to be replaced.",
            "dependencies": [],
            "details": "Use grep or a code search tool to find all occurrences of 'app.view' in files, noting the exact lines and files for replacement. Focus on main.js and canvas.js as primary targets, but check all files to ensure completeness.",
            "status": "done",
            "testStrategy": "Verify the search results by manually checking a few files to confirm no instances are missed."
          },
          {
            "id": 2,
            "title": "Replace app.view in main.js",
            "description": "Update all references to app.view with app.canvas in the main.js file.",
            "dependencies": [
              1
            ],
            "details": "Open main.js and replace each instance of 'app.view' with 'app.canvas'. Ensure the replacement is done accurately without affecting surrounding code. Save the file after changes.",
            "status": "done",
            "testStrategy": "Run a diff or search in main.js to confirm all 'app.view' have been replaced and no new instances remain."
          },
          {
            "id": 3,
            "title": "Replace app.view in canvas.js",
            "description": "Update all references to app.view with app.canvas in the canvas.js file.",
            "dependencies": [
              1
            ],
            "details": "Open canvas.js and replace each instance of 'app.view' with 'app.canvas'. Carefully check for any context-specific usages to avoid breaking functionality. Save the file after changes.",
            "status": "done",
            "testStrategy": "Run a diff or search in canvas.js to confirm all 'app.view' have been replaced and no new instances remain."
          },
          {
            "id": 4,
            "title": "Check and replace app.view in other files if any",
            "description": "Review search results for any additional files containing app.view and perform replacements.",
            "dependencies": [
              1
            ],
            "details": "From the search results, identify any files beyond main.js and canvas.js that have 'app.view'. Replace them with 'app.canvas' in each file, ensuring consistency across the codebase.",
            "status": "done",
            "testStrategy": "Perform another search post-replacement to ensure no 'app.view' instances are left in any file."
          },
          {
            "id": 5,
            "title": "Test canvas rendering after replacements",
            "description": "Verify that the app functions correctly with app.canvas references.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Run the application and inspect the DOM to ensure the canvas element is correctly referenced. Test canvas rendering functionality to confirm no errors or broken behaviors due to the replacements.",
            "status": "done",
            "testStrategy": "Use browser developer tools to inspect the DOM for correct canvas references and perform visual checks on rendering."
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this is a simple find-and-replace operation.",
        "updatedAt": "2025-10-15T20:59:56.060Z"
      },
      {
        "id": 6,
        "title": "Migrate Graphics API to Builder Pattern",
        "description": "Refactor all Graphics drawing logic to use the new builder pattern.",
        "details": "Change from beginFill/drawShape/endFill to shape().fill().stroke(). Update functions like createRectangle and createCircle in canvas.js.",
        "testStrategy": "Create shapes and verify they render correctly without visual artifacts.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update createRectangle function to builder pattern",
            "description": "Refactor the createRectangle function in canvas.js to use the new builder pattern, changing from beginFill/drawShape/endFill to shape().fill().stroke().",
            "dependencies": [],
            "details": "Locate the createRectangle function in canvas.js. Replace the old API calls with the new builder pattern syntax, ensuring the rectangle is created using shape().rect().fill().stroke(). Update any related parameters and ensure compatibility with PixiJS v8.",
            "status": "done",
            "testStrategy": "Create a rectangle shape using the updated function and verify it renders correctly on the canvas without visual artifacts, checking dimensions and fill/stroke properties."
          },
          {
            "id": 2,
            "title": "Update createCircle function to builder pattern",
            "description": "Refactor the createCircle function in canvas.js to use the new builder pattern, changing from beginFill/drawShape/endFill to shape().fill().stroke().",
            "dependencies": [],
            "details": "Locate the createCircle function in canvas.js. Replace the old API calls with the new builder pattern syntax, ensuring the circle is created using shape().circle().fill().stroke(). Update any related parameters and ensure compatibility with PixiJS v8.",
            "status": "done",
            "testStrategy": "Create a circle shape using the updated function and verify it renders correctly on the canvas without visual artifacts, checking radius and fill/stroke properties."
          },
          {
            "id": 3,
            "title": "Update createTriangle function to builder pattern",
            "description": "Refactor the createTriangle function in canvas.js to use the new builder pattern, changing from beginFill/drawShape/endFill to shape().fill().stroke().",
            "dependencies": [],
            "details": "Locate the createTriangle function in canvas.js. Replace the old API calls with the new builder pattern syntax, ensuring the triangle is created using shape().polygon().fill().stroke() with appropriate vertices. Update any related parameters and ensure compatibility with PixiJS v8.",
            "status": "done",
            "testStrategy": "Create a triangle shape using the updated function and verify it renders correctly on the canvas without visual artifacts, checking vertices and fill/stroke properties."
          },
          {
            "id": 4,
            "title": "Update createLine function to builder pattern",
            "description": "Refactor the createLine function in canvas.js to use the new builder pattern, changing from beginFill/drawShape/endFill to shape().fill().stroke().",
            "dependencies": [],
            "details": "Locate the createLine function in canvas.js. Replace the old API calls with the new builder pattern syntax, ensuring the line is created using shape().moveTo().lineTo().stroke(). Update any related parameters and ensure compatibility with PixiJS v8.",
            "status": "done",
            "testStrategy": "Create a line shape using the updated function and verify it renders correctly on the canvas without visual artifacts, checking start/end points and stroke properties."
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Generate subtasks for updating each drawing function (e.g., createRectangle, createCircle) to the new builder pattern, including testing each shape individually.",
        "updatedAt": "2025-10-15T20:59:58.456Z"
      },
      {
        "id": 7,
        "title": "Update Shape Function Names",
        "description": "Rename drawShape methods to their v8 equivalents.",
        "details": "Replace drawRect with rect, drawCircle with circle, etc., in all Graphics usage.",
        "testStrategy": "Test drawing various shapes and confirm they appear as expected.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify all Graphics usage files",
            "description": "Search the codebase to find all files that import or use the Graphics class from PixiJS.",
            "dependencies": [],
            "details": "Use grep or a code search tool to locate files containing 'Graphics' and method calls like drawRect, drawCircle, etc. Compile a list of affected files.",
            "status": "done",
            "testStrategy": "Basic verification: run and ensure no errors."
          },
          {
            "id": 2,
            "title": "Replace drawRect with rect",
            "description": "Update all instances of drawRect method calls to use rect instead.",
            "dependencies": [
              1
            ],
            "details": "In each identified file, perform a find-and-replace operation to change drawRect() to rect(). Ensure the parameters remain compatible.",
            "status": "done",
            "testStrategy": "Verify that rectangles are drawn correctly after replacement."
          },
          {
            "id": 3,
            "title": "Replace drawCircle with circle",
            "description": "Update all instances of drawCircle method calls to use circle instead.",
            "dependencies": [
              1
            ],
            "details": "In each identified file, perform a find-and-replace operation to change drawCircle() to circle(). Check parameter compatibility.",
            "status": "done",
            "testStrategy": "Verify that circles are drawn correctly after replacement."
          },
          {
            "id": 4,
            "title": "Replace other drawShape methods",
            "description": "Update remaining drawShape methods like drawEllipse, drawPolygon, etc., to their v8 equivalents.",
            "dependencies": [
              1
            ],
            "details": "Identify and replace methods such as drawEllipse with ellipse, drawPolygon with polygon, etc. Ensure all Graphics shape drawing methods are updated.",
            "status": "done",
            "testStrategy": "Test rendering of ellipses, polygons, and other shapes to confirm they appear as expected."
          },
          {
            "id": 5,
            "title": "Verify and test all Graphics updates",
            "description": "Run tests to ensure all shape drawing works correctly after renaming methods.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Execute the project's test suite, particularly focusing on rendering tests. Manually check that shapes are drawn without errors in the application.",
            "status": "done",
            "testStrategy": "Run automated tests and perform visual checks on shape rendering in the app."
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this is a rename operation across Graphics usage.",
        "updatedAt": "2025-10-15T21:00:09.432Z"
      },
      {
        "id": 8,
        "title": "Use Style Objects for Fills and Strokes",
        "description": "Update fill() and stroke() calls to use style objects where applicable.",
        "details": "Change calls like fill(color) to fill({color: color}) and stroke(width, color) to stroke({width: width, color: color}).",
        "testStrategy": "Render shapes with fills and strokes and check for correct styling.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify Files with Fill and Stroke Calls",
            "description": "Scan the codebase to find all files that use fill() or stroke() methods.",
            "dependencies": [
              7
            ],
            "details": "Use grep or search tools to locate all instances of fill( and stroke( in the project files, ensuring to cover all shape creation code.",
            "status": "done",
            "testStrategy": "Basic verification: run and ensure no errors."
          },
          {
            "id": 2,
            "title": "Convert Fill Calls to Style Objects",
            "description": "Change all fill(color) calls to fill({color: color}) format.",
            "dependencies": [
              1
            ],
            "details": "For each identified fill call, modify the parameters to pass an object with the color property, ensuring compatibility with PixiJS v8 API.",
            "status": "done",
            "testStrategy": "Basic verification: run and ensure no errors."
          },
          {
            "id": 3,
            "title": "Convert Stroke Calls to Style Objects",
            "description": "Change stroke(width, color) calls to stroke({width: width, color: color}) format.",
            "dependencies": [
              1
            ],
            "details": "For each stroke call, update to use an object with width and color properties, matching the new PixiJS v8 style object structure.",
            "status": "done",
            "testStrategy": "Basic verification: run and ensure no errors."
          },
          {
            "id": 4,
            "title": "Review and Fix Edge Cases",
            "description": "Check for any complex fill or stroke usages that need special handling.",
            "dependencies": [
              2,
              3
            ],
            "details": "Ensure all changes are syntactically correct, handle any edge cases like multiple parameters or conditional calls, and verify no errors introduced.",
            "status": "done",
            "testStrategy": "Basic verification: run and ensure no errors."
          },
          {
            "id": 5,
            "title": "Test Shape Rendering with New Styles",
            "description": "Render shapes and verify fills and strokes appear correctly.",
            "dependencies": [
              4
            ],
            "details": "Run the application, render various shapes with fills and strokes, and visually inspect to confirm correct styling and no visual regressions.",
            "status": "done",
            "testStrategy": "Render shapes with fills and strokes and check for correct styling."
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this updates API calls in shape creation.",
        "updatedAt": "2025-10-15T21:00:12.099Z"
      },
      {
        "id": 9,
        "title": "Replace updateTransform with onRender",
        "description": "Update custom logic using updateTransform to use the new onRender hook.",
        "details": "Create an _onRender method and bind it in the constructor. Replace updateTransform calls with onRender.",
        "testStrategy": "Test custom rendering logic to ensure it executes correctly during render cycles.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify classes using updateTransform",
            "description": "Locate all classes in the codebase that currently use the updateTransform method to understand the scope of refactoring needed.",
            "dependencies": [],
            "details": "Search the codebase for 'updateTransform' calls using grep or IDE search tools. Document the classes, methods, and contexts where it's used to prepare for replacement.",
            "status": "done",
            "testStrategy": "Verify that all instances are identified by cross-checking with code review."
          },
          {
            "id": 2,
            "title": "Create _onRender method in identified classes",
            "description": "Add a new _onRender method to each class that previously used updateTransform, implementing the custom logic.",
            "dependencies": [
              1
            ],
            "details": "In each identified class, define a new private method named _onRender that encapsulates the logic previously in updateTransform. Ensure the method signature matches the onRender hook requirements.",
            "status": "done",
            "testStrategy": "Check that the _onRender method is syntactically correct and compiles without errors."
          },
          {
            "id": 3,
            "title": "Bind _onRender in constructors",
            "description": "Bind the _onRender method in the constructor of each affected class to ensure proper context.",
            "dependencies": [
              2
            ],
            "details": "In the constructor of each class, add a binding statement like this._onRender = this._onRender.bind(this); to maintain the correct 'this' context when the method is used as a hook.",
            "status": "done",
            "testStrategy": "Run unit tests to confirm that the binding works and the method can be called without context errors."
          },
          {
            "id": 4,
            "title": "Replace updateTransform calls with onRender",
            "description": "Update all calls to updateTransform to use the new onRender hook instead.",
            "dependencies": [
              3
            ],
            "details": "Replace each updateTransform() call with the appropriate onRender hook invocation, ensuring that the _onRender method is passed or registered as needed in the PixiJS application lifecycle.",
            "status": "done",
            "testStrategy": "Test that the application renders correctly and that custom logic executes during render cycles by observing visual output and console logs."
          },
          {
            "id": 5,
            "title": "Verify and test the refactoring",
            "description": "Perform comprehensive testing to ensure the refactoring from updateTransform to onRender works as expected.",
            "dependencies": [
              4
            ],
            "details": "Run the full application, check for any runtime errors, and validate that rendering behavior matches the original functionality. Use debugging tools to step through render cycles.",
            "status": "done",
            "testStrategy": "Conduct integration tests focusing on render cycle execution, including edge cases like multiple objects and performance benchmarks."
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this refactors custom logic in specific classes.",
        "updatedAt": "2025-10-15T21:00:14.776Z"
      },
      {
        "id": 10,
        "title": "Update getBounds Usage",
        "description": "Refactor getBounds() calls to use the new return format.",
        "details": "Change container.getBounds() to container.getBounds().rectangle where a PIXI.Rectangle is expected.",
        "testStrategy": "Test bounding box calculations for containers and ensure selections work.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify all getBounds() call sites",
            "description": "Search the codebase to locate every instance where getBounds() is called on containers, ensuring a comprehensive list for refactoring.",
            "dependencies": [],
            "details": "Use grep or IDE search tools to find all occurrences of .getBounds() in the project files, excluding comments and documentation. Document the file paths and line numbers for each call.",
            "status": "done",
            "testStrategy": "Verify the list by manually checking a sample of files to ensure no calls are missed."
          },
          {
            "id": 2,
            "title": "Update getBounds() calls to use .rectangle",
            "description": "Modify each identified getBounds() call to append .rectangle where a PIXI.Rectangle is expected, based on the new return format.",
            "dependencies": [
              1
            ],
            "details": "For each call site identified in subtask 1, change container.getBounds() to container.getBounds().rectangle. Ensure the context confirms PIXI.Rectangle is expected, and handle any necessary imports or type checks.",
            "status": "done",
            "testStrategy": "Compile the code after changes and check for TypeScript errors or runtime issues related to rectangle access."
          },
          {
            "id": 3,
            "title": "Handle edge cases and conditional usages",
            "description": "Address any conditional or complex usages of getBounds() that might require special handling in the refactoring.",
            "dependencies": [
              1
            ],
            "details": "Review the identified call sites for scenarios like conditional checks, loops, or assignments. Adjust the code to properly access .rectangle in these cases, ensuring the logic remains intact.",
            "status": "done",
            "testStrategy": "Run unit tests on affected components to confirm edge cases behave as expected."
          },
          {
            "id": 4,
            "title": "Update related bounding box calculations",
            "description": "Adjust any calculations or operations that depend on the getBounds() return value to work with the new .rectangle format.",
            "dependencies": [
              2
            ],
            "details": "Locate and modify code that performs operations on the getBounds() result, such as width/height calculations or intersection checks, to use the rectangle properties correctly.",
            "status": "done",
            "testStrategy": "Test bounding box calculations manually or via automated tests to ensure accuracy."
          },
          {
            "id": 5,
            "title": "Verify and test overall functionality",
            "description": "Run comprehensive tests to ensure the refactored getBounds() usages work correctly and selections or bounding boxes function as intended.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Execute the project's test suite, focusing on rendering, selections, and any features relying on bounding boxes. Manually test UI interactions that depend on getBounds() to confirm no regressions.",
            "status": "done",
            "testStrategy": "Use visual inspections and automated tests to validate that shapes, containers, and selections render and behave correctly with the new format."
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this adjusts getBounds calls to new format.",
        "updatedAt": "2025-10-15T21:00:17.386Z"
      },
      {
        "id": 11,
        "title": "Update Ticker Callback",
        "description": "Adjust Ticker callback to use ticker.deltaTime instead of direct deltaTime.",
        "details": "Modify Ticker.shared.add() callback to access deltaTime via ticker.deltaTime.",
        "testStrategy": "Test animations and updates that rely on ticker to ensure smooth performance.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Locate Ticker Callbacks",
            "description": "Search the codebase for all instances of Ticker.shared.add() callbacks that use direct deltaTime.",
            "dependencies": [],
            "details": "Use grep or IDE search to find all Ticker.shared.add() calls and note where deltaTime is accessed directly instead of via ticker.deltaTime. This ensures we identify all locations needing updates.",
            "status": "done",
            "testStrategy": "Verify that all identified callbacks are listed and none are missed by cross-checking with code review."
          },
          {
            "id": 2,
            "title": "Modify Callback Signatures",
            "description": "Update the callback functions to accept the ticker parameter and access deltaTime via ticker.deltaTime.",
            "dependencies": [
              1
            ],
            "details": "For each identified callback, change the function signature to include 'ticker' as the first parameter, and replace any direct deltaTime references with ticker.deltaTime. Ensure the callback is properly bound if necessary.",
            "status": "done",
            "testStrategy": "Compile the code and check for syntax errors in the modified callbacks."
          },
          {
            "id": 3,
            "title": "Update Ticker Registration",
            "description": "Ensure Ticker.shared.add() calls pass the callback correctly with the new signature.",
            "dependencies": [
              2
            ],
            "details": "Review and adjust the Ticker.shared.add() calls to ensure they are registering the updated callbacks properly. If the callback was previously anonymous, consider making it a named function for clarity.",
            "status": "done",
            "testStrategy": "Run the application and confirm that callbacks are registered without errors, checking console logs for any Ticker-related warnings."
          },
          {
            "id": 4,
            "title": "Test Animation Performance",
            "description": "Run tests to verify that animations using the updated callbacks perform smoothly.",
            "dependencies": [
              3
            ],
            "details": "Execute unit tests or manual tests for animations and updates that rely on the ticker. Measure frame rates and ensure deltaTime calculations are accurate, preventing issues like variable time steps.",
            "status": "done",
            "testStrategy": "Use performance profiling tools to monitor frame times and deltaTime values during animation playback."
          },
          {
            "id": 5,
            "title": "Code Review and Final Validation",
            "description": "Conduct a final review of all changes and validate the migration to ticker.deltaTime.",
            "dependencies": [
              4
            ],
            "details": "Perform a code review to ensure all Ticker callbacks now use ticker.deltaTime consistently. Run a full test suite to confirm no regressions in animation or update logic.",
            "status": "done",
            "testStrategy": "Integrate with CI/CD pipeline to run automated tests, ensuring the changes pass all existing test cases related to rendering and updates."
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this modifies a single callback.",
        "updatedAt": "2025-10-15T21:00:19.870Z"
      },
      {
        "id": 12,
        "title": "Replace PIXI.utils Imports",
        "description": "Update all PIXI.utils.* calls to direct imports from 'pixi.js'.",
        "details": "Change imports like PIXI.utils.isMobile to import { isMobile } from 'pixi.js'.",
        "testStrategy": "Run the app and check for any utils-related errors or warnings.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify Files Using PIXI.utils Imports",
            "description": "Scan the entire codebase to find all files that contain PIXI.utils.* calls or imports.",
            "dependencies": [],
            "details": "Use grep or a code search tool to locate all instances of PIXI.utils in the project files, including JavaScript, TypeScript, and any other relevant files. Document the list of files and specific lines for reference.",
            "status": "done",
            "testStrategy": "Verify the list by manually checking a few files to ensure no instances are missed."
          },
          {
            "id": 2,
            "title": "Update Import Statements in Identified Files",
            "description": "Replace PIXI.utils imports with direct imports from 'pixi.js' in each identified file.",
            "dependencies": [
              1
            ],
            "details": "For each file from subtask 1, change statements like 'import PIXI from 'pixi.js';' followed by PIXI.utils usage, to direct imports such as 'import { isMobile } from 'pixi.js';'. Ensure all necessary utils functions are imported.",
            "status": "done",
            "testStrategy": "Check the import sections of updated files to confirm they match the new direct import pattern."
          },
          {
            "id": 3,
            "title": "Replace PIXI.utils Usage with Direct Calls",
            "description": "Update all code references from PIXI.utils.something to just something, assuming the direct import is in place.",
            "dependencies": [
              2
            ],
            "details": "Go through each file and replace usages like PIXI.utils.isMobile() with isMobile(), ensuring the function is imported directly. Handle any potential naming conflicts or scope issues.",
            "status": "done",
            "testStrategy": "Run a linter or static analysis tool to detect any undefined references or syntax errors after replacements."
          },
          {
            "id": 4,
            "title": "Verify No Remaining PIXI.utils References",
            "description": "Perform a final check to ensure all PIXI.utils calls have been replaced and no references remain.",
            "dependencies": [
              3
            ],
            "details": "Re-scan the codebase using the same search method as in subtask 1 to confirm zero instances of PIXI.utils. Review any build or compilation logs for related warnings.",
            "status": "done",
            "testStrategy": "Attempt to build the project and check for any errors related to missing PIXI.utils imports."
          },
          {
            "id": 5,
            "title": "Test Application Functionality",
            "description": "Run the application and verify that all utils-related functionality works correctly after the import changes.",
            "dependencies": [
              4
            ],
            "details": "Start the app, interact with features that use the updated utils (e.g., mobile detection), and monitor for runtime errors. Ensure rendering and logic dependent on these utils perform as expected.",
            "status": "done",
            "testStrategy": "Run the app and check console for any utils-related errors or warnings, as per the parent task's test strategy."
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this updates import statements.",
        "updatedAt": "2025-10-15T21:00:30.253Z"
      },
      {
        "id": 13,
        "title": "Implement CullerPlugin for Performance",
        "description": "Add and configure the CullerPlugin for automatic culling.",
        "details": "Import { extensions, CullerPlugin } from 'pixi.js' and add extensions.add(CullerPlugin). Set cullable = true on the main viewport container.",
        "testStrategy": "Monitor FPS during scene rendering with many objects to ensure culling improves performance.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Import CullerPlugin from PixiJS",
            "description": "Import the CullerPlugin and extensions from the pixi.js library to prepare for plugin addition.",
            "dependencies": [],
            "details": "In the main application file, add the import statement: import { extensions, CullerPlugin } from 'pixi.js';. Ensure this is done after the PixiJS application is initialized.",
            "status": "done",
            "testStrategy": "Verify that the import does not cause any syntax errors or runtime issues during application startup."
          },
          {
            "id": 2,
            "title": "Add CullerPlugin to Extensions",
            "description": "Register the CullerPlugin with the PixiJS extensions system to enable automatic culling functionality.",
            "dependencies": [
              1
            ],
            "details": "After importing, add the plugin by calling extensions.add(CullerPlugin);. This should be done in the initialization phase of the application, ensuring it happens before creating any renderable objects.",
            "status": "done",
            "testStrategy": "Check the console for any errors related to plugin registration and confirm that the plugin is listed in the extensions."
          },
          {
            "id": 3,
            "title": "Configure Main Viewport as Cullable",
            "description": "Set the cullable property to true on the main viewport container to allow the CullerPlugin to manage its visibility.",
            "dependencies": [
              2
            ],
            "details": "Locate the main viewport container in the code and set its cullable property: viewport.cullable = true;. This enables culling for objects within this container, improving performance by not rendering off-screen elements.",
            "status": "done",
            "testStrategy": "Inspect the viewport object in the debugger to confirm the cullable property is set to true."
          },
          {
            "id": 4,
            "title": "Integrate Culling into Application Lifecycle",
            "description": "Ensure the culling logic is properly integrated into the application's rendering loop or initialization sequence.",
            "dependencies": [
              3
            ],
            "details": "Verify that the CullerPlugin is active during the application's update and render cycles. This may involve checking that the plugin hooks into the ticker or render events appropriately.",
            "status": "done",
            "testStrategy": "Run the application and observe that culling is occurring by checking for reduced draw calls in performance tools."
          },
          {
            "id": 5,
            "title": "Monitor Performance Improvements",
            "description": "Test and monitor the performance gains from enabling culling, especially in scenes with many objects.",
            "dependencies": [
              4
            ],
            "details": "Use performance monitoring tools to measure FPS before and after enabling culling. Load a scene with numerous objects and compare rendering times, ensuring the plugin reduces unnecessary computations.",
            "status": "done",
            "testStrategy": "Monitor FPS during scene rendering with many objects using browser dev tools or a performance monitor, verifying that culling improves performance without introducing errors."
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this adds and configures a plugin.",
        "updatedAt": "2025-10-15T21:08:50.754Z"
      },
      {
        "id": 14,
        "title": "Optimize Event System",
        "description": "Review and set interactiveChildren to false on non-interactive containers.",
        "details": "Identify containers like grid backgrounds and set interactiveChildren = false to reduce event traversal.",
        "testStrategy": "Test interaction with interactive elements and ensure non-interactive ones don't interfere.",
        "priority": "low",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify Container Objects in Codebase",
            "description": "Scan the codebase to locate all instances of container objects such as DisplayObjectContainers, Sprites, or other PixiJS objects that hold child elements.",
            "dependencies": [
              4
            ],
            "details": "Use grep or manual search in files like main.js, canvas.js, and other relevant files to find all container declarations and usages. Document their locations and types.",
            "status": "done",
            "testStrategy": "Verify the list of identified containers matches expected structures in the code."
          },
          {
            "id": 2,
            "title": "Classify Containers as Interactive or Non-Interactive",
            "description": "Review each identified container to determine if it requires interactivity or is purely for layout/background purposes.",
            "dependencies": [
              1
            ],
            "details": "Examine the purpose of each container, such as grid backgrounds being non-interactive. Categorize them based on whether they handle user events or not.",
            "status": "done",
            "testStrategy": "Cross-check classifications with code comments or usage patterns to ensure accuracy."
          },
          {
            "id": 3,
            "title": "Set interactiveChildren to False on Non-Interactive Containers",
            "description": "Apply the interactiveChildren = false property to all containers classified as non-interactive.",
            "dependencies": [
              2
            ],
            "details": "Modify the code in the relevant files to add or set interactiveChildren = false on the identified non-interactive containers, ensuring no interactive children are affected.",
            "status": "done",
            "testStrategy": "Run the application and check that no errors occur during initialization or rendering."
          },
          {
            "id": 4,
            "title": "Test Interactive Element Functionality",
            "description": "Verify that interactive elements within the containers still respond correctly to user interactions.",
            "dependencies": [
              3
            ],
            "details": "Interact with buttons, clickable areas, or other interactive components in the app to ensure they trigger events as expected after the changes.",
            "status": "done",
            "testStrategy": "Use manual testing or automated scripts to simulate interactions and log event firings."
          },
          {
            "id": 5,
            "title": "Validate Event Traversal Optimization",
            "description": "Confirm that setting interactiveChildren reduces unnecessary event processing on non-interactive containers.",
            "dependencies": [
              4
            ],
            "details": "Monitor event handling performance, perhaps by adding temporary logging or using browser dev tools to check event propagation paths and ensure efficiency improvements.",
            "status": "done",
            "testStrategy": "Compare event logs or performance metrics before and after changes to quantify the optimization."
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this sets properties on containers.",
        "updatedAt": "2025-10-15T21:10:30.101Z"
      },
      {
        "id": 15,
        "title": "Conduct Functional and Performance Testing",
        "description": "Run full testing suite including functional checks and performance benchmarks.",
        "details": "Execute QA checklist for user stories. Run performance tests using PerformanceMonitor, comparing to v7 baseline. Ensure FPS meets criteria.",
        "testStrategy": "Validate all acceptance criteria: no errors, tests pass, performance met, no deprecations.",
        "priority": "high",
        "dependencies": [
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Run Functional Checks on User Stories",
            "description": "Execute the QA checklist to verify that all user stories meet their acceptance criteria, ensuring no errors occur and all tests pass.",
            "dependencies": [
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14
            ],
            "details": "Go through each user story in the QA checklist, perform functional tests to check for correct behavior, error handling, and compliance with requirements. Document any issues found and ensure all tests are passing before proceeding.",
            "status": "done",
            "testStrategy": "Validate all acceptance criteria including no errors and tests passing."
          },
          {
            "id": 2,
            "title": "Run Performance Benchmarks Against v7 Baseline",
            "description": "Execute performance tests using PerformanceMonitor to compare current performance against the v7 baseline and ensure FPS meets the required criteria.",
            "dependencies": [
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14
            ],
            "details": "Set up and run PerformanceMonitor on the application, measure FPS and other key metrics during benchmarks, compare results directly to the v7 baseline data, and verify that performance thresholds are met or exceeded.",
            "status": "done",
            "testStrategy": "Monitor FPS and other performance metrics, ensuring they meet or exceed the v7 baseline criteria."
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Generate subtasks for running functional checks on user stories and separate subtasks for performance benchmarks against v7 baseline.",
        "updatedAt": "2025-10-15T21:00:32.389Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-16T20:18:53.900Z",
      "taskCount": 15,
      "completedCount": 15,
      "tags": [
        "pixi-upgrade"
      ],
      "created": "2025-10-16T21:25:04.764Z",
      "description": "Tasks for pixi-upgrade context",
      "updated": "2025-10-16T21:25:04.764Z"
    }
  },
  "auth0": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up Auth0 configuration and environment variables",
        "description": "Configure Auth0 domain, client ID, client secret, callback URL, and audience in the application configuration to enable OAuth2 integration.",
        "details": "Create a configuration file or module (e.g., src/auth0-config.lisp) with parameters like *auth0-domain*, *auth0-client-id*, etc., using environment variables. Implement helper functions such as auth0-authorize-url, auth0-token-url, auth0-userinfo-url, and auth0-logout-url as specified in the PRD. Ensure secure handling of secrets and validate that all required environment variables are set.",
        "testStrategy": "Unit test the configuration functions to verify correct URL generation and parameter inclusion. Mock environment variables and check for proper error handling if variables are missing.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break down the setup of Auth0 configuration into subtasks focusing on creating the configuration module, implementing helper functions, and adding validation for environment variables."
      },
      {
        "id": 2,
        "title": "Update database schema to support Auth0 fields",
        "description": "Modify the users table to include Auth0-specific fields like auth0_sub, display_name, avatar_url, email_verified, and last_login_at, making password_hash nullable.",
        "details": "Execute the SQL schema changes as provided in the PRD, recreating the users table with new columns and copying existing data. Add indexes for auth0_sub, email, and username. Ensure backward compatibility by keeping password_hash nullable for legacy users.",
        "testStrategy": "Integration test by running the schema migration on a test database, verifying that existing data is preserved and new columns are added correctly. Check for no data loss and proper indexing.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Divide the database schema update into subtasks for executing SQL changes and ensuring data migration with backward compatibility."
      },
      {
        "id": 3,
        "title": "Implement OAuth2 authorization flow initiation",
        "description": "Create the handler to redirect users to Auth0's authorization endpoint with proper state parameter for CSRF protection.",
        "details": "Implement handle-auth0-login function in src/auth0-oauth.lisp, generating a secure state token, storing it temporarily, and redirecting to the Auth0 authorize URL. Include state expiry mechanism using threads for cleanup after 5 minutes.",
        "testStrategy": "Unit test the handler to ensure correct redirect URL generation and state storage. Simulate requests and verify state validation in subsequent steps.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Expand the OAuth2 flow initiation into subtasks covering state token generation, temporary storage, and redirect handling with expiry mechanisms."
      },
      {
        "id": 4,
        "title": "Implement OAuth2 callback and token exchange",
        "description": "Handle the Auth0 callback, validate state, exchange authorization code for tokens, and process the response.",
        "details": "Implement handle-auth0-callback function, checking for errors and state validity, then calling exchange-code-for-tokens to POST to Auth0's token endpoint. Parse the response for access_token and id_token. Handle errors gracefully with logging.",
        "testStrategy": "Integration test by mocking the callback request with valid/invalid codes and states. Verify token exchange via HTTP calls to a test Auth0 endpoint and check error responses.",
        "priority": "high",
        "dependencies": [
          "1",
          "3"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down the callback handling into subtasks for state validation, token exchange via HTTP, response parsing, and error handling."
      },
      {
        "id": 5,
        "title": "Implement JWT ID token decoding and validation",
        "description": "Decode the ID token, validate its signature, issuer, audience, and expiration, and extract user claims.",
        "details": "Implement decode-id-token and validate-jwt-signature functions, fetching JWKS from Auth0 for signature verification using RS256. Cache JWKS for 24 hours. Validate claims as per OAuth2 standards and return user info like sub, email, name, etc.",
        "testStrategy": "Unit test with mock JWTs, verifying signature validation, claim checks, and error handling for expired or invalid tokens. Use test JWKS data to simulate Auth0 responses.",
        "priority": "high",
        "dependencies": [
          "1",
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 8,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Subdivide JWT handling into tasks for decoding, signature validation with JWKS, claim validation, and caching mechanisms."
      },
      {
        "id": 6,
        "title": "Implement user finding and creation from OAuth data",
        "description": "Check for existing users by auth0_sub or email, update or create new users, and handle linking for legacy accounts.",
        "details": "Implement find-or-create-user-from-oauth, get-user-by-auth0-sub, update-user-from-oauth, link-auth0-to-user, and create-user-from-oauth functions. Use database transactions for safety. Generate usernames from emails if needed.",
        "testStrategy": "Unit test the functions with mock OAuth user info, verifying user creation, updates, and linking. Integration test by inserting test data and checking database state after operations.",
        "priority": "medium",
        "dependencies": [
          "2",
          "5"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Expand user management into subtasks for finding existing users, creating new ones, updating records, and handling legacy account linking with transactions."
      },
      {
        "id": 7,
        "title": "Implement session creation and cookie management",
        "description": "Create user sessions upon successful OAuth authentication and set secure session cookies.",
        "details": "After validating tokens and finding/creating users, call create-session-for-user and set-session-cookie with HttpOnly, Secure, SameSite=strict flags, and 24-hour expiry. Ensure sessions are stored securely.",
        "testStrategy": "Integration test the full flow, checking cookie setting and session retrieval. Verify cookie security attributes and session validity across requests.",
        "priority": "medium",
        "dependencies": [
          "5",
          "6"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Divide session handling into subtasks for creating sessions and setting secure cookies with proper attributes."
      },
      {
        "id": 8,
        "title": "Update frontend for Auth0 login integration",
        "description": "Modify the frontend to include Auth0 login buttons, handle redirects, and support dual-mode authentication during transition.",
        "details": "Update frontend/src/auth.js with AuthManager class, adding loginWithAuth0, loginWithGoogle, loginWithGithub methods. Modify UI in login page to show Auth0 and social login options, keeping legacy login for transition.",
        "testStrategy": "Manual testing in browser: click login buttons, verify redirects to Auth0, and successful callback. Check UI rendering and error handling for failed logins.",
        "priority": "medium",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down frontend updates into subtasks for modifying the AuthManager class, updating UI elements, and supporting dual-mode authentication."
      },
      {
        "id": 9,
        "title": "Implement user migration and linking flow",
        "description": "Allow existing users to link their Auth0 accounts to legacy profiles during Phase 2.",
        "details": "Implement handle-link-auth0-account function, requiring legacy login first, then initiating OAuth with metadata to link. Update user records with auth0_sub upon successful linking. Add UI banners and email campaigns as per PRD.",
        "testStrategy": "Integration test the linking flow: simulate legacy login, initiate link, complete OAuth, and verify database updates. Manual test with real users to ensure no disruption.",
        "priority": "medium",
        "dependencies": [
          "6",
          "8"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Expand the migration flow into subtasks for implementing the linking handler, updating UI banners, managing email campaigns, and ensuring database updates."
      },
      {
        "id": 10,
        "title": "Implement monitoring, testing, and deprecation of legacy auth",
        "description": "Add metrics collection, comprehensive testing, and gradual removal of legacy authentication in Phase 3.",
        "details": "Implement get-auth-metrics for monitoring key stats. Conduct unit, integration, and manual tests as outlined. Add feature flags for Auth0 enablement and deprecate legacy endpoints after migration thresholds.",
        "testStrategy": "Run full test suite including OAuth flow simulations, social logins, and migration. Monitor metrics for errors and usage. Manual checklist verification for security and functionality.",
        "priority": "low",
        "dependencies": [
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 9,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Subdivide the final phase into tasks for metrics collection, comprehensive testing, feature flag implementation, legacy deprecation, and monitoring setup."
      },
      {
        "id": 11,
        "title": "Implement JWT Signature Validation with RS256 and JWKS",
        "description": "Enhance JWT validation to include cryptographic signature verification using RS256 algorithm and Auth0's JWKS endpoint, ensuring secure token authenticity beyond claims validation.",
        "details": "Update the existing JWT validation logic (likely in Task 5's functions) to incorporate signature verification. Use a robust JWT library such as 'jose' or 'cl-jwt' for Common Lisp to handle decoding, signature verification, and JWKS management. Implement a function to fetch Auth0's JWKS (JSON Web Key Set) from the configured endpoint (e.g., https://your-domain.auth0.com/.well-known/jwks.json), parse the keys, and select the appropriate RSA public key based on the 'kid' (Key ID) in the JWT header. Verify the JWT signature using RS256 (RSA with SHA-256) against the public key. Implement caching for the JWKS with a TTL (Time-To-Live) of 24 hours to minimize network calls and improve performance; use a thread-safe cache mechanism like a hash table with expiry timestamps or a library such as 'cl-cache'. Ensure the cache handles key rotation by re-fetching if a 'kid' is not found. Validate standard claims (iss, aud, exp, iat) as before, but now as part of a comprehensive validation function that returns true only if both signature and claims are valid. Handle errors gracefully, such as invalid signatures, network failures during JWKS fetch, or malformed JWKS, by logging and returning appropriate error responses. Consider security best practices: avoid storing private keys, use HTTPS for JWKS fetches, and implement rate limiting if needed. Integrate this into the OAuth callback flow after token exchange (from Task 4).",
        "testStrategy": "Conduct unit tests with mock JWTs: create valid and invalid signed tokens using test keys, verify signature validation passes/fails correctly, and check JWKS caching behavior (e.g., simulate cache expiry and re-fetch). Use integration tests to simulate the full OAuth flow: mock Auth0 responses including JWKS, exchange code for tokens, and validate the ID token with signature verification. Test edge cases like key rotation (new 'kid'), network timeouts during JWKS fetch, and malformed JWKS. Perform manual tests in a staging environment with real Auth0 integration, monitoring logs for signature validation successes/failures and cache hits/misses. Verify performance impact by measuring response times with and without caching. Ensure compliance with OAuth2 and JWT RFC standards.",
        "status": "done",
        "dependencies": [
          "4"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement JWKS Fetching Function",
            "description": "Create a function to fetch the JSON Web Key Set (JWKS) from Auth0's endpoint, handling network requests and parsing the response.",
            "dependencies": [],
            "details": "Implement a function named 'fetch-jwks' that makes an HTTPS GET request to the configured Auth0 JWKS endpoint (e.g., https://your-domain.auth0.com/.well-known/jwks.json). Use a Common Lisp HTTP library like Drakma to perform the request. Parse the JSON response into a usable structure, such as a list of key objects. Handle errors like network failures or invalid JSON by logging and returning nil or an error indicator. Ensure the function is thread-safe if called concurrently.",
            "status": "pending",
            "testStrategy": "Unit test the function with mocked HTTP responses: simulate successful fetches, network errors, and malformed JSON to verify correct parsing and error handling.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement JWKS Caching Mechanism",
            "description": "Set up a thread-safe caching system for JWKS data with a 24-hour TTL to reduce network calls and handle key rotation.",
            "dependencies": [
              1
            ],
            "details": "Implement a cache using a thread-safe hash table or a library like cl-cache. Store the fetched JWKS with an expiry timestamp set to 24 hours from fetch time. Create functions to check cache validity, retrieve keys, and refresh the cache if expired or if a key ID is not found. Ensure the cache handles concurrent access using locks or atomic operations. Integrate this with the fetching function to automatically re-fetch when needed.",
            "status": "pending",
            "testStrategy": "Unit test caching behavior: simulate cache hits, misses, expiries, and key rotations by mocking time and verifying re-fetch calls.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement RSA Public Key Selection",
            "description": "Add logic to select the appropriate RSA public key from the JWKS based on the 'kid' in the JWT header.",
            "dependencies": [
              2
            ],
            "details": "In the JWT validation process, decode the JWT header to extract the 'kid' (Key ID). Query the cached JWKS to find the matching key. If not found, trigger a cache refresh. Convert the selected key (in JWK format) to an RSA public key object using the JWT library (e.g., 'jose' or 'cl-jwt'). Handle cases where the key is not RSA or RS256 compatible by raising appropriate errors. This ensures the correct public key is used for signature verification.",
            "status": "pending",
            "testStrategy": "Unit test key selection: create mock JWKS with multiple keys, test matching 'kid', non-matching cases, and invalid key types.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement JWT Signature Verification with RS256",
            "description": "Verify the JWT signature using the selected RSA public key and RS256 algorithm.",
            "dependencies": [
              3
            ],
            "details": "Using the JWT library, implement signature verification by decoding the JWT, extracting the signature, and verifying it against the RSA public key using RS256 (RSA with SHA-256). Ensure the verification process checks the entire token integrity. Return true if valid, false otherwise. Integrate error handling for invalid signatures, mismatched algorithms, or corrupted tokens, logging details for debugging.",
            "status": "pending",
            "testStrategy": "Unit test signature verification: use mock JWTs signed with test keys, verify valid signatures pass and invalid ones fail, including algorithm mismatches.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate Comprehensive JWT Validation",
            "description": "Combine signature verification with claims validation into a single function and integrate it into the OAuth callback flow.",
            "dependencies": [
              4
            ],
            "details": "Create a comprehensive 'validate-jwt' function that first performs signature verification (from subtask 4) and then validates standard claims (iss, aud, exp, iat) as in Task 5. Return true only if both are valid. Handle errors gracefully, such as by returning error responses. Integrate this into the OAuth callback handler after token exchange (from Task 4), ensuring the flow proceeds only on successful validation. Update existing logic from Task 5 to use this new function.",
            "status": "pending",
            "testStrategy": "Integration test the full validation: mock OAuth flow with valid/invalid tokens, verify signature and claims checks, and ensure proper error responses in the callback handler.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-16T22:33:53.155Z"
      },
      {
        "id": 12,
        "title": "Implement Rate Limiting for OAuth Endpoints",
        "description": "Add rate limiting middleware to the OAuth endpoints (/auth0/login, /auth0/callback, /auth0/link) to prevent abuse by enforcing a limit of 10 requests per hour per IP address using IP-based tracking with a sliding window mechanism.",
        "details": "Implement rate limiting as middleware in the Common Lisp application to protect the specified OAuth endpoints from abuse. Create a global hash table *rate-limit-store* to track request timestamps per IP address, where each key is an IP string and the value is a list of timestamps (in Unix epoch seconds) for recent requests. Develop a check-rate-limit function that, for a given IP, removes timestamps older than 1 hour (3600 seconds) from the list (sliding window), counts the remaining timestamps, and returns true if the count is less than 10, otherwise false. If allowed, append the current timestamp to the list. Apply this middleware to the handlers for /auth0/login (from Task 3), /auth0/callback (from Task 4), and /auth0/link (from Task 9), checking the rate limit before processing the request and returning a 429 Too Many Requests HTTP status with an appropriate error message if exceeded. Use the client's IP address from the request headers (e.g., X-Forwarded-For or remote-addr), with considerations for proxies. For best practices, ensure thread-safety by using locks or atomic operations on the hash table in a multi-threaded environment like Hunchentoot. Periodically clean up the hash table to remove entries for IPs with no recent requests to prevent memory leaks. Research indicates using a sliding window over fixed windows reduces burstiness; consider libraries like cl-store for persistence if needed, but in-memory suffices for this scale. Handle IPv4 and IPv6 addresses uniformly.",
        "testStrategy": "Conduct unit tests for the check-rate-limit function using mock IP addresses and timestamps: simulate multiple requests within an hour to verify blocking after 10, and test window sliding by advancing time and checking if older requests are pruned. Integration tests: Use a test framework to send repeated requests to each endpoint (/auth0/login, /auth0/callback, /auth0/link) from the same IP, verifying that the 11th request returns 429 status and subsequent requests are allowed after the hour window. Mock the IP extraction and test with various header scenarios. Load test with concurrent requests to ensure thread-safety and performance. Manual verification: Deploy to a staging environment, simulate abuse patterns, and monitor logs for rate limit hits without affecting legitimate traffic.",
        "status": "done",
        "dependencies": [
          "3",
          "4",
          "9"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Global Rate Limit Store",
            "description": "Set up a global hash table to track request timestamps per IP address for rate limiting.",
            "dependencies": [],
            "details": "Implement a global hash table *rate-limit-store* in the Common Lisp application, where keys are IP strings and values are lists of Unix epoch timestamps for recent requests. Ensure it handles IPv4 and IPv6 uniformly.",
            "status": "pending",
            "testStrategy": "Unit test the hash table creation and basic operations like insertion and retrieval of timestamps for mock IP addresses.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Check Rate Limit Function",
            "description": "Develop the check-rate-limit function to enforce the sliding window rate limiting logic.",
            "dependencies": [
              1
            ],
            "details": "Create a check-rate-limit function that takes an IP address, removes timestamps older than 3600 seconds from the list, counts remaining timestamps, and returns true if count < 10, appending current timestamp if allowed. Implement sliding window mechanism.",
            "status": "pending",
            "testStrategy": "Unit tests with mock IPs and timestamps: simulate requests to verify blocking after 10 within an hour, and test pruning of old timestamps by advancing time.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Extract Client IP Address from Request",
            "description": "Implement logic to reliably extract the client's IP address from HTTP request headers.",
            "dependencies": [],
            "details": "Develop a function to get the client's IP from headers like X-Forwarded-For or remote-addr, considering proxy scenarios. Handle both IPv4 and IPv6 addresses uniformly for rate limiting purposes.",
            "status": "pending",
            "testStrategy": "Unit tests with various header combinations, including proxies, to ensure correct IP extraction. Mock requests to verify handling of forwarded headers.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Apply Rate Limiting Middleware to OAuth Endpoints",
            "description": "Integrate the rate limiting check as middleware for the specified OAuth handlers.",
            "dependencies": [
              2,
              3
            ],
            "details": "Modify the handlers for /auth0/login, /auth0/callback, and /auth0/link to check rate limit before processing. If exceeded, return 429 status with error message. Apply this middleware ensuring it uses the extracted IP.",
            "status": "pending",
            "testStrategy": "Integration tests using a test framework to send requests to the endpoints, verifying rate limiting blocks after 10 requests per hour per IP and allows within limits.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Ensure Thread-Safety and Periodic Cleanup",
            "description": "Add thread-safety and cleanup mechanisms to the rate limiting system.",
            "dependencies": [
              1,
              2
            ],
            "details": "Use locks or atomic operations for hash table access in multi-threaded Hunchentoot environment. Implement periodic cleanup to remove entries for IPs with no recent requests, preventing memory leaks. Consider in-memory storage sufficiency.",
            "status": "pending",
            "testStrategy": "Stress tests in a multi-threaded setup to verify thread-safety. Unit tests for cleanup function, simulating time passage and checking hash table size reduction.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-16T22:35:49.751Z"
      },
      {
        "id": 13,
        "title": "Implement Environment-Dependent Secure Cookie Flag",
        "description": "Modify the auth0-oauth.lisp file to make the :secure cookie flag dynamic based on the ENVIRONMENT environment variable, setting it to true for production to ensure cookies are only sent over HTTPS, while allowing insecure cookies in development.",
        "details": "In the auth0-oauth.lisp file, replace the hardcoded :secure nil with a dynamic parameter. Define a global parameter *use-secure-cookies* that checks the ENVIRONMENT environment variable using (uiop:getenv \"ENVIRONMENT\") or similar. Set *use-secure-cookies* to t if ENVIRONMENT is \"production\" (or matches production values like \"prod\"), otherwise nil. This follows security best practices where secure cookies prevent transmission over insecure connections in production, reducing risks like session hijacking. Consider using a configuration module (e.g., from Task 1) to centralize environment checks. Ensure the parameter is evaluated at runtime or load time, and document the behavior. For Common Lisp, leverage libraries like uiop for environment access. Update any cookie-setting functions to use this parameter, such as in Hunchentoot or similar web frameworks. Best practices include defaulting to secure in production and providing clear logging or warnings if the environment is misconfigured.",
        "testStrategy": "Unit test the *use-secure-cookies* parameter by mocking the ENVIRONMENT variable: set it to \"production\" and verify it returns t, set to \"development\" and verify nil. Integration test by simulating OAuth login in a test environment, checking that cookies are set with :secure t in production mode and nil in development. Use a test web server to inspect cookie headers in responses. Verify no regressions in existing OAuth flows by running full integration tests for login and callback endpoints.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-10-16T22:22:42.589Z"
      },
      {
        "id": 14,
        "title": "Fix Thread Safety in State Token Cleanup",
        "description": "Modify the cleanup-expired-states function in auth0-oauth.lisp to ensure thread-safe removal of expired state tokens by collecting keys first and removing them in a separate pass, preventing issues from modifying the hash table during iteration.",
        "details": "In the cleanup-expired-states function around line 60 of auth0-oauth.lisp, address the thread safety issue where the hash table is modified during iteration, which can lead to undefined behavior or errors in Common Lisp implementations. Current best practices for thread-safe hash table operations in Common Lisp recommend avoiding modifications during iteration to prevent race conditions in multi-threaded environments. Implement the fix by first iterating over the hash table to collect expired keys into a list (e.g., using maphash or loop to check expiration based on timestamps), then perform a second pass to remove those keys from the hash table using remhash. Ensure the function uses appropriate locking if the hash table is accessed concurrently, such as with a mutex or bordeaux-threads locks, to synchronize access. Consider using a read-write lock for better performance if reads are more frequent than writes. Update any related documentation or comments to reflect the thread-safe approach. This aligns with Common Lisp concurrency patterns, drawing from libraries like bordeaux-threads for synchronization primitives, and ensures robustness in production environments where multiple threads might access the state store simultaneously.",
        "testStrategy": "Conduct unit tests for the cleanup-expired-states function using a testing framework like FiveAM or Prove. Create a mock hash table populated with state tokens, some expired and some not, based on simulated timestamps. Test the function in a single-threaded context first to verify expired keys are correctly identified and removed without errors. For thread safety, use bordeaux-threads to spawn multiple threads that concurrently access and modify the hash table while the cleanup runs periodically (e.g., every few seconds in a loop). Monitor for race conditions by checking hash table integrity post-cleanup, ensuring no keys are lost or corrupted. Use tools like SBCL's thread inspector or add logging to detect any iteration-related exceptions. Integration tests should simulate the full OAuth flow with concurrent requests, verifying that state cleanup does not interfere with active sessions. Run stress tests with high concurrency to confirm no deadlocks or performance degradation, measuring execution time and memory usage.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-10-16T22:19:20.381Z"
      },
      {
        "id": 15,
        "title": "Enhance Error Handling in OAuth Token Exchange",
        "description": "Improve error handling in the exchange-code-for-token function within auth0-oauth.lisp by replacing the generic error handler with specific conditions for network errors and JSON parsing issues, providing appropriate HTTP status codes and user-friendly error messages.",
        "details": "In the auth0-oauth.lisp file, locate the exchange-code-for-token function and modify its error handling from the generic (error (e)) clause to handle specific error types. Use drakma:drakma-error for network-related issues, such as connection failures or HTTP errors like 502 Bad Gateway, and define a custom json-parse-error condition for malformed JSON responses, typically associated with 500 Internal Server Error. For each error type, set the appropriate HTTP status code in the response and include user-friendly messages, e.g., 'Network error occurred during token exchange' for drakma:drakma-error and 'Invalid response format from authorization server' for json-parse-error. Ensure the error handling integrates with the application's web framework (e.g., Hunchentoot or similar) to return proper HTTP responses. Consider using Common Lisp's condition system to define and signal these errors, allowing for clean separation of concerns. Research indicates that specific error handling improves debugging and user experience, aligning with best practices in robust web application development. Avoid catching all errors generically to prevent masking underlying issues. If using libraries like Drakma for HTTP requests and a JSON parser like Yason or Jonathon, ensure compatibility. Update any related logging to capture error details for monitoring.",
        "testStrategy": "Conduct unit tests for the exchange-code-for-token function using a testing framework like FiveAM or Prove. Mock network failures by simulating drakma:drakma-error conditions (e.g., using a test double for HTTP requests) and verify that a 502 status code is returned with the appropriate message. For JSON parsing errors, mock malformed responses and check for 500 status code and user-friendly message. Integration tests should simulate the full OAuth callback flow: use a test server to trigger the function with invalid codes or network disruptions, ensuring the application handles errors gracefully without crashing and logs details appropriately. Verify that valid token exchanges still succeed and that error responses are properly formatted (e.g., JSON or HTML based on the application's response type).",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-10-16T22:23:48.199Z"
      },
      {
        "id": 16,
        "title": "Enhance Frontend Error Handling for OAuth Methods in auth.js",
        "description": "Improve error handling in the OAuth login methods (loginWithAuth0, loginWithGoogle, loginWithGithub) within auth.js by replacing simple console logging with comprehensive checks for HTTP response status, safe JSON parsing, and displaying user-friendly error messages via the showError method, while gracefully managing network failures.",
        "details": "In the auth.js file, locate the AuthManager class and its OAuth methods (loginWithAuth0, loginWithGoogle, loginWithGithub). Currently, these methods likely use fetch or similar for API calls and only log errors to console. Enhance each method with robust error handling following modern JavaScript best practices: wrap the fetch calls in try-catch blocks to handle network failures (e.g., connection timeouts or DNS errors), check response.ok to identify HTTP errors (4xx/5xx), and safely parse JSON responses using response.json() within a try-catch to handle malformed JSON. For errors, extract relevant details from the response (e.g., error message from JSON body if available) and call the existing showError method to display user-friendly messages, such as 'Login failed: Invalid credentials' or 'Network error: Please check your connection'. Implement exponential backoff for retryable network errors (e.g., 5xx status codes) using a utility function with setTimeout, limiting retries to 3 attempts. Ensure error messages are localized if an i18n system is in place, and log detailed errors to console.error for debugging while keeping user-facing messages generic. Use async/await for readability and avoid callback hell. Consider integrating with a global error boundary or logging service like Sentry for production monitoring. This approach aligns with current best practices for frontend error handling, emphasizing user experience and security by not exposing sensitive details.",
        "testStrategy": "Conduct manual testing in a browser environment: simulate various error scenarios using browser developer tools (e.g., throttle network to 'Offline' for network failures, use mock servers like Postman or a local Express server to return 4xx/5xx responses with error JSON). Verify that user-friendly messages appear via showError for each method, and check console.error logs for detailed debugging info. For unit tests, use Jest or Mocha to mock fetch responses: test successful logins, HTTP errors (e.g., 400 with error JSON), network failures (throwing errors), and malformed JSON. Assert that showError is called with appropriate messages, retries occur for 5xx errors, and no unhandled exceptions propagate. Integration tests should cover the full login flow, ensuring errors don't break the UI state and redirects work post-error. Validate accessibility by checking error messages are announced via screen readers if showError supports ARIA.",
        "status": "done",
        "dependencies": [
          "8"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-10-16T22:24:51.125Z"
      },
      {
        "id": 17,
        "title": "Add Docstrings to Core OAuth Functions in auth0-oauth.lisp",
        "description": "Add comprehensive docstrings to key functions in auth0-oauth.lisp, including parse-jwt, exchange-code-for-token, validate-id-token, and other core OAuth functions, following Common Lisp conventions with detailed descriptions of parameters, return values, and behavior.",
        "details": "In the auth0-oauth.lisp file, identify the core OAuth functions such as parse-jwt, exchange-code-for-token, validate-id-token, and any other essential functions (e.g., those handling token validation, state management, or error responses). For each function, add a docstring immediately following the function definition using Common Lisp's standard docstring placement. Follow established Common Lisp docstring conventions: start with a brief description of the function's purpose, then list parameters with their types and descriptions, followed by return value details including types and possible values. Include any side effects, error conditions, or examples where relevant. Use clear, concise language and ensure consistency across functions. For instance, for exchange-code-for-token, describe parameters like authorization-code and redirect-uri, and specify return values such as a token object or error signals. Research and incorporate best practices from Common Lisp documentation standards, such as those outlined in the CLHS (Common Lisp HyperSpec) and tools like SLIME for docstring formatting. Ensure docstrings are machine-readable for tools like documentation generators (e.g., using DECLARE or custom macros if needed, but stick to standard strings). Consider internationalization if applicable, but prioritize English for clarity. Update any related comments or inline documentation to avoid redundancy.",
        "testStrategy": "Verify docstring addition by manually inspecting the auth0-oauth.lisp file to ensure each targeted function has a docstring in the correct position (after DEFUN or similar). Use a Common Lisp REPL or IDE like Emacs with SLIME to query function documentation via DESCRIBE or DOCUMENTATION functions, confirming that parameters, return values, and descriptions are accurately reflected. Conduct peer code review to assess clarity and adherence to conventions. Run automated checks if available (e.g., via linters like lisp-critic or custom scripts) to detect missing docstrings. Test that the functions still operate correctly after docstring addition by running existing unit tests for parse-jwt, exchange-code-for-token, etc., ensuring no functional changes were introduced. Document the docstrings in project documentation or README to confirm they enhance code maintainability.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-10-16T22:21:53.015Z"
      },
      {
        "id": 18,
        "title": "Extract Magic Numbers to Named Constants in auth0-oauth.lisp",
        "description": "Refactor the auth0-oauth.lisp file to replace hardcoded magic numbers, such as the 300-second state token TTL, with named constants following Common Lisp conventions, including rate limits, timeouts, and other similar values to improve code readability and maintainability.",
        "details": "In the auth0-oauth.lisp file, identify all hardcoded magic numbers related to OAuth functionality, including but not limited to the state token TTL (e.g., 300 seconds), rate limiting thresholds, timeout values, HTTP status codes used in responses, and any other numeric literals that represent configurable or meaningful constants. Define these as named constants using Common Lisp's DEFCONSTANT macro, adhering to naming conventions by enclosing the names in plus signs, such as +STATE-TOKEN-TTL+, +RATE-LIMIT-THRESHOLD+, +REQUEST-TIMEOUT+, etc. Place these constant definitions at the top of the file or in a dedicated constants section for easy reference and modification. Ensure that the constants are evaluated at compile-time where possible for efficiency. Replace all occurrences of the magic numbers with references to these constants throughout the file, using tools like grep or manual inspection to avoid missing any instances. Consider grouping related constants (e.g., all time-related constants together) and adding comments explaining their purpose and units. This refactoring aligns with Common Lisp best practices for code maintainability, as outlined in resources like 'Practical Common Lisp' by Peter Seibel, which emphasizes avoiding magic numbers to make code self-documenting and easier to configure. Be cautious with DEFCONSTANT, as it creates true constants that cannot be redefined without warnings; if runtime configurability is needed, consider DEFPARAMETER instead, but for fixed values like TTLs, DEFCONSTANT is appropriate. After changes, ensure the file compiles without errors and that the constants are accessible in the package namespace.",
        "testStrategy": "Verify the extraction by compiling the auth0-oauth.lisp file and checking for any compilation errors or warnings related to undefined variables. Use a Common Lisp REPL (e.g., SBCL or CCL) to load the file and inspect the defined constants using DESCRIBE or by evaluating them directly to confirm their values match the original magic numbers. Conduct unit tests with a framework like FiveAM or Prove to ensure that functions using these constants (e.g., state token expiration logic) behave identically before and after the change; for instance, create test cases that simulate token creation and expiration, asserting that TTL calculations use the new +STATE-TOKEN-TTL+ constant correctly. Perform integration tests by running the OAuth flow in a test environment, monitoring logs or responses to confirm that timeouts, rate limits, and other behaviors align with the constant values. Use code analysis tools like SLIME in Emacs to search for any remaining magic numbers in the file. Finally, document the constants in the code comments and verify that changing a constant value (e.g., via recompilation) propagates correctly without altering the source code elsewhere.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-10-16T22:20:30.489Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-16T22:35:49.752Z",
      "taskCount": 18,
      "completedCount": 18,
      "tags": [
        "auth0"
      ],
      "created": "2025-10-17T15:17:51.937Z",
      "description": "Tasks for auth0 context",
      "updated": "2025-10-17T15:17:51.937Z"
    }
  },
  "physics": {
    "tasks": [
      {
        "id": 1,
        "title": "Update Object Data Model for Physics Properties",
        "description": "Extend the existing object data model in the backend to include new physics properties such as isDynamic, mass, friction, and restitution for shapes like Rectangles and Circles.",
        "details": "In backend/src/canvas-state.lisp, modify the object structure to add the new fields: isDynamic (boolean, default false), mass (number, default 1), friction (number, 0-1, default 0.1), restitution (number, 0-1, default 0.8). Ensure these are initialized for new objects and can be updated via existing update mechanisms. Use Lisp structs or hash tables for storage, adhering to the current codebase patterns.",
        "testStrategy": "Unit tests in Lisp to verify object creation includes default physics properties and updates apply correctly. Integration tests to ensure objects with physics properties are serialized/deserialized properly in the canvas state.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Modify Object Data Structure to Include Physics Properties",
            "description": "Update the object structure in backend/src/canvas-state.lisp to add new fields: isDynamic (boolean, default false), mass (number, default 1), friction (number, 0-1, default 0.1), and restitution (number, 0-1, default 0.8). Use Lisp structs or hash tables following current patterns.",
            "dependencies": [],
            "details": "Locate the existing object definition in canvas-state.lisp and extend it with the specified physics fields. Ensure the structure supports both Rectangles and Circles. Implement default values during object creation to maintain consistency.",
            "status": "done",
            "testStrategy": "Unit tests to verify new fields are present in created objects with correct defaults."
          },
          {
            "id": 2,
            "title": "Implement Default Initializations and Update Serialization Mechanisms",
            "description": "Ensure new objects are initialized with default physics properties and that existing update mechanisms can modify these fields. Update serialization to include the new properties for proper saving and loading.",
            "dependencies": [
              1
            ],
            "details": "Modify object creation functions to set defaults for isDynamic, mass, friction, and restitution. Integrate with existing update APIs to allow changes. Adjust serialization/deserialization logic in canvas-state.lisp to handle the new fields, ensuring backward compatibility.",
            "status": "done",
            "testStrategy": "Integration tests to confirm serialization includes physics properties and deserialization restores them correctly, plus tests for update mechanisms applying changes."
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Server-Side Physics Engine",
        "description": "Create a new backend module for a deterministic, fixed-timestep 2D Verlet integration physics engine.",
        "details": "Create backend/src/physics.lisp with functions for Verlet integration: applyGravity (global gravity), applyConstraints (canvas boundaries with contain/wrap options), updatePositions, and handleCollisions (simple circle/rectangle collisions). Implement fixed timestep (e.g., 20ms) for deterministic simulation. Use Lisp for efficiency, ensuring the engine is computationally light for 200+ objects.",
        "testStrategy": "Unit tests for physics functions with known inputs/outputs to verify determinism. Performance benchmarks to ensure simulation runs at 50Hz with 200 objects without exceeding CPU limits.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement applyGravity Function",
            "description": "Create the applyGravity function to apply global gravity to all dynamic objects in the physics simulation.",
            "dependencies": [],
            "details": "In backend/src/physics.lisp, define applyGravity as a function that takes a list of objects and applies a downward force (e.g., gravity vector) to each dynamic object's velocity. Ensure it integrates with the Verlet integration loop for accurate physics.",
            "status": "pending",
            "testStrategy": "Unit tests with predefined object states to verify gravity application produces expected velocity changes."
          },
          {
            "id": 2,
            "title": "Implement applyConstraints Function",
            "description": "Develop the applyConstraints function to handle canvas boundaries with contain or wrap options.",
            "dependencies": [],
            "details": "In backend/src/physics.lisp, implement applyConstraints to check object positions against canvas boundaries. For 'contain', bounce or stop objects at edges; for 'wrap', teleport to opposite side. Apply to all dynamic objects during each simulation step.",
            "status": "pending",
            "testStrategy": "Unit tests simulating boundary collisions with known positions to confirm correct containment or wrapping behavior."
          },
          {
            "id": 3,
            "title": "Implement updatePositions Function",
            "description": "Build the updatePositions function for Verlet integration to update object positions based on velocities.",
            "dependencies": [],
            "details": "In backend/src/physics.lisp, create updatePositions using Verlet integration formula: new_position = current_position + velocity * dt + acceleration * dt^2. Iterate over all dynamic objects, updating their positions deterministically in the fixed timestep loop.",
            "status": "pending",
            "testStrategy": "Unit tests with initial positions and velocities to verify position updates match expected Verlet integration outputs."
          },
          {
            "id": 4,
            "title": "Implement handleCollisions Function",
            "description": "Create the handleCollisions function for simple circle and rectangle collision detection and resolution.",
            "dependencies": [],
            "details": "In backend/src/physics.lisp, define handleCollisions to detect and resolve collisions between circles (distance-based) and rectangles (AABB or SAT). Adjust velocities or positions upon collision to prevent overlap, ensuring efficiency for 200+ objects.",
            "status": "pending",
            "testStrategy": "Unit tests with pairs of colliding objects to check collision detection accuracy and resolution without penetration."
          },
          {
            "id": 5,
            "title": "Add Determinism and Performance Optimizations",
            "description": "Implement fixed timestep simulation and optimizations to ensure deterministic behavior and computational efficiency for 200+ objects.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "In backend/src/physics.lisp, set up a fixed timestep loop (e.g., 20ms) using a timer or thread. Optimize data structures (e.g., arrays for objects) and algorithms for O(n) or better complexity. Ensure reproducibility across runs for determinism.",
            "status": "pending",
            "testStrategy": "Performance benchmarks measuring CPU usage at 50Hz with 200 objects; determinism tests by running simulations multiple times and comparing outputs."
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement Simulation Loop and State Broadcasting",
        "description": "Set up a central simulation loop in the backend to run the physics engine and broadcast state snapshots.",
        "details": "In backend/src/websocket-adapter.lisp, use bt:make-thread to create a loop running at 50Hz. Each tick: call physics engine to step simulation, then every 2-3 ticks (e.g., 20Hz), create a snapshot of all isDynamic objects (id, x, y, rotation) and broadcast via WebSocket as 'state-snapshot'. Modify handle-object-update to handle static changes only.",
        "testStrategy": "Integration tests to verify loop runs at correct frequency, snapshots are generated accurately, and broadcasted to clients. Simulate multiple users and check synchronization via logs.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up Threaded Simulation Loop",
            "description": "Create a threaded loop in the backend to run the simulation at 50Hz using bt:make-thread.",
            "dependencies": [],
            "details": "In backend/src/websocket-adapter.lisp, implement a thread that runs a loop at 50Hz, ensuring precise timing for each tick to maintain simulation consistency.",
            "status": "done",
            "testStrategy": "Unit tests to verify the loop frequency is accurately maintained at 50Hz using timing measurements."
          },
          {
            "id": 2,
            "title": "Integrate Physics Engine Steps",
            "description": "Incorporate physics engine stepping into each tick of the simulation loop.",
            "dependencies": [
              1
            ],
            "details": "Within the loop, call the physics engine's step function to update the simulation state, ensuring deterministic behavior with fixed timesteps.",
            "status": "done",
            "testStrategy": "Integration tests to confirm physics steps are executed correctly and deterministically on each loop iteration."
          },
          {
            "id": 3,
            "title": "Generate State Snapshots",
            "description": "Create snapshots of dynamic objects every 2-3 ticks at approximately 20Hz.",
            "dependencies": [
              2
            ],
            "details": "After physics steps, periodically collect id, x, y, and rotation for all isDynamic objects to form a state snapshot, optimizing for performance with 200+ objects.",
            "status": "done",
            "testStrategy": "Tests to validate snapshot accuracy, including correct object data and timing every 2-3 ticks."
          },
          {
            "id": 4,
            "title": "Broadcast State Snapshots via WebSocket",
            "description": "Broadcast generated snapshots to clients and modify object update handling for static changes.",
            "dependencies": [
              3
            ],
            "details": "Send the state snapshots via WebSocket as 'state-snapshot' messages, and update handle-object-update to process only static object changes, ensuring real-time synchronization.",
            "status": "done",
            "testStrategy": "Integration tests simulating multiple clients to verify broadcasting, synchronization, and correct handling of static updates."
          }
        ]
      },
      {
        "id": 4,
        "title": "Port Physics Engine to Frontend",
        "description": "Implement the exact same deterministic physics engine in JavaScript for client-side prediction.",
        "details": "Create frontend/src/physics.js with a JS port of the Verlet integration from backend/src/physics.lisp, including applyGravity, applyConstraints, updatePositions, handleCollisions. Ensure identical logic for determinism. Use modern JS (ES6+) for performance.",
        "testStrategy": "Unit tests comparing JS physics outputs to Lisp outputs for same inputs. Performance tests to ensure 60 FPS prediction with 200 objects.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Port applyGravity Function to JavaScript",
            "description": "Port the applyGravity function from the Lisp backend to JavaScript, ensuring identical deterministic logic for applying global gravity to objects.",
            "dependencies": [
              2
            ],
            "details": "In frontend/src/physics.js, implement applyGravity using ES6+ syntax, mirroring the Verlet integration logic from backend/src/physics.lisp. Apply gravity as a constant acceleration to dynamic objects' velocities, ensuring no floating-point discrepancies for determinism across clients.",
            "status": "done",
            "testStrategy": "Unit tests comparing JS applyGravity outputs to Lisp outputs for identical inputs, verifying determinism and performance at 60 FPS with 200 objects."
          },
          {
            "id": 2,
            "title": "Port applyConstraints Function to JavaScript",
            "description": "Port the applyConstraints function from Lisp to JS, handling canvas boundaries with contain/wrap options for deterministic behavior.",
            "dependencies": [
              1
            ],
            "details": "Implement applyConstraints in frontend/src/physics.js using modern JS, replicating the boundary checks from backend/src/physics.lisp. Support contain (bounce) and wrap (teleport) modes for objects exceeding canvas limits, maintaining exact logic for client-side prediction.",
            "status": "done",
            "testStrategy": "Unit tests against Lisp outputs for various boundary scenarios, including performance checks to sustain 60 FPS with object interactions."
          },
          {
            "id": 3,
            "title": "Port updatePositions Function to JavaScript",
            "description": "Port the updatePositions function, which updates object positions based on Verlet integration, ensuring identical calculations.",
            "dependencies": [
              2
            ],
            "details": "Add updatePositions to frontend/src/physics.js, using ES6+ for efficient position updates from previous and current positions plus accelerations. Match the Lisp implementation precisely to preserve determinism in the physics simulation.",
            "status": "done",
            "testStrategy": "Unit tests comparing position updates between JS and Lisp for same inputs, with benchmarks ensuring 60 FPS for 200 objects."
          },
          {
            "id": 4,
            "title": "Port handleCollisions Function to JavaScript",
            "description": "Port the handleCollisions function for simple circle and rectangle collisions, maintaining deterministic resolution.",
            "dependencies": [
              3
            ],
            "details": "Implement handleCollisions in frontend/src/physics.js, replicating collision detection and response logic from backend/src/physics.lisp. Use modern JS for performance, handling overlaps and applying restitution/friction for identical outcomes.",
            "status": "done",
            "testStrategy": "Unit tests verifying collision resolutions match Lisp outputs, plus performance tests to confirm 60 FPS client-side prediction with colliding objects."
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Client-Side Prediction and Reconciliation",
        "description": "Integrate local physics simulation in the frontend for smooth prediction and server reconciliation.",
        "details": "In frontend/src/canvas.js (CanvasManager), in the animation loop (app.ticker.add), call local physics engine to predict states. In frontend/src/websocket.js, handle 'state-snapshot' by passing to CanvasManager for reconciliation: compare server positions, interpolate gently over frames to avoid jitter.",
        "testStrategy": "Visual tests in browser to check smoothness at 60 FPS. Network simulation tests to verify reconciliation corrects divergences without visible artifacts.",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate Prediction in Animation Loop",
            "description": "Modify the frontend animation loop to call the local physics engine for predicting object states ahead of server updates.",
            "dependencies": [],
            "details": "In frontend/src/canvas.js, within the CanvasManager class, update the animation loop (app.ticker.add callback) to invoke the local physics simulation engine to predict future positions and states of dynamic objects based on current inputs and velocities. Ensure the prediction runs at 60 FPS to maintain smoothness.",
            "status": "done",
            "testStrategy": null
          },
          {
            "id": 2,
            "title": "Handle Snapshot Reception",
            "description": "Update the WebSocket handler to receive and process state snapshots from the server.",
            "dependencies": [],
            "details": "In frontend/src/websocket.js, enhance the WebSocket message handler to listen for 'state-snapshot' events. Upon reception, parse the snapshot data (containing object IDs, positions, rotations) and pass it to the CanvasManager for further processing. Ensure efficient parsing to avoid blocking the main thread.",
            "status": "done",
            "testStrategy": null
          },
          {
            "id": 3,
            "title": "Implement Reconciliation Logic",
            "description": "Develop logic to compare predicted states with server snapshots and interpolate smoothly to correct divergences.",
            "dependencies": [
              1,
              2
            ],
            "details": "In frontend/src/canvas.js, within CanvasManager, add a reconciliation method that compares local predicted positions with server-provided positions from snapshots. Implement gentle interpolation over multiple frames (e.g., using linear interpolation or easing functions) to adjust object positions without causing visible jitter. Handle cases of high latency by prioritizing server authority.",
            "status": "done",
            "testStrategy": null
          },
          {
            "id": 4,
            "title": "Test Interpolation Smoothness",
            "description": "Conduct tests to ensure reconciliation interpolation is smooth and artifact-free under various network conditions.",
            "dependencies": [
              3
            ],
            "details": "Perform visual tests in the browser at 60 FPS to observe smoothness during reconciliation. Use network simulation tools (e.g., Chrome DevTools throttling) to test scenarios with latency and packet loss, verifying that divergences are corrected without visible artifacts like teleportation or stuttering. Log frame rates and interpolation times for analysis.",
            "status": "done",
            "testStrategy": "Visual inspection and network simulation to confirm 60 FPS smoothness and absence of jitter during reconciliation."
          }
        ]
      },
      {
        "id": 6,
        "title": "Add Simulation Controls UI",
        "description": "Implement UI controls for Play, Pause, Reset simulation and global settings like gravity and boundary rules.",
        "details": "In frontend/src/main.js and index.html, add buttons to the right-hand sidebar: Play/Pause/Reset. Add sliders/inputs for global gravity (0-10) and boundary rule (contain/wrap). Bind to WebSocket messages to send updates to backend.",
        "testStrategy": "UI tests to verify buttons trigger correct actions. Functional tests to ensure simulation starts/pauses/resets across clients.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add UI Elements for Simulation Controls",
            "description": "Create and integrate buttons for Play, Pause, and Reset, along with sliders for gravity and boundary rules in the right-hand sidebar of index.html.",
            "dependencies": [],
            "details": "In frontend/src/main.js and index.html, add HTML elements for Play/Pause/Reset buttons and input sliders for gravity (range 0-10) and boundary rule (select contain/wrap). Ensure proper styling and positioning in the sidebar for user interaction.",
            "status": "done",
            "testStrategy": "UI tests to verify buttons and sliders are rendered correctly and respond to user inputs without errors."
          },
          {
            "id": 2,
            "title": "Bind UI Controls to WebSocket Events",
            "description": "Implement event handlers for UI controls to send WebSocket messages to the backend for simulation actions and settings updates.",
            "dependencies": [
              1
            ],
            "details": "In frontend/src/main.js, add event listeners for the Play/Pause/Reset buttons and gravity/boundary sliders. On interaction, construct and send WebSocket messages (e.g., 'play', 'pause', 'reset', 'update-gravity', 'update-boundary') to the backend server.",
            "status": "done",
            "testStrategy": "Functional tests to ensure button clicks and slider changes trigger correct WebSocket messages, verified via network logs or mock WebSocket."
          },
          {
            "id": 3,
            "title": "Implement Backend Handling for Global Settings",
            "description": "Update the backend to receive and process WebSocket messages for simulation controls and apply global settings like gravity and boundary rules.",
            "dependencies": [
              2
            ],
            "details": "In backend/src/websocket-adapter.lisp, add message handlers for 'play', 'pause', 'reset', 'update-gravity', and 'update-boundary'. Integrate with the simulation loop to start/pause/reset the physics engine and update global variables for gravity and boundary constraints.",
            "status": "done",
            "testStrategy": "Integration tests to verify backend receives messages, updates simulation state correctly, and broadcasts changes to all connected clients."
          }
        ]
      },
      {
        "id": 7,
        "title": "Add Physics Properties UI",
        "description": "Create a UI section in the sidebar for editing selected object's physics properties.",
        "details": "In the right-hand sidebar (frontend/src/main.js), add a 'Physics' section with checkbox for isDynamic, sliders for mass, friction, restitution. On change, send updates via WebSocket to broadcast in real-time.",
        "testStrategy": "UI interaction tests to check property changes update object and sync across clients. Edge case tests for invalid values.",
        "priority": "medium",
        "dependencies": [
          1,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Physics Properties UI Section",
            "description": "Add a new 'Physics' section to the right-hand sidebar in frontend/src/main.js, including a checkbox for isDynamic and sliders for mass, friction, and restitution.",
            "dependencies": [],
            "details": "Locate the sidebar rendering code in frontend/src/main.js. Append a new collapsible or static section titled 'Physics'. Add HTML elements: a checkbox for isDynamic (default false), and range sliders for mass (0-10), friction (0-1), restitution (0-1). Ensure the UI is responsive and integrates with the existing sidebar layout. Bind initial values from the selected object's properties.",
            "status": "done",
            "testStrategy": "Manual UI tests to verify elements render correctly and sliders have proper ranges."
          },
          {
            "id": 2,
            "title": "Bind UI Changes to WebSocket Updates and Ensure Synchronization",
            "description": "Implement event handlers for the physics UI controls to send property updates via WebSocket and ensure real-time broadcasting to all clients.",
            "dependencies": [
              1
            ],
            "details": "In frontend/src/main.js, add event listeners to the checkbox and sliders (e.g., onChange or onInput). On change, construct an update message with the new values and send it via the WebSocket connection in frontend/src/websocket.js. Ensure the message includes the object ID and updated physics properties. Verify that changes are broadcasted in real-time, updating the object state across clients without conflicts.",
            "status": "done",
            "testStrategy": "Integration tests simulating UI interactions and checking WebSocket messages. Cross-client tests to confirm real-time sync and handle edge cases like rapid changes."
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Gravity Source Tool",
        "description": "Add a new tool for placing Gravity Sources that exert radial forces.",
        "details": "In frontend/src/canvas.js, add createGravitySource method for visualization (e.g., a circle with radius). Update toolbar in index.html to include 'Gravity' tool. Properties: strength, radius. Backend must handle placement and physics application.",
        "testStrategy": "Functional tests to place Gravity Source and verify forces on dynamic objects. Multi-user tests to ensure collaborative placement.",
        "priority": "medium",
        "dependencies": [
          2,
          5
        ],
        "status": "deferred",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Gravity Source Visualization",
            "description": "Implement the createGravitySource method in frontend/src/canvas.js to render a circle representing the Gravity Source with adjustable radius.",
            "dependencies": [],
            "details": "In the CanvasManager class, add a new method createGravitySource that draws a circle on the canvas with a specified radius. Ensure it integrates with the existing rendering loop and supports properties like strength and radius for visual feedback.",
            "status": "pending",
            "testStrategy": "Visual tests to confirm the circle appears correctly on the canvas with varying radii."
          },
          {
            "id": 2,
            "title": "Integrate Gravity Tool in Toolbar",
            "description": "Update the toolbar in index.html to include a new 'Gravity' tool button for selecting and placing Gravity Sources.",
            "dependencies": [
              1
            ],
            "details": "Modify the HTML structure in index.html to add a button for the Gravity tool. Attach event listeners to switch the active tool mode in the canvas manager, allowing users to place Gravity Sources by clicking on the canvas.",
            "status": "pending",
            "testStrategy": "UI tests to verify the button is clickable and switches the tool mode appropriately."
          },
          {
            "id": 3,
            "title": "Implement Backend Physics and Multi-User Handling",
            "description": "Extend the backend physics engine to apply radial forces from Gravity Sources and ensure collaborative placement works in multi-user scenarios.",
            "dependencies": [
              2
            ],
            "details": "In backend/src/physics.lisp, add logic to calculate and apply radial forces based on Gravity Source properties (strength, radius). Integrate with the simulation loop to update object positions. Handle placement via WebSocket messages and test for synchronization in multi-user environments.",
            "status": "pending",
            "testStrategy": "Functional tests for force application on dynamic objects and multi-user tests to ensure Gravity Sources are placed and forces applied consistently across clients."
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Particle Emitter Tool",
        "description": "Add a tool for placing Particle Emitters that generate dynamic particles.",
        "details": "In frontend/src/canvas.js, add createEmitter method for visualization. Toolbar update for 'Emitter' tool. Properties: rate, lifespan, initialVelocity, particleSize. Backend to simulate emission in physics loop.",
        "testStrategy": "Tests to verify particles are emitted at correct rate, with proper lifespan and velocity. Performance tests with high emission rates.",
        "priority": "medium",
        "dependencies": [
          2,
          5
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Particle Emitter Tool to Toolbar and Implement Visualization",
            "description": "Update the toolbar in index.html to include the 'Emitter' tool and add the createEmitter method in frontend/src/canvas.js for visualizing particle emitters as dynamic objects with properties like rate, lifespan, initialVelocity, and particleSize.",
            "dependencies": [],
            "details": "Modify the toolbar UI in index.html to add a new button or option for the 'Emitter' tool. In frontend/src/canvas.js, implement the createEmitter method to render emitters on the canvas, possibly as a visual indicator (e.g., a small icon or shape) that can be placed by users. Ensure the visualization integrates with the existing canvas drawing logic and supports the specified properties for display purposes.",
            "status": "done",
            "testStrategy": "Manual UI tests to verify the toolbar includes the new 'Emitter' tool and that placing an emitter renders correctly on the canvas without errors."
          },
          {
            "id": 2,
            "title": "Implement Emission Logic in Physics Loop",
            "description": "Extend the backend physics engine to simulate particle emission from emitters, including generating particles with specified rate, lifespan, initialVelocity, and particleSize during the physics loop.",
            "dependencies": [
              1
            ],
            "details": "In the backend physics module (likely backend/src/physics.lisp), add logic to the simulation loop to handle emitters: on each tick, check active emitters and emit particles based on the rate property. Each particle should have a lifespan timer, initial velocity, and size. Integrate this with the existing Verlet integration for position updates and ensure particles are treated as dynamic objects in the simulation. Update the state broadcasting to include particle states.",
            "status": "done",
            "testStrategy": "Unit tests for emission logic with mock emitters to verify particles are created at the correct rate, have proper initial velocities, and are removed after lifespan expires. Integration tests to ensure particles interact correctly with other physics objects."
          },
          {
            "id": 3,
            "title": "Conduct Performance Testing for High Emission Rates",
            "description": "Test the system's performance when particle emitters operate at high rates to ensure smooth simulation and avoid frame drops or server overload.",
            "dependencies": [
              2
            ],
            "details": "Set up performance benchmarks simulating high emission rates (e.g., 100+ particles per second from multiple emitters). Monitor CPU usage, frame rates, and memory consumption in both frontend and backend. Use tools like browser dev tools for client-side and profiling in Lisp for server-side. Optimize if necessary, such as limiting total particles or implementing culling for off-screen particles.",
            "status": "pending",
            "testStrategy": "Automated performance tests using load simulation tools to emit particles at high rates and measure FPS, latency, and resource usage. Compare against thresholds (e.g., maintain 50Hz simulation and 60 FPS rendering) and log any bottlenecks for optimization."
          }
        ]
      },
      {
        "id": 10,
        "title": "Update AI Agent with New Tools",
        "description": "Extend the AI agent to support new function-calling tools for physics manipulation.",
        "details": "In backend/src/ai-agent.lisp, update *component-tools* with schemas for setObjectPhysics, setGlobalPhysics, createGravitySource, createEmitter. Modify execute-ai-command to dispatch these, updating canvas state accordingly.",
        "testStrategy": "AI command tests with examples like 'Make all red circles bouncy' to verify tool calls execute correctly and affect simulation.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          8,
          9
        ],
        "status": "deferred",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Schemas for New Physics Tools",
            "description": "Create JSON schemas for the new function-calling tools: setObjectPhysics, setGlobalPhysics, createGravitySource, and createEmitter in the AI agent.",
            "dependencies": [
              1,
              2,
              8,
              9
            ],
            "details": "In backend/src/ai-agent.lisp, update the *component-tools* list with detailed schemas including parameters and descriptions for each tool, ensuring they align with the physics properties and engine implemented in tasks 1 and 2.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 2,
            "title": "Modify execute-ai-command to Dispatch New Tools",
            "description": "Update the execute-ai-command function to handle calls to the new physics tools and update the canvas state accordingly.",
            "dependencies": [
              1,
              2,
              8,
              9,
              1
            ],
            "details": "In backend/src/ai-agent.lisp, modify execute-ai-command to parse tool calls for setObjectPhysics, setGlobalPhysics, createGravitySource, and createEmitter, executing the appropriate actions such as setting object properties, global physics, creating gravity sources or emitters, and ensuring the canvas state is updated and broadcasted.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 3,
            "title": "Implement and Run Tests for AI Command Execution",
            "description": "Develop and execute tests to verify that AI commands trigger the correct tool calls and produce expected physics effects in the simulation.",
            "dependencies": [
              1,
              2,
              8,
              9,
              2
            ],
            "details": "Create test cases in the backend testing framework, including examples like 'Make all red circles bouncy', to check that the AI agent correctly dispatches to the new tools, updates the canvas state, and the physics simulation reflects the changes accurately.",
            "status": "pending",
            "testStrategy": "AI command tests with natural language inputs to verify tool calls, state updates, and simulation impacts."
          }
        ]
      },
      {
        "id": 11,
        "title": "Investigate and Implement Binary Protocol for Snapshots",
        "description": "As a stretch goal, switch to MessagePack for efficient state snapshot serialization.",
        "details": "Research MessagePack library for Lisp and JS. Update backend/src/websocket-adapter.lisp to serialize snapshots in binary. Frontend/src/websocket.js to decode. Ensure WebSocket handles binary frames.",
        "testStrategy": "Bandwidth tests comparing JSON vs MessagePack payload sizes. Compatibility tests across browsers and ensure no data loss.",
        "priority": "low",
        "dependencies": [
          3,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Research MessagePack Libraries for Lisp and JavaScript",
            "description": "Investigate and select suitable MessagePack libraries for binary serialization in Lisp (backend) and JavaScript (frontend) to replace JSON for state snapshots.",
            "dependencies": [],
            "details": "Research libraries such as cl-messagepack for Common Lisp and msgpack-lite or similar for JavaScript. Ensure compatibility with WebSocket binary frames and verify features like efficient encoding/decoding of complex data structures used in snapshots.",
            "status": "pending",
            "testStrategy": "Test basic serialization and deserialization with sample snapshot data to confirm library functionality."
          },
          {
            "id": 2,
            "title": "Implement Binary Serialization in Backend and Decoding in Frontend",
            "description": "Update the backend to serialize snapshots using MessagePack and modify the frontend to decode them, ensuring WebSocket handles binary data.",
            "dependencies": [
              1
            ],
            "details": "In backend/src/websocket-adapter.lisp, integrate the chosen MessagePack library to serialize state snapshots into binary format. In frontend/src/websocket.js, add decoding logic to parse incoming binary frames. Verify WebSocket configuration supports binary messages and handle any necessary type conversions.",
            "status": "pending",
            "testStrategy": "Conduct bandwidth tests comparing JSON vs MessagePack payload sizes under various snapshot complexities. Perform compatibility tests across different browsers to ensure no data loss and proper decoding."
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement Default Object Behaviors",
        "description": "Set default physics behaviors: circles are dynamic by default (isDynamic=true), rectangles are always static (isDynamic=false, cannot be changed). Ensure UI and backend enforce these defaults.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Particle Lifecycle Management",
        "description": "Add particle cleanup: auto-despawn particles after lifespan expires, cap total particles at 300-500, remove oldest particles when limit reached. Track particle age in emitter system.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          9
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Physics-Canvas State Synchronization",
        "description": "Sync canvas state with physics engine: load existing canvas objects into physics on startup, sync user-created objects to physics, handle user drag by manually overriding physics positions. Ensure bidirectional sync.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          2,
          3
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-10-17T15:15:55.037Z",
      "updated": "2025-10-17T16:09:11.051Z",
      "description": "Tasks for physics context"
    }
  }
}