{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up project structure and dependencies",
        "description": "Initialize the backend and frontend project structures, install required libraries and tools as specified in the technical stack.",
        "details": "For backend: Use Roswell to set up SBCL Common Lisp project with ASDF system definition. Install Hunchentoot, Hunchensocket, cl-sqlite, Jonathan, Ironclad, Bordeaux-threads via Quicklisp. For frontend: Initialize Vite project with PixiJS v7, vanilla JavaScript ES6+. Create directory structures as per architecture (backend/src/, frontend/src/). Ensure Docker setup with Debian base.",
        "testStrategy": "Verify backend loads in REPL with (ql:quickload :collabcanvas). Check frontend builds with npm run build. Confirm all dependencies are installed without errors.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize backend project structure with Roswell and SBCL",
            "description": "Set up the Common Lisp project using Roswell to initialize SBCL with ASDF system definition and create the backend/src/ directory structure.",
            "dependencies": [],
            "details": "Use Roswell to create a new SBCL project named 'collabcanvas' with ASDF system definition. Ensure the project structure includes backend/src/ for source files. Verify that the ASDF system loads correctly in the REPL.",
            "status": "done",
            "testStrategy": "Load the project in SBCL REPL and check that the ASDF system is defined without errors.",
            "updatedAt": "2025-10-13T21:24:51.583Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Install backend dependencies via Quicklisp",
            "description": "Install the required Common Lisp libraries including Hunchentoot, Hunchensocket, cl-sqlite, Jonathan, Ironclad, and Bordeaux-threads using Quicklisp.",
            "dependencies": [
              1
            ],
            "details": "After setting up the backend project, use Quicklisp to install Hunchentoot for web server, Hunchensocket for WebSockets, cl-sqlite for database, Jonathan for JSON handling, Ironclad for cryptography, and Bordeaux-threads for threading. Ensure all packages are available and loadable.",
            "status": "done",
            "testStrategy": "Run (ql:quickload :collabcanvas) in the REPL and confirm all dependencies load without errors.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:24:52.880Z"
          },
          {
            "id": 3,
            "title": "Initialize frontend project with Vite and PixiJS",
            "description": "Set up the frontend project using Vite for build tooling and initialize with PixiJS v7 and vanilla JavaScript ES6+, creating the frontend/src/ directory.",
            "dependencies": [],
            "details": "Use npm or yarn to initialize a Vite project in the frontend directory. Install PixiJS v7 as a dependency. Create the frontend/src/ structure for source files. Configure Vite for vanilla JS ES6+ development.",
            "status": "done",
            "testStrategy": "Run npm run build in the frontend directory and verify that the build completes successfully with PixiJS integrated.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:24:54.220Z"
          },
          {
            "id": 4,
            "title": "Install frontend dependencies",
            "description": "Ensure all frontend dependencies are installed, focusing on PixiJS v7 and any additional tools required for the project.",
            "dependencies": [
              3
            ],
            "details": "After initializing the Vite project, install PixiJS v7 and confirm that the package.json includes all necessary dependencies for vanilla JS ES6+ development. Check for any peer dependencies and resolve them.",
            "status": "done",
            "testStrategy": "Check that npm install completes without errors and that PixiJS can be imported in a test JS file.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:24:55.568Z"
          },
          {
            "id": 5,
            "title": "Set up Docker environment with Debian base",
            "description": "Create a Docker setup using Debian base image to containerize the project, ensuring both backend and frontend can run within the container.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Write a Dockerfile with Debian base image. Include instructions to install SBCL, Roswell, Node.js, and other necessary tools. Copy project files and set up commands to run the backend and frontend. Ensure the container can build and run the application.",
            "status": "done",
            "testStrategy": "Build the Docker image and run the container, verifying that both backend and frontend start without errors.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:24:56.916Z"
          }
        ],
        "updatedAt": "2025-10-13T21:24:56.916Z"
      },
      {
        "id": 2,
        "title": "Implement database schema and setup",
        "description": "Create and initialize the SQLite database with the required tables for users, sessions, and canvas states.",
        "details": "Use cl-sqlite to execute the schema.sql file creating users, sessions, and canvas_states tables. Include indexes for performance. Ensure database file is created in data/ directory. Implement utility functions in database.lisp for connecting and executing queries.",
        "testStrategy": "Run SQLite commands to verify tables exist and constraints are enforced. Insert test data and query to confirm integrity.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create schema.sql file with table definitions",
            "description": "Define the SQL schema for users, sessions, and canvas_states tables including columns, data types, and constraints.",
            "dependencies": [],
            "details": "Write a schema.sql file that includes CREATE TABLE statements for users (id, email, username, password_hash), sessions (id, user_id, session_id, expires_at), and canvas_states (id, session_id, state_json). Add PRIMARY KEY and UNIQUE constraints, and indexes for performance on frequently queried columns like email and session_id.",
            "status": "pending",
            "testStrategy": "Validate the SQL syntax by attempting to execute it in a SQLite environment and check for errors.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement database connection utility",
            "description": "Create functions in database.lisp to establish a connection to the SQLite database.",
            "dependencies": [
              1
            ],
            "details": "In database.lisp, define a function to connect to the SQLite database file located in the data/ directory, using cl-sqlite. Ensure the connection is reusable and handle any connection errors gracefully.",
            "status": "pending",
            "testStrategy": "Call the connection function and verify that the database file is created in data/ if it doesn't exist, and that subsequent calls reuse the connection.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Execute schema.sql to initialize database",
            "description": "Run the schema.sql file to create the tables and indexes in the database.",
            "dependencies": [
              2
            ],
            "details": "Implement a function in database.lisp that reads and executes the schema.sql file using the established database connection. Ensure all tables are created with their indexes and constraints.",
            "status": "pending",
            "testStrategy": "After execution, query the database to confirm that tables users, sessions, and canvas_states exist with the correct columns and indexes.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement query execution utilities",
            "description": "Add functions for executing SQL queries and statements in database.lisp.",
            "dependencies": [
              3
            ],
            "details": "Define utility functions for executing SELECT, INSERT, UPDATE, and DELETE queries, handling parameters securely to prevent SQL injection. Include functions for fetching results and handling transactions.",
            "status": "pending",
            "testStrategy": "Write and execute test queries to insert sample data into the tables and retrieve it, verifying that the utilities work correctly and data integrity is maintained.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Verify database setup and file location",
            "description": "Ensure the database file is correctly placed and the setup is complete.",
            "dependencies": [
              4
            ],
            "details": "Check that the SQLite database file is created in the data/ directory. Run a final verification to ensure all tables, indexes, and constraints are properly set up and functional.",
            "status": "pending",
            "testStrategy": "Use SQLite commands to inspect the database file, confirm table structures, and perform basic operations to ensure everything is working as expected.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-13T21:24:58.407Z"
      },
      {
        "id": 3,
        "title": "Implement authentication backend",
        "description": "Develop the authentication system including user registration, login, logout, and session management using SHA-256 hashing.",
        "details": "In auth.lisp, implement functions for hashing passwords with Ironclad, creating sessions, validating logins. Add HTTP endpoints /api/register, /api/login, /api/logout using Hunchentoot. Store sessions in SQLite with 24-hour expiry. Handle unique constraints for email and username.",
        "testStrategy": "Use curl to test registration, login, and logout endpoints. Verify session persistence and expiry. Check database for correct data insertion.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up database schema for users and sessions",
            "description": "Create SQLite tables for users (with email, username, hashed password) and sessions (with session ID, user ID, expiry timestamp). Ensure unique constraints on email and username.",
            "dependencies": [],
            "details": "In the database setup, define a 'users' table with columns: id (primary key), email (unique), username (unique), password_hash (text). Define a 'sessions' table with columns: id (primary key), user_id (foreign key to users), session_id (unique), created_at (timestamp), expires_at (timestamp). Use SQLite pragmas for foreign keys.\n<info added on 2025-10-13T20:19:17.572Z>\nInstead of creating new tables, this subtask should confirm that Task 2 successfully created the users and sessions tables with the correct columns and constraints. Query the SQLite database schema using PRAGMA table_info or similar to validate the structure: users table with id (primary key), email (unique), username (unique), password_hash (text); sessions table with id (primary key), user_id (foreign key to users), session_id (unique), created_at (timestamp), expires_at (timestamp). Ensure foreign key constraints are enabled and unique constraints are in place on email and username. Raise errors if the schema does not match expectations.\n</info added on 2025-10-13T20:19:17.572Z>",
            "status": "pending",
            "testStrategy": "Verify table creation by querying the database schema and inserting test data to confirm unique constraints.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement password hashing function",
            "description": "Develop a function to hash passwords using SHA-256 with Ironclad library.",
            "dependencies": [
              1
            ],
            "details": "In auth.lisp, define a function hash-password that takes a plain password string, uses Ironclad to compute SHA-256 hash, and returns the hex-encoded string. Ensure it handles UTF-8 encoding properly.",
            "status": "pending",
            "testStrategy": "Unit test the function with known inputs and verify outputs match expected SHA-256 hashes.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement user registration endpoint",
            "description": "Create the /api/register HTTP endpoint to handle user registration with email, username, and password.",
            "dependencies": [
              1,
              2
            ],
            "details": "Using Hunchentoot, add a POST handler for /api/register that parses JSON body for email, username, password. Validate inputs, hash password, insert into users table, handle unique constraint violations by returning appropriate error responses.",
            "status": "pending",
            "testStrategy": "Use curl to send POST requests with valid and invalid data, check for successful registration and error messages for duplicates.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement login endpoint with session creation",
            "description": "Create the /api/login HTTP endpoint to validate credentials and create a session.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Add a POST handler for /api/login that takes email/username and password. Query user by email or username, verify password hash, generate a unique session ID, insert into sessions table with 24-hour expiry, return session ID in response.",
            "status": "pending",
            "testStrategy": "Test login with correct and incorrect credentials using curl, verify session creation in database and response contains session ID.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement logout endpoint and session management",
            "description": "Create the /api/logout HTTP endpoint to invalidate sessions.",
            "dependencies": [
              4
            ],
            "details": "Add a POST handler for /api/logout that takes session ID, deletes the session from the database. Optionally, implement session validation middleware for protected endpoints to check expiry.",
            "status": "pending",
            "testStrategy": "Login to get a session, call logout, verify session is removed from database, and test that expired sessions are invalidated.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-13T21:24:59.652Z"
      },
      {
        "id": 4,
        "title": "Implement authentication frontend",
        "description": "Create the login/register modal UI and logic for handling authentication on the client side.",
        "details": "In auth.js, build modal with tabs for login/register, fields for email, password, username. Use fetch API to call backend endpoints. Store sessionId in localStorage. Block canvas access until authenticated. Handle errors and display messages.",
        "testStrategy": "Open app, attempt registration and login. Verify modal blocks canvas, session persists on refresh. Test invalid credentials error handling.",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create modal UI structure with tabs",
            "description": "Build the basic HTML structure for the authentication modal including tabs for login and register.",
            "dependencies": [],
            "details": "In auth.js, create a modal element with two tabs: one for login and one for register. Use CSS to style the modal as an overlay that appears when authentication is required. Ensure the modal is hidden by default and can be toggled.",
            "status": "done",
            "testStrategy": "Open the app and verify the modal appears with login and register tabs visible.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:27:24.151Z"
          },
          {
            "id": 2,
            "title": "Add form fields for login and register",
            "description": "Implement input fields for email, password, and username in the respective tabs.",
            "dependencies": [
              1
            ],
            "details": "In the login tab, add fields for email and password. In the register tab, add fields for email, password, and username. Include submit buttons for each form. Validate that required fields are filled before submission.",
            "status": "done",
            "testStrategy": "Switch between tabs and confirm fields are present and functional.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:10.289Z"
          },
          {
            "id": 3,
            "title": "Implement fetch API calls to backend endpoints",
            "description": "Set up logic to send POST requests to /api/login and /api/register using fetch API.",
            "dependencies": [
              2
            ],
            "details": "On form submission, collect form data and use fetch to call the appropriate backend endpoint. Handle the response asynchronously. Prepare for storing sessionId on success.",
            "status": "done",
            "testStrategy": "Submit forms with valid data and check network requests in browser dev tools.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:11.618Z"
          },
          {
            "id": 4,
            "title": "Handle authentication success and session storage",
            "description": "Process successful login/register responses by storing sessionId and unblocking canvas access.",
            "dependencies": [
              3
            ],
            "details": "Upon successful response, store the sessionId in localStorage. Hide the modal and allow access to the canvas. Check for existing sessionId on app load to skip modal if already authenticated.",
            "status": "done",
            "testStrategy": "Register and login, then refresh the page to verify session persists and canvas is accessible.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:12.950Z"
          },
          {
            "id": 5,
            "title": "Implement error handling and message display",
            "description": "Add logic to display error messages for failed authentication attempts.",
            "dependencies": [
              3
            ],
            "details": "On failed responses, parse error messages from the backend and display them in the modal. Clear messages on successful attempts. Ensure the modal remains open on errors.",
            "status": "done",
            "testStrategy": "Attempt login/register with invalid credentials and verify error messages appear.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:14.350Z"
          }
        ],
        "updatedAt": "2025-10-13T21:28:14.350Z"
      },
      {
        "id": 5,
        "title": "Set up WebSocket server infrastructure",
        "description": "Establish the WebSocket server with room management for canvas collaboration.",
        "details": "In websocket.lisp, create canvas-room class with thread-safe client lists. Implement connection handling, message routing for auth, cursor, object operations. Use Hunchensocket for WebSocket acceptor. Add functions for broadcasting messages to room members.",
        "testStrategy": "Start server and connect via browser console WebSocket. Send test messages and verify routing and broadcasting. Check room creation and client addition/removal.",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Hunchensocket WebSocket acceptor",
            "description": "Initialize the WebSocket server using Hunchensocket library in websocket.lisp.",
            "dependencies": [],
            "details": "Configure Hunchensocket to create a WebSocket acceptor that listens on a specified port, handling the basic setup for WebSocket connections.",
            "status": "pending",
            "testStrategy": "Start the server and verify that it listens on the port without errors, using a simple connection test.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create canvas-room class with thread-safe client lists",
            "description": "Define the canvas-room class to manage rooms for canvas collaboration.",
            "dependencies": [
              1
            ],
            "details": "In websocket.lisp, implement a canvas-room class that includes thread-safe lists for managing connected clients, ensuring safe concurrent access.",
            "status": "pending",
            "testStrategy": "Instantiate the class and perform basic operations like adding/removing clients in a multi-threaded environment to check for race conditions.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement WebSocket connection handling",
            "description": "Handle client connections and disconnections for the WebSocket server.",
            "dependencies": [
              2
            ],
            "details": "Add logic to accept incoming WebSocket connections, associate them with canvas rooms, and manage client addition/removal from room lists upon connect/disconnect.",
            "status": "pending",
            "testStrategy": "Connect multiple clients via browser console and verify they are added to the room; disconnect and check removal.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement message routing for auth, cursor, and object operations",
            "description": "Set up routing for different types of WebSocket messages.",
            "dependencies": [
              3
            ],
            "details": "In websocket.lisp, create handlers for message types including authentication, cursor updates, and object operations, parsing incoming messages and dispatching to appropriate functions.",
            "status": "pending",
            "testStrategy": "Send test messages of each type from a client and verify they are routed correctly, logging the handling process.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add broadcasting functions for room members",
            "description": "Implement functions to broadcast messages to all clients in a room.",
            "dependencies": [
              4
            ],
            "details": "Create utility functions in websocket.lisp that iterate over the thread-safe client lists in a canvas-room and send messages to all connected members.",
            "status": "pending",
            "testStrategy": "Connect multiple clients to a room, send a broadcast message, and verify all clients receive it via console logs.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-13T21:25:01.037Z"
      },
      {
        "id": 6,
        "title": "Implement canvas rendering with PixiJS",
        "description": "Set up the PixiJS application for the infinite canvas with basic rendering.",
        "details": "In canvas.js, initialize PIXI.Application with full viewport. Create Container for world space. Implement grid rendering at 50px intervals. Set up event listeners for mouse interactions. Define screenToWorld and worldToScreen conversion functions.",
        "testStrategy": "Load canvas, verify PixiJS renders grid correctly. Check coordinate conversions with console logs. Ensure canvas fills viewport without scrollbars.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize PIXI.Application with full viewport",
            "description": "Set up the PIXI.Application instance to fill the entire viewport without scrollbars.",
            "dependencies": [],
            "details": "In canvas.js, create a new PIXI.Application with options for width and height set to window.innerWidth and window.innerHeight, and append its view to the document body. Ensure it resizes dynamically with window resize events.",
            "status": "pending",
            "testStrategy": "Load the canvas and verify that PixiJS application renders and fills the viewport completely without any scrollbars appearing.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Container for world space",
            "description": "Establish a PIXI.Container to represent the infinite world space for objects.",
            "dependencies": [
              1
            ],
            "details": "After initializing the PIXI.Application, create a new PIXI.Container instance and add it to the application's stage. This container will hold all world-space objects and transformations.",
            "status": "pending",
            "testStrategy": "Check that the container is added to the stage and can hold child objects by adding a test sprite and confirming it renders.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement grid rendering at 50px intervals",
            "description": "Render a visual grid on the canvas to aid in object placement and navigation.",
            "dependencies": [
              2
            ],
            "details": "In the world container, create PIXI.Graphics to draw horizontal and vertical lines at 50px intervals in world coordinates. Update the grid rendering on zoom and pan events to maintain visibility.",
            "status": "pending",
            "testStrategy": "Zoom and pan the canvas, verify the grid lines appear at correct 50px intervals and adjust dynamically with transformations.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Set up event listeners for mouse interactions",
            "description": "Add mouse event handlers for basic interactions like clicking and dragging.",
            "dependencies": [
              1
            ],
            "details": "Attach event listeners to the PIXI.Application view for 'mousedown', 'mousemove', and 'mouseup' events. Store mouse positions and states to handle interactions such as panning or selecting.",
            "status": "pending",
            "testStrategy": "Click and drag on the canvas, use console logs to verify that mouse events are captured and positions are recorded accurately.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Define screenToWorld and worldToScreen conversion functions",
            "description": "Implement utility functions to convert between screen and world coordinates.",
            "dependencies": [
              2
            ],
            "details": "Create functions screenToWorld(x, y) and worldToScreen(x, y) that account for the world container's position, scale, and rotation. Use these for accurate object placement and interaction in world space.",
            "status": "pending",
            "testStrategy": "Use console logs to test coordinate conversions by logging screen positions and their world equivalents, ensuring accuracy during zoom and pan.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-13T21:25:02.354Z"
      },
      {
        "id": 7,
        "title": "Implement pan and zoom functionality",
        "description": "Add pan and zoom controls to the canvas for navigation.",
        "details": "In canvas.js, handle middle-click or Alt+left-click drag for pan. Implement mouse wheel zoom with cursor centering, range 0.1x to 10x. Update viewport tracking. Ensure 60 FPS performance using requestAnimationFrame.",
        "testStrategy": "Test pan with middle-click and Alt+drag, verify smooth movement. Zoom in/out with wheel, check cursor centering and FPS via DevTools. Confirm no frame drops with rapid interactions.",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up event listeners for pan and zoom",
            "description": "Initialize event listeners in canvas.js for mouse events to handle pan and zoom interactions.",
            "dependencies": [],
            "details": "Add event listeners for mousedown, mousemove, mouseup, and wheel events on the canvas element. Track mouse state variables like isPanning, lastMouseX, lastMouseY, and zoomLevel. Ensure listeners are attached when the canvas is initialized.",
            "status": "done",
            "testStrategy": "Verify that event listeners are attached by checking console logs on mouse interactions.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:27:39.201Z"
          },
          {
            "id": 2,
            "title": "Implement pan functionality",
            "description": "Handle middle-click or Alt+left-click drag to pan the canvas view.",
            "dependencies": [
              1
            ],
            "details": "In the mousedown event, check for middle button or Alt+left-click to set isPanning to true and record initial mouse position. In mousemove, if isPanning, calculate delta movement and update the viewport offset. Reset on mouseup. Prevent default drag behavior.",
            "status": "done",
            "testStrategy": "Test middle-click drag and Alt+left-click drag to ensure the canvas pans smoothly without selecting text or other elements.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:15.758Z"
          },
          {
            "id": 3,
            "title": "Implement zoom functionality",
            "description": "Add mouse wheel zoom with cursor centering and enforce zoom range from 0.1x to 10x.",
            "dependencies": [
              1
            ],
            "details": "In the wheel event, calculate zoom factor based on deltaY, clamp between 0.1 and 10. Adjust zoom level and recompute viewport to center on cursor position. Use transform or scale on the canvas rendering context. Update zoomLevel variable.",
            "status": "done",
            "testStrategy": "Scroll mouse wheel in and out, check that zoom scales from 0.1x to 10x and centers on cursor. Verify zoom stops at limits.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:17.092Z"
          },
          {
            "id": 4,
            "title": "Update viewport tracking",
            "description": "Maintain and update viewport properties like offset and zoom level for accurate rendering.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create a viewport object with properties: offsetX, offsetY, zoom. Update these in pan and zoom handlers. Use these to transform world coordinates to screen coordinates in rendering functions. Ensure viewport is reset or initialized properly.",
            "status": "done",
            "testStrategy": "After pan and zoom, inspect viewport values and confirm they match expected changes based on mouse movements.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:18.386Z"
          },
          {
            "id": 5,
            "title": "Optimize for 60 FPS performance",
            "description": "Ensure smooth performance using requestAnimationFrame for updates.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Wrap pan and zoom updates in requestAnimationFrame to limit to 60 FPS. Debounce rapid events if necessary. Profile with DevTools to confirm no frame drops during interactions. Optimize rendering by only updating changed parts if possible.",
            "status": "done",
            "testStrategy": "Use DevTools Performance tab to record interactions, verify frame rate stays at 60 FPS with no drops during rapid pan and zoom.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:20.031Z"
          }
        ],
        "updatedAt": "2025-10-13T21:28:20.031Z"
      },
      {
        "id": 8,
        "title": "Implement object creation",
        "description": "Enable creation of rectangles and circles on the canvas via click-and-drag.",
        "details": "In canvas.js, add tool modes for rectangle ('R') and circle ('C'). On mouse down, start creation; on mouse up, finalize object with properties (id, type, x, y, width/height/radius, color). Use PIXI.Graphics for rendering. Generate unique IDs.",
        "testStrategy": "Switch to rectangle tool, click-drag to create. Repeat for circle. Verify objects appear with correct properties. Check keyboard shortcuts switch modes.",
        "priority": "high",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add tool modes for rectangle and circle creation",
            "description": "Implement tool modes in canvas.js to switch between rectangle ('R') and circle ('C') creation modes using keyboard shortcuts.",
            "dependencies": [],
            "details": "Modify the canvas.js file to include a mode variable that can be set to 'rectangle' or 'circle' based on key presses 'R' and 'C'. Ensure the mode affects the creation behavior.",
            "status": "pending",
            "testStrategy": "Press 'R' and 'C' keys and verify the mode changes via console logs or UI indicators.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Handle mouse down event to start object creation",
            "description": "Add event listener for mouse down to initiate the creation of a rectangle or circle based on the current tool mode.",
            "dependencies": [
              1
            ],
            "details": "In canvas.js, attach a mousedown event listener to the canvas. On mousedown, record the starting point (x, y) and create a temporary PIXI.Graphics object for previewing the shape being drawn.",
            "status": "pending",
            "testStrategy": "Switch to rectangle mode, click on canvas, and check if a temporary graphic appears at the click position.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Handle mouse move event to update shape during drag",
            "description": "Implement mouse move event to dynamically update the dimensions of the rectangle or circle as the user drags.",
            "dependencies": [
              2
            ],
            "details": "Add a mousemove event listener that, while dragging, calculates width/height for rectangle or radius for circle based on current mouse position and starting point, then redraws the temporary PIXI.Graphics object.",
            "status": "pending",
            "testStrategy": "Start dragging after mousedown, move mouse, and verify the shape resizes in real-time on the canvas.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Handle mouse up event to finalize object creation",
            "description": "On mouse up, finalize the object by assigning properties and adding it to the canvas permanently.",
            "dependencies": [
              3
            ],
            "details": "In the mouseup event listener, remove the temporary graphic, create a new PIXI.Graphics object with final dimensions, assign properties like id, type, x, y, width/height/radius, color, and add it to the canvas stage.",
            "status": "pending",
            "testStrategy": "Complete a click-drag action, release mouse, and confirm a permanent object appears with correct size and properties.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement unique ID generation for objects",
            "description": "Add functionality to generate unique IDs for each created object to ensure no duplicates.",
            "dependencies": [
              4
            ],
            "details": "Create a function in canvas.js that generates unique IDs, perhaps using a counter or timestamp-based method. Assign this ID to each new object upon finalization in the mouseup handler.",
            "status": "pending",
            "testStrategy": "Create multiple objects and verify each has a unique ID by inspecting object properties or logging them.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-14T02:52:42.112Z"
      },
      {
        "id": 9,
        "title": "Implement object manipulation",
        "description": "Add selection, dragging, multi-select, and deletion for objects.",
        "details": "In canvas.js, implement select mode ('V') for clicking to select, Shift+click for multi-select. Enable dragging selected objects. Add Delete key handler for removal. Update object positions in world coordinates.",
        "testStrategy": "Create objects, select single/multiple, drag to new positions. Verify positions update correctly. Delete selected objects and confirm removal.",
        "priority": "high",
        "dependencies": [
          "8"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement select mode activation",
            "description": "Add keyboard shortcut 'V' to activate select mode in canvas.js.",
            "dependencies": [],
            "details": "Modify canvas.js to listen for the 'V' key press event and set the current tool mode to 'select'. Ensure this mode allows for object selection without creating new objects.",
            "status": "pending",
            "testStrategy": "Press 'V' key and verify select mode is activated, preventing object creation.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement single object selection",
            "description": "Enable clicking on objects to select them in select mode.",
            "dependencies": [
              1
            ],
            "details": "In canvas.js, add mouse click event handler in select mode to detect clicks on objects using PIXI's hit detection. Mark the clicked object as selected and visually indicate selection (e.g., highlight).",
            "status": "pending",
            "testStrategy": "Create an object, enter select mode, click on it, and verify it is selected and highlighted.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement multi-select with Shift+click",
            "description": "Allow selecting multiple objects by holding Shift and clicking.",
            "dependencies": [
              2
            ],
            "details": "Extend the click handler in canvas.js to check for Shift key during click. If Shift is held, add the clicked object to the selection without deselecting others. Maintain a list of selected objects.",
            "status": "pending",
            "testStrategy": "Create multiple objects, select one, then Shift+click another, and verify both are selected.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement dragging of selected objects",
            "description": "Enable dragging selected objects to new positions.",
            "dependencies": [
              3
            ],
            "details": "In canvas.js, add mouse down, move, and up event handlers for dragging. On mouse down on selected objects, initiate drag. Update positions during move and finalize on mouse up, converting screen coordinates to world coordinates.",
            "status": "pending",
            "testStrategy": "Select an object, drag it to a new position, and verify the position updates correctly in world coordinates.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement deletion of selected objects",
            "description": "Add Delete key handler to remove selected objects.",
            "dependencies": [
              3
            ],
            "details": "In canvas.js, add a keydown event listener for the Delete key. When pressed, remove all selected objects from the canvas and update the object list. Ensure positions are handled in world coordinates if needed.",
            "status": "pending",
            "testStrategy": "Select one or more objects, press Delete key, and verify they are removed from the canvas.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-14T02:52:43.333Z"
      },
      {
        "id": 10,
        "title": "Implement WebSocket client",
        "description": "Develop the client-side WebSocket connection and message handling.",
        "details": "In websocket.js, create WebSocketClient class to connect to ws://host/ws/{canvas-id}. Handle auth message on connect. Implement send/receive for cursor, object operations. Add reconnection logic and throttling for cursor updates (30/sec).",
        "testStrategy": "Connect to server, send auth, verify auth-success. Send test object-create message and check server response. Test reconnection after disconnect.",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create WebSocketClient class structure",
            "description": "Set up the basic WebSocketClient class in websocket.js with constructor and initial properties.",
            "dependencies": [],
            "details": "In websocket.js, define a WebSocketClient class with a constructor that takes host, canvasId, and authToken. Initialize properties like ws (WebSocket instance), isConnected (boolean), and message handlers. Ensure the class is exportable for use in other modules.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:27:55.378Z"
          },
          {
            "id": 2,
            "title": "Implement WebSocket connection and authentication",
            "description": "Establish the WebSocket connection to the server and handle the initial authentication message.",
            "dependencies": [
              1
            ],
            "details": "In the WebSocketClient class, add a connect() method that creates a new WebSocket connection to ws://host/ws/{canvas-id}. On connection open, send an auth message with the authToken. Listen for auth-success or auth-failure responses and handle accordingly, updating connection status.",
            "status": "done",
            "testStrategy": "Connect to a test server, verify WebSocket opens, send auth message, and check for auth-success response.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:21.428Z"
          },
          {
            "id": 3,
            "title": "Implement message sending and receiving for cursor and object operations",
            "description": "Add methods to send and receive messages for cursor updates and object manipulations.",
            "dependencies": [
              2
            ],
            "details": "In the WebSocketClient class, implement sendMessage() method to send JSON messages for cursor positions and object operations (create, update, delete). Add onMessage handler to parse incoming messages and dispatch to appropriate handlers for cursor updates and object changes. Ensure messages are properly formatted as JSON.",
            "status": "done",
            "testStrategy": "Send a test cursor update message and verify it's received. Send an object-create message and check the response.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:22.890Z"
          },
          {
            "id": 4,
            "title": "Add reconnection logic",
            "description": "Implement automatic reconnection when the WebSocket connection is lost.",
            "dependencies": [
              2
            ],
            "details": "In the WebSocketClient class, add an onClose handler that attempts to reconnect after a delay (e.g., exponential backoff). Track reconnection attempts and stop after a maximum number. Re-authenticate upon successful reconnection. Provide a method to manually disconnect.",
            "status": "done",
            "testStrategy": "Disconnect the WebSocket manually, verify automatic reconnection occurs, and auth is re-sent.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:24.212Z"
          },
          {
            "id": 5,
            "title": "Implement throttling for cursor updates",
            "description": "Add throttling to limit cursor update messages to 30 per second.",
            "dependencies": [
              3
            ],
            "details": "In the WebSocketClient class, implement a throttling mechanism using a timer or library to ensure cursor position updates are sent at most 30 times per second. Buffer or drop excess updates. Integrate this into the cursor sending logic to prevent flooding the server.",
            "status": "done",
            "testStrategy": "Simulate rapid cursor movements and verify that no more than 30 updates are sent per second.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:25.505Z"
          }
        ],
        "updatedAt": "2025-10-13T21:28:25.505Z"
      },
      {
        "id": 11,
        "title": "Implement real-time synchronization for objects",
        "description": "Sync object creation, updates, and deletions across all connected clients.",
        "details": "Integrate WebSocketClient with CanvasManager: on local object create/update/delete, send message. On receive, update canvas. Broadcast via server. Use last-write-wins for conflicts.",
        "testStrategy": "Open two browser windows, create/update/delete objects in one, verify immediate sync in the other. Check latency <100ms with network tools.",
        "priority": "high",
        "dependencies": [
          "9",
          "10"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate WebSocketClient for sending object change messages",
            "description": "Modify CanvasManager to send WebSocket messages whenever an object is created, updated, or deleted locally.",
            "dependencies": [],
            "details": "In CanvasManager, hook into object creation, update, and deletion events to serialize the object data (id, type, position, etc.) into a JSON message and send it via WebSocketClient to the server.",
            "status": "pending",
            "testStrategy": "Use browser console to verify messages are sent on object actions, check network tab for WebSocket frames.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement handling of incoming WebSocket messages for canvas updates",
            "description": "Update CanvasManager to listen for incoming WebSocket messages and apply the received object changes to the canvas.",
            "dependencies": [
              1
            ],
            "details": "Add a WebSocket message handler in CanvasManager that parses incoming JSON messages for object create, update, or delete operations, and updates the local canvas state accordingly, ensuring UI reflects changes.",
            "status": "pending",
            "testStrategy": "Send manual WebSocket messages from server and observe canvas updates in real-time without local actions.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Set up server-side broadcasting of object change messages",
            "description": "Implement server logic to broadcast received WebSocket messages to all connected clients except the sender.",
            "dependencies": [
              2
            ],
            "details": "In the server code, upon receiving a message from a client, relay it to all other connected WebSocket clients, ensuring efficient broadcasting without echoing back to the originator.",
            "status": "pending",
            "testStrategy": "Connect multiple clients, perform an action on one, and verify the message is received by others via server logs or client-side logs.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement last-write-wins conflict resolution",
            "description": "Add logic to handle concurrent updates by prioritizing the latest timestamped change.",
            "dependencies": [
              3
            ],
            "details": "Attach timestamps to all object change messages. In the message handler, compare timestamps on conflicts (e.g., simultaneous updates to the same object) and apply the most recent one, discarding older changes.",
            "status": "pending",
            "testStrategy": "Simulate conflicts by rapidly updating the same object from two clients and verify only the latest change persists.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Test end-to-end real-time synchronization",
            "description": "Perform comprehensive testing to ensure synchronization works across clients with low latency.",
            "dependencies": [
              4
            ],
            "details": "Open multiple browser windows, create, update, and delete objects in one, and verify immediate reflection in others. Use network tools to confirm latency under 100ms and handle edge cases like disconnections.",
            "status": "pending",
            "testStrategy": "Follow the test strategy from the parent task: Open two browser windows, perform actions in one, check sync in the other, measure latency.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-14T02:52:44.596Z"
      },
      {
        "id": 12,
        "title": "Implement cursor synchronization",
        "description": "Enable real-time cursor position sharing with presence.",
        "details": "In websocket.js, send cursor updates on mouse move (throttled). On receive, render remote cursors with username labels in unique colors. Update presence list on connect/disconnect.",
        "testStrategy": "Move mouse in one window, verify cursor appears in others with <50ms latency. Check presence list updates on join/leave.",
        "priority": "medium",
        "dependencies": [
          "10"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up mouse move event listener with throttling",
            "description": "Implement a throttled mouse move event listener in the canvas to capture cursor positions efficiently.",
            "dependencies": [],
            "details": "In canvas.js, add an event listener for mousemove events on the canvas element. Use a throttling mechanism (e.g., lodash.throttle or custom implementation) to limit updates to every 50ms or less to avoid excessive sending.",
            "status": "pending",
            "testStrategy": "Move mouse rapidly and verify that position updates are throttled, not sent on every pixel movement.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Send cursor position updates via WebSocket",
            "description": "Modify websocket.js to send cursor position data on throttled mouse moves.",
            "dependencies": [
              1
            ],
            "details": "In websocket.js, on each throttled mouse move, send a message containing the current cursor x, y coordinates, username, and a unique color identifier via the WebSocket connection.",
            "status": "pending",
            "testStrategy": "Move mouse and use browser dev tools to inspect WebSocket messages, confirming position data is sent with username and color.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Receive and parse cursor updates from WebSocket",
            "description": "Handle incoming WebSocket messages for cursor positions from other users.",
            "dependencies": [
              2
            ],
            "details": "In websocket.js, add a message handler to receive cursor update messages, parse the JSON payload to extract position, username, and color, and store or update a list of remote cursors.",
            "status": "pending",
            "testStrategy": "Open multiple browser windows, move mouse in one, and check console logs in others for received messages with correct data.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Render remote cursors with username labels and unique colors",
            "description": "Display remote cursors on the canvas with labels and colors.",
            "dependencies": [
              3
            ],
            "details": "In canvas.js, for each remote cursor in the list, render a cursor icon (e.g., a small arrow or dot) at the received position, add a text label with the username, and apply the unique color. Update positions in real-time as new messages arrive.",
            "status": "pending",
            "testStrategy": "With multiple users, move cursors and verify they appear in other windows with labels, colors, and <50ms latency using browser performance tools.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Update presence list on user connect and disconnect",
            "description": "Maintain and display a list of online users based on WebSocket connections.",
            "dependencies": [
              3
            ],
            "details": "In websocket.js, on WebSocket open (connect), send a join message with username. On close (disconnect), send a leave message. Maintain a presence list and update the UI (e.g., a sidebar) to show current online users.",
            "status": "pending",
            "testStrategy": "Open/close browser windows and check that the presence list updates immediately on join/leave, reflecting accurate user counts.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-14T02:52:45.813Z"
      },
      {
        "id": 13,
        "title": "Implement state persistence",
        "description": "Save and load canvas state to/from SQLite database.",
        "details": "In canvas-state.lisp, implement save function with debounced updates (500ms). Load state on connection via GET /api/canvas/state. Store as JSON blob in canvas_states table.",
        "testStrategy": "Create objects, refresh page, verify state persists. Disconnect all users, reconnect, check state loads. Confirm debouncing prevents excessive saves.",
        "priority": "high",
        "dependencies": [
          "2",
          "11"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create canvas_states table in SQLite",
            "description": "Set up the database schema for storing canvas state as JSON blobs.",
            "dependencies": [],
            "details": "Create a table named 'canvas_states' with columns: id (primary key, auto-increment), state_json (text for JSON blob), and timestamp (datetime for last update). Ensure the table is created in the SQLite database used by the application.",
            "status": "pending",
            "testStrategy": "Run a database query to verify the table exists with correct columns.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement debounced save function in canvas-state.lisp",
            "description": "Develop a function to save the current canvas state to the database with debouncing to prevent excessive saves.",
            "dependencies": [
              1
            ],
            "details": "In canvas-state.lisp, create a save-canvas-state function that serializes the canvas state to JSON and inserts/updates it in the canvas_states table. Implement debouncing using a timer (500ms delay) to batch saves and avoid overloading the database on rapid changes.",
            "status": "pending",
            "testStrategy": "Simulate rapid canvas changes and check that saves occur only after 500ms of inactivity, verifying database entries.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement load state function for GET /api/canvas/state",
            "description": "Create a backend endpoint to retrieve and return the persisted canvas state.",
            "dependencies": [
              1
            ],
            "details": "In canvas-state.lisp, add a handler for GET /api/canvas/state that queries the canvas_states table for the latest state JSON, parses it, and returns it in the response. Handle cases where no state exists (return empty or default state).",
            "status": "pending",
            "testStrategy": "Use curl or a browser to call the endpoint and verify it returns the correct JSON state or default when no data is present.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate saving on canvas state changes",
            "description": "Connect the save function to trigger whenever the canvas state is modified.",
            "dependencies": [
              2
            ],
            "details": "Modify the canvas manipulation code (e.g., in canvas.js or related Lisp functions) to call the debounced save function whenever objects are created, moved, or deleted. Ensure the state includes all necessary object properties for accurate restoration.",
            "status": "pending",
            "testStrategy": "Create and modify objects on the canvas, then check the database to confirm the state is saved correctly after debouncing.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate loading on client connection",
            "description": "Ensure the canvas state is loaded from the database when a user connects or refreshes the page.",
            "dependencies": [
              3
            ],
            "details": "In the client-side code (e.g., canvas.js), add logic to fetch the state via GET /api/canvas/state on page load or connection, and populate the canvas with the loaded objects. Handle authentication if required, and merge or replace existing state appropriately.",
            "status": "pending",
            "testStrategy": "Refresh the page after making changes, verify that the canvas reloads with the persisted state. Test with multiple users or disconnections.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-14T02:52:47.049Z"
      },
      {
        "id": 14,
        "title": "Implement user interface components",
        "description": "Build the UI for toolbar, presence list, and status bar.",
        "details": "In HTML/CSS/JS, create toolbar for tools (select, rectangle, circle), color picker. Add presence list in top-right. Implement status bar for tool, position, zoom. Ensure dark theme consistency.",
        "testStrategy": "Verify toolbar switches tools, presence shows online users, status updates correctly. Check UI doesn't obstruct canvas and is responsive.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create toolbar with tool buttons and color picker",
            "description": "Design and implement the toolbar containing buttons for select, rectangle, and circle tools, along with a color picker component.",
            "dependencies": [],
            "details": "In HTML, add a div for the toolbar. Use CSS for styling with dark theme. In JS, create buttons for each tool and a color input. Attach event listeners to switch tool modes in canvas.js.",
            "status": "pending",
            "testStrategy": "Click each tool button and verify the active tool changes. Select a color and confirm it applies to new objects.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement presence list in top-right corner",
            "description": "Build the presence list component to display online users in the top-right area of the interface.",
            "dependencies": [
              1
            ],
            "details": "Add a div in the top-right of the page layout. Use JS to fetch and display user list from backend. Style with dark theme CSS. Update list on user join/leave events.",
            "status": "pending",
            "testStrategy": "Simulate multiple users logging in and verify the list updates in real-time. Check positioning doesn't overlap with other UI elements.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop status bar for tool, position, and zoom info",
            "description": "Create the status bar at the bottom to show current tool, mouse position, and zoom level.",
            "dependencies": [
              1
            ],
            "details": "Insert a status bar div at the bottom of the page. In JS, update text content based on current tool, mouse coordinates, and zoom factor. Ensure responsive design and dark theme.",
            "status": "pending",
            "testStrategy": "Switch tools and move mouse; verify status bar updates accurately. Zoom in/out and check zoom display changes.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Apply dark theme consistency across UI components",
            "description": "Ensure all toolbar, presence list, and status bar elements adhere to the dark theme color scheme.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Define CSS variables for dark theme colors (e.g., background, text, borders). Apply these to all UI elements created. Test for consistency in visibility and aesthetics.",
            "status": "pending",
            "testStrategy": "Inspect UI in browser dev tools for color consistency. Verify readability and contrast in dark mode.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate UI components into main layout",
            "description": "Position and integrate the toolbar, presence list, and status bar into the overall page layout without obstructing the canvas.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Use CSS flexbox or grid to arrange components: toolbar top-left, presence top-right, status bottom. Ensure canvas remains central and unobstructed. Make layout responsive.",
            "status": "pending",
            "testStrategy": "Resize browser window and confirm UI elements adjust properly. Verify canvas interaction isn't blocked by UI overlays.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-14T02:52:48.264Z"
      },
      {
        "id": 15,
        "title": "Deploy application to Fly.io",
        "description": "Containerize and deploy the application to Fly.io for public access.",
        "details": "Create Dockerfile as specified. Build frontend and backend. Configure fly.toml. Use fly deploy. Ensure health check endpoint.",
        "testStrategy": "Access deployed URL, test full flow: register, login, create objects, sync with another user. Verify performance and no errors in logs.",
        "priority": "high",
        "dependencies": [
          "13",
          "14"
        ],
        "status": "pending",
        "subtasks": [],
        "updatedAt": "2025-10-14T02:52:04.930Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-14T02:52:48.265Z",
      "taskCount": 15,
      "completedCount": 14,
      "tags": [
        "master"
      ],
      "created": "2025-10-14T14:40:42.116Z",
      "description": "Tasks for master context"
    }
  },
  "perf": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement Cursor Update Batching",
        "description": "Batch cursor updates on the backend and throttle sending on the frontend to reduce network traffic and ensure <50ms latency.",
        "details": "On the backend, create a message-queue struct with cursor-batch and object-batch. Implement queue-cursor-update to add updates to the batch and flush-cursor-batch to send batched updates every 50ms. On the frontend, create a CursorThrottle class that throttles updates to max 20/sec using setInterval. Ensure batch messages include all cursor positions and latency remains <50ms.",
        "testStrategy": "Unit test the batching logic to verify updates are queued and flushed correctly. Integration test with multiple clients to measure latency and ensure it stays under 50ms. Load test with 5 concurrent users to confirm no lag.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Backend Message Queue for Cursor Batching",
            "description": "Create a backend message-queue struct that includes cursor-batch and object-batch components. Implement functions to queue cursor updates and flush batches every 50ms to reduce network traffic.",
            "dependencies": [],
            "details": "On the backend, define a message-queue struct with arrays for cursor-batch and object-batch. Implement queue-cursor-update to append updates to the cursor-batch. Implement flush-cursor-batch to send the batched updates via WebSocket or similar every 50ms using a timer. Ensure the batch includes all cursor positions and handles multiple updates efficiently.",
            "status": "done",
            "testStrategy": "Unit test the queue and flush functions to verify updates are batched and sent at the correct intervals.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T15:59:40.899Z"
          },
          {
            "id": 2,
            "title": "Implement Frontend Cursor Throttling Logic",
            "description": "Create a CursorThrottle class on the frontend to limit cursor updates to a maximum of 20 per second using setInterval, ensuring low latency.",
            "dependencies": [],
            "details": "On the frontend, develop a CursorThrottle class that uses setInterval to throttle cursor position updates to no more than 20 per second. Capture cursor movements, buffer them, and send batched updates at the throttled rate. Integrate with the backend batching to maintain overall latency under 50ms.",
            "status": "done",
            "testStrategy": "Unit test the throttling mechanism to ensure it limits updates to 20/sec and handles rapid cursor movements without exceeding the rate.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T15:59:42.195Z"
          },
          {
            "id": 3,
            "title": "Conduct Comprehensive Testing Including Latency Measurements",
            "description": "Perform unit, integration, and load testing to verify batching and throttling work correctly, with a focus on measuring and ensuring latency remains under 50ms.",
            "dependencies": [],
            "details": "Execute unit tests for backend batching and frontend throttling. Run integration tests with multiple clients to simulate real-world usage. Conduct load tests with 5 concurrent users to measure latency using tools like performance.now(). Ensure all tests confirm latency <50ms and no network overload.",
            "status": "done",
            "testStrategy": "Use automated testing frameworks for unit and integration tests; employ load testing tools to measure latency percentiles and verify compliance with <50ms requirement under various conditions.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T15:59:43.450Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down the task into backend queue implementation, frontend throttling logic, and comprehensive testing including latency measurements.",
        "updatedAt": "2025-10-14T15:59:43.450Z"
      },
      {
        "id": 2,
        "title": "Implement Delta Compression for Object Updates",
        "description": "Send only changed fields for object updates to reduce bandwidth by 60-80%.",
        "details": "On the backend, create create-object-delta function to compare old and new objects and return only changed properties like x, y, width, height, rotation, color. On the frontend, implement applyDelta method to update only the changed properties on the object. Send full object state on creation and deltas thereafter.",
        "testStrategy": "Unit test delta creation to ensure only changed fields are included. Integration test to verify deltas are applied correctly across clients. Measure bandwidth usage before and after implementation to confirm 60-80% reduction.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Backend Delta Creation Function",
            "description": "Create the create-object-delta function on the backend to compare old and new objects and return only changed properties such as x, y, width, height, rotation, and color.",
            "dependencies": [],
            "details": "On the backend, implement a function that takes old and new object states, performs a deep comparison to identify changed fields, and returns a delta object containing only the modified properties. Ensure the function handles nested objects if necessary and is efficient for real-time updates.",
            "status": "done",
            "testStrategy": "Unit test the delta creation to ensure only changed fields are included and no unchanged fields are present.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Frontend Delta Application and Bandwidth Testing",
            "description": "Implement the applyDelta method on the frontend to update only the changed properties on objects and measure bandwidth reduction.",
            "dependencies": [
              1
            ],
            "details": "On the frontend, create an applyDelta method that merges the delta into the existing object state without overwriting unchanged fields. Send full object state on creation and deltas thereafter. Conduct bandwidth measurement tests by comparing network usage before and after implementation to confirm 60-80% reduction.",
            "status": "done",
            "testStrategy": "Integration test to verify deltas are applied correctly across clients. Measure bandwidth usage before and after implementation using network profiling tools to confirm the 60-80% reduction.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Separate into backend delta creation, frontend delta application, and bandwidth measurement testing."
      },
      {
        "id": 3,
        "title": "Implement Priority Queue for Messages",
        "description": "Prioritize cursor and presence updates over object updates to prevent cursor lag.",
        "details": "On the backend, create a priority-queue struct with high-priority (cursors, presence), normal-priority (object updates), and low-priority queues. Implement process-message-queue to process high-priority first, then normal with a limit. Ensure message ordering within priorities.",
        "testStrategy": "Unit test queue processing to verify priority order. Integration test during heavy object updates to ensure cursor updates are not delayed. Performance test to confirm no cursor lag with high object update frequency.",
        "priority": "medium",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Priority Queue Structure",
            "description": "Create a priority-queue struct with three levels: high-priority for cursors and presence updates, normal-priority for object updates, and low-priority queues to manage message ordering.",
            "dependencies": [],
            "details": "Implement a data structure using arrays or linked lists for each priority level, ensuring FIFO ordering within each priority. Include methods to enqueue messages with their priority and dequeue based on priority order.",
            "status": "done",
            "testStrategy": "Unit test the queue structure to verify correct enqueuing and dequeuing across priorities.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Message Processing Logic",
            "description": "Develop process-message-queue function to process high-priority messages first, then normal-priority with a limit, ensuring no lag in cursor updates.",
            "dependencies": [
              1
            ],
            "details": "Write logic to iterate through high-priority queue completely, then process up to a configurable limit from normal-priority, and optionally low-priority. Maintain message ordering within priorities using timestamps or sequence numbers.",
            "status": "done",
            "testStrategy": "Unit test the processing logic to confirm priority order and limits are respected.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Test Priority Handling Under High Load",
            "description": "Perform testing to ensure priority queue prevents cursor lag during heavy object updates and concurrent presence changes.",
            "dependencies": [
              1,
              2
            ],
            "details": "Set up load tests simulating high-frequency object updates while monitoring cursor and presence update delays. Use performance metrics to verify that high-priority messages are processed without significant lag.",
            "status": "done",
            "testStrategy": "Integration and performance tests under simulated high load to measure latency and confirm no cursor lag.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Divide into queue structure design, processing logic, and priority testing under high load."
      },
      {
        "id": 4,
        "title": "Implement Object Culling for Rendering",
        "description": "Only render objects visible in the viewport plus padding to maintain 60 FPS with 500+ objects.",
        "details": "In CanvasManager, add setupViewportCulling to listen for viewport moved/zoomed events and call updateVisibleObjects. Implement updateVisibleObjects to calculate visible bounds with 200px padding and set obj.visible and obj.renderable based on intersection. Use getVisibleBounds and isIntersecting helper functions.",
        "testStrategy": "Unit test bounds calculation and intersection logic. Integration test by creating 500+ objects and verifying only visible ones are rendered. Performance test to ensure 60 FPS during pan/zoom operations.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Viewport Calculation and Culling Logic",
            "description": "Add setupViewportCulling to listen for viewport events and implement updateVisibleObjects to calculate bounds with padding and set object visibility.",
            "dependencies": [],
            "details": "In CanvasManager, add setupViewportCulling method to listen for viewport moved/zoomed events and call updateVisibleObjects. Implement updateVisibleObjects to calculate visible bounds with 200px padding using getVisibleBounds, and set obj.visible and obj.renderable based on intersection using isIntersecting helper functions.",
            "status": "done",
            "testStrategy": "Unit test bounds calculation and intersection logic.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Performance Testing with Many Objects",
            "description": "Test rendering performance with 500+ objects to ensure 60 FPS during pan/zoom operations.",
            "dependencies": [
              1
            ],
            "details": "Create integration tests by generating 500+ objects and verifying only visible ones are rendered. Perform performance tests to measure FPS during pan/zoom operations, ensuring it maintains 60 FPS with the culling logic in place.",
            "status": "done",
            "testStrategy": "Integration test with 500+ objects to verify visibility. Performance test for 60 FPS during pan/zoom.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:02:47.879Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Split into viewport calculation, culling logic, and performance testing with many objects.",
        "updatedAt": "2025-10-14T16:02:47.879Z"
      },
      {
        "id": 5,
        "title": "Add FPS Monitoring",
        "description": "Track and log FPS to detect drops below 55 and provide performance stats.",
        "details": "Create PerformanceMonitor class that uses app.ticker to track FPS in a history array of max 60 entries. Log warnings when FPS < 55, including object count and average FPS. Provide getStats method for current, average, min, max FPS.",
        "testStrategy": "Unit test FPS tracking accuracy. Integration test by simulating load and checking logs for warnings. Manual test to access stats via console and verify no performance impact from monitoring.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create PerformanceMonitor Class Structure",
            "description": "Set up the basic PerformanceMonitor class with necessary properties and initialization.",
            "dependencies": [],
            "details": "Define the PerformanceMonitor class with properties for FPS history array (max 60 entries), current FPS, and methods stubs for tracking and stats. Ensure it integrates with app.ticker for updates.",
            "status": "done",
            "testStrategy": "Unit test class instantiation and property initialization.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:18:10.090Z"
          },
          {
            "id": 2,
            "title": "Implement FPS Tracking with Ticker",
            "description": "Use app.ticker to calculate and track FPS in real-time.",
            "dependencies": [
              1
            ],
            "details": "In the PerformanceMonitor class, add a ticker listener that calculates FPS based on delta time from the ticker. Update the current FPS value on each tick and prepare for adding to history.",
            "status": "done",
            "testStrategy": "Unit test FPS calculation accuracy by mocking ticker events.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:18:11.375Z"
          },
          {
            "id": 3,
            "title": "Add FPS History Array Management",
            "description": "Maintain a history array of FPS values with a maximum of 60 entries.",
            "dependencies": [
              2
            ],
            "details": "Implement logic to add current FPS to the history array on each update, ensuring the array does not exceed 60 entries by removing oldest values. Calculate average FPS from the history.",
            "status": "done",
            "testStrategy": "Unit test array management, including adding, removing, and average calculation.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:18:12.803Z"
          },
          {
            "id": 4,
            "title": "Implement Warning Logging for Low FPS",
            "description": "Log warnings when FPS drops below 55, including object count and average FPS.",
            "dependencies": [
              3
            ],
            "details": "Add logic to check if current FPS is below 55, and if so, log a warning message that includes the current object count (assuming access to object count) and the average FPS from history. Use console.warn or similar.",
            "status": "done",
            "testStrategy": "Integration test by simulating low FPS scenarios and verifying logs are generated correctly.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:18:14.154Z"
          },
          {
            "id": 5,
            "title": "Provide getStats Method for FPS Statistics",
            "description": "Implement getStats method to return current, average, min, and max FPS.",
            "dependencies": [
              3
            ],
            "details": "Create the getStats method that computes and returns an object with current FPS, average FPS (from history), minimum FPS, and maximum FPS from the history array. Ensure calculations are accurate and efficient.",
            "status": "done",
            "testStrategy": "Unit test the getStats method with various history arrays to verify correct stats output.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:18:15.523Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": "2025-10-14T16:18:15.523Z"
      },
      {
        "id": 6,
        "title": "Optimize Remote Cursor Rendering",
        "description": "Use shared textures for cursors to improve performance with multiple remote cursors.",
        "details": "In createRemoteCursor, create a shared cursorTexture once using PIXI.Graphics for the cursor shape. Use PIXI.Sprite with tint for color instead of individual graphics. Add username label as PIXI.Text. Ensure smooth movement at 60 FPS with 10+ cursors.",
        "testStrategy": "Unit test texture sharing and sprite creation. Performance test rendering 10+ cursors to confirm no FPS drop. Visual test to ensure cursors are readable and performant.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Shared Cursor Texture",
            "description": "Generate a single shared texture for the cursor shape using PIXI.Graphics to avoid recreating graphics for each cursor.",
            "dependencies": [],
            "details": "In the PIXI application, create a function to draw a cursor shape (e.g., arrow or pointer) using PIXI.Graphics, render it to a texture once, and store it as a shared resource. This texture will be reused for all remote cursors to optimize memory and rendering performance.",
            "status": "done",
            "testStrategy": "Unit test to verify the texture is created correctly and can be reused without errors.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Refactor createRemoteCursor to Use Shared Texture and Sprite",
            "description": "Update the createRemoteCursor function to use the shared texture with PIXI.Sprite and apply tint for color variations instead of individual graphics.",
            "dependencies": [
              1
            ],
            "details": "Modify createRemoteCursor to instantiate a PIXI.Sprite using the shared cursorTexture, set its tint property for different colors based on user, and position it accordingly. Remove any code that creates individual PIXI.Graphics for each cursor to reduce overhead.",
            "status": "done",
            "testStrategy": "Unit test sprite creation and tint application to ensure colors are applied correctly.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Username Label to Remote Cursors",
            "description": "Attach a PIXI.Text label displaying the username to each remote cursor for identification.",
            "dependencies": [
              2
            ],
            "details": "In createRemoteCursor, create a PIXI.Text object with the username, style it appropriately (e.g., font size, color), and add it as a child to the cursor sprite. Position the text relative to the cursor (e.g., above or beside it) to ensure readability.",
            "status": "done",
            "testStrategy": "Visual test to confirm labels are displayed correctly and do not overlap or obscure the cursor.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Smooth Cursor Movement",
            "description": "Ensure cursor positions are updated smoothly to achieve 60 FPS movement with multiple cursors.",
            "dependencies": [
              2
            ],
            "details": "Update the cursor update logic to interpolate positions between received updates for fluid animation. Use requestAnimationFrame or PIXI's ticker to animate cursor movement, ensuring it handles 10+ cursors without dropping below 60 FPS.",
            "status": "done",
            "testStrategy": "Performance test rendering and animating 10+ cursors to measure FPS and confirm smooth movement.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Optimize and Test Overall Rendering Performance",
            "description": "Conduct performance optimizations and tests to ensure the system maintains 60 FPS with 10+ remote cursors.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Profile the rendering pipeline, optimize any bottlenecks in texture usage, sprite management, and animation. Run comprehensive tests including unit tests for components, performance benchmarks for FPS, and visual checks for readability and performance.",
            "status": "done",
            "testStrategy": "Performance test with 10+ cursors to confirm no FPS drop; visual test for readability; integration test to ensure all components work together seamlessly.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": ""
      },
      {
        "id": 7,
        "title": "Implement Memory Cleanup on Disconnect",
        "description": "Properly clean up user data and objects on disconnect to prevent memory leaks.",
        "details": "On backend, in handle-client-disconnect, remove client from room, broadcast user-left, and clean up user data. On frontend, handleUserLeft to destroy cursors (keeping shared texture), remove from activeUsers, and update UI. Add startPeriodicCleanup to remove orphaned objects every minute.",
        "testStrategy": "Unit test cleanup functions. Integration test connect/disconnect cycles to verify memory stability. Run 24-hour session test to ensure no memory growth.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Backend Disconnect Handling",
            "description": "Handle client disconnection on the backend by removing the client from the room, broadcasting user-left events, and cleaning up associated user data to prevent memory leaks.",
            "dependencies": [],
            "details": "In the handle-client-disconnect function, ensure the client is removed from the room structure, broadcast a user-left event to other clients, and perform thorough cleanup of user-specific data such as session variables and temporary caches. This prevents orphaned references that could lead to memory accumulation.",
            "status": "done",
            "testStrategy": "Unit test the cleanup functions to verify that user data is properly removed upon disconnect.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:16:03.329Z"
          },
          {
            "id": 2,
            "title": "Implement Frontend Memory Cleanup",
            "description": "On the frontend, handle user-left events to destroy cursors while preserving shared textures, remove users from active lists, and update the UI accordingly.",
            "dependencies": [],
            "details": "In the handleUserLeft function, destroy individual cursor objects but keep shared textures intact to avoid unnecessary reloading. Remove the disconnected user from the activeUsers array and update any UI elements that display user presence. Ensure no references to the user remain in the DOM or memory.",
            "status": "done",
            "testStrategy": "Integration test connect/disconnect cycles to verify that frontend memory is stable and no leaks occur during repeated user joins and leaves.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:16:04.616Z"
          },
          {
            "id": 3,
            "title": "Add Periodic Memory Cleanup and Long-Term Testing",
            "description": "Implement a periodic cleanup mechanism to remove orphaned objects every minute and conduct thorough testing to ensure no memory growth over time.",
            "dependencies": [],
            "details": "Add a startPeriodicCleanup function that runs every minute to scan for and remove orphaned objects, such as unused PIXI elements or stale data structures. Integrate this into the application's main loop. Conduct a 24-hour session test to monitor memory usage and confirm no gradual leaks occur under sustained load.",
            "status": "done",
            "testStrategy": "Run a 24-hour session test to ensure no memory growth, combined with memory profiling to detect any leaks during periodic cleanup operations.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:16:05.909Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Separate into backend disconnect handling, frontend cleanup, and long-term memory testing.",
        "updatedAt": "2025-10-14T16:16:05.909Z"
      },
      {
        "id": 8,
        "title": "Implement Object Deletion with Proper Cleanup",
        "description": "Ensure deleted objects are fully removed from memory and textures are managed.",
        "details": "In deleteObject, use obj.destroy with options to destroy children but keep shared textures. Remove from objects and selectedObjects maps. For bulk delete, process multiple IDs and broadcast deletions once. Ensure no orphaned PIXI objects.",
        "testStrategy": "Unit test deletion and bulk operations. Memory profiling test to confirm no leaks after deletions. Integration test to verify objects are removed across clients.",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Single and Bulk Object Deletion Logic",
            "description": "Develop the core logic for deleting individual objects and handling bulk deletions, ensuring proper cleanup of PIXI objects and removal from maps.",
            "dependencies": [],
            "details": "In the deleteObject function, use obj.destroy with options to destroy children but preserve shared textures. Remove the object from both objects and selectedObjects maps. For bulk delete, process an array of IDs, perform deletions, and broadcast the deletions once to avoid multiple broadcasts. Ensure no orphaned PIXI objects remain in the scene graph.",
            "status": "done",
            "testStrategy": "Unit tests for deleteObject and bulkDelete functions to verify objects are removed from maps and destroyed correctly. Integration tests to confirm broadcasts are sent properly for bulk operations.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Memory Leak Verification for Object Deletion",
            "description": "Add mechanisms to verify that deleted objects are fully removed from memory and no leaks occur, including texture management checks.",
            "dependencies": [
              1
            ],
            "details": "After deletion, implement checks to ensure PIXI objects are not retained in memory. Use memory profiling tools or custom checks to confirm textures are managed properly (shared ones kept, others released). Add logging or assertions to detect orphaned objects. Integrate with the deletion logic to run verifications post-deletion.",
            "status": "done",
            "testStrategy": "Memory profiling tests using tools like Chrome DevTools to confirm no leaks after deletions. Unit tests for verification functions to ensure they detect potential issues. Integration tests to verify no orphaned objects in the PIXI stage after bulk deletions.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break into deletion logic, bulk operations, and memory leak verification."
      },
      {
        "id": 9,
        "title": "Add Rate Limiting and Input Validation",
        "description": "Protect against abuse with rate limiting and validate input to prevent invalid data.",
        "details": "On backend, create rate-limiter struct with message count and window. Implement check-rate-limit to allow max 100 messages/sec, resetting window. Add validate-object-update and validate-canvas-state for bounds checking. Reject invalid data with errors.",
        "testStrategy": "Unit test rate limiter and validation functions. Load test to attempt DoS and verify limits are enforced. Integration test invalid inputs are rejected with error messages.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Rate Limiter Struct and Logic",
            "description": "Create a rate-limiter struct with message count and window, and implement check-rate-limit to allow max 100 messages/sec, resetting the window as needed.",
            "dependencies": [],
            "details": "On the backend, define a rate-limiter struct that tracks message counts within a time window. Implement the check-rate-limit function to enforce a maximum of 100 messages per second, automatically resetting the window when the time period expires. Ensure thread-safety for concurrent access.",
            "status": "done",
            "testStrategy": "Unit test the rate limiter to verify it correctly allows up to 100 messages per second and resets the window appropriately.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add Input Validation Functions",
            "description": "Implement validate-object-update and validate-canvas-state functions to perform bounds checking on input data.",
            "dependencies": [],
            "details": "Add validation functions on the backend to check bounds for object updates and canvas states. These functions should verify that provided values are within acceptable ranges, such as position coordinates, sizes, and other properties, to prevent invalid data from being processed.",
            "status": "done",
            "testStrategy": "Unit test the validation functions to ensure they correctly identify and flag invalid inputs based on defined bounds.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Conduct Abuse and DoS Testing",
            "description": "Perform load testing to simulate abuse scenarios, including attempts at DoS attacks, and verify that rate limits are enforced.",
            "dependencies": [
              1
            ],
            "details": "Set up load tests that attempt to exceed the rate limits by sending high volumes of messages. Monitor the system to ensure the rate limiter blocks excessive requests and prevents DoS conditions. Use tools to simulate concurrent high-traffic scenarios.",
            "status": "done",
            "testStrategy": "Load test to attempt DoS and verify that limits are enforced, preventing system overload.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Error Handling for Invalid Data",
            "description": "Add error handling mechanisms to reject invalid data and return appropriate error messages to clients.",
            "dependencies": [
              2
            ],
            "details": "Integrate error responses into the validation functions so that when invalid data is detected, the system rejects it and sends back clear error messages indicating what was wrong (e.g., out-of-bounds values). Ensure errors are logged and communicated properly without exposing sensitive information.",
            "status": "done",
            "testStrategy": "Integration test to verify that invalid inputs are rejected with appropriate error messages.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Divide into rate limiter implementation, validation functions, abuse testing, and error handling."
      },
      {
        "id": 10,
        "title": "Optimize Database Access with Pooling and Indexing",
        "description": "Implement connection pooling and add indexes to improve query performance.",
        "details": "Create db-pool struct with 10 connections and thread-safe access using bt:make-lock. Implement with-db-connection macro for reusing connections. Add SQL indexes on canvas_id, session_id, user_id, email. Optimize save-canvas-state-optimized with transactions and INSERT OR REPLACE.",
        "testStrategy": "Unit test connection pooling for reuse and thread-safety. Performance test query execution times to ensure <10ms. Load test database operations to confirm no contention or leaks.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Database Connection Pooling",
            "description": "Set up a connection pool to manage database connections efficiently with thread-safe access.",
            "dependencies": [],
            "details": "Create a db-pool struct with 10 connections and ensure thread-safe access using bt:make-lock. Implement the with-db-connection macro to allow reusing connections from the pool, preventing connection exhaustion and improving concurrency.",
            "status": "done",
            "testStrategy": "Unit test connection pooling for reuse and thread-safety, verifying that connections are properly acquired and released without leaks.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:24:32.583Z"
          },
          {
            "id": 2,
            "title": "Add SQL Indexes on Key Columns",
            "description": "Create indexes on frequently queried columns to speed up database lookups.",
            "dependencies": [],
            "details": "Add SQL indexes on canvas_id, session_id, user_id, and email columns in the relevant database tables. This will reduce query execution time by allowing faster searches and joins on these fields.",
            "status": "done",
            "testStrategy": "Performance test query execution times after indexing to ensure they remain under 10ms, comparing before and after metrics.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:24:33.878Z"
          },
          {
            "id": 3,
            "title": "Optimize Canvas State Saving with Transactions",
            "description": "Enhance the save-canvas-state-optimized function using transactions and efficient insert operations.",
            "dependencies": [],
            "details": "Modify save-canvas-state-optimized to use database transactions for atomic operations and employ INSERT OR REPLACE statements to handle updates and inserts efficiently, minimizing overhead and ensuring data consistency.",
            "status": "done",
            "testStrategy": "Unit test the transaction logic to verify atomicity and correctness of INSERT OR REPLACE operations under various scenarios.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:24:35.189Z"
          },
          {
            "id": 4,
            "title": "Perform Performance and Load Testing",
            "description": "Conduct comprehensive testing to validate database performance under load and ensure no issues.",
            "dependencies": [],
            "details": "Execute load tests on database operations to confirm there is no contention, connection leaks, or performance degradation. Monitor query times to maintain sub-10ms performance even under high concurrency.",
            "status": "done",
            "testStrategy": "Load test database operations to confirm no contention or leaks, and performance test query execution times to ensure they stay under 10ms with simulated high-load conditions.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:24:36.586Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Split into pooling setup, indexing, transaction optimization, and performance/load testing.",
        "updatedAt": "2025-10-14T16:24:36.586Z"
      },
      {
        "id": 11,
        "title": "Implement Performance Monitoring for Latency",
        "description": "Track message latency and provide stats for optimization.",
        "details": "Create LatencyMonitor class to track round-trip latency for messages using performance.now() and messageId. Record latencies in history, warn on >100ms. Provide getStats for percentiles (p50, p95, p99).",
        "testStrategy": "Unit test latency tracking. Integration test with message sending to verify stats accuracy. Performance profiling to ensure monitoring adds minimal overhead.",
        "priority": "medium",
        "dependencies": [
          "1",
          "2",
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define LatencyMonitor Class Structure",
            "description": "Create the basic LatencyMonitor class with constructor, properties for storing latency history, and initial setup.",
            "dependencies": [],
            "details": "Initialize the class with a Map or array to store message IDs and their start times. Include a history array to record completed latencies. Set up any necessary imports for performance.now().",
            "status": "done",
            "testStrategy": "Unit test the class instantiation and basic properties.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:29:30.329Z"
          },
          {
            "id": 2,
            "title": "Implement Latency Start Tracking",
            "description": "Add a method to start tracking latency for a message using performance.now() and messageId.",
            "dependencies": [
              1
            ],
            "details": "Create a startLatency(messageId) method that records the current performance.now() timestamp associated with the messageId in the tracking map.",
            "status": "done",
            "testStrategy": "Unit test the startLatency method to verify timestamps are recorded correctly.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:29:31.795Z"
          },
          {
            "id": 3,
            "title": "Implement Latency End Tracking and Recording",
            "description": "Add a method to stop tracking and calculate round-trip latency, then record it in history.",
            "dependencies": [
              2
            ],
            "details": "Create an endLatency(messageId) method that calculates the latency by subtracting the start time from current performance.now(), removes the entry from tracking map, and pushes the latency to the history array.",
            "status": "done",
            "testStrategy": "Unit test the endLatency method to ensure accurate latency calculation and recording.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:29:33.524Z"
          },
          {
            "id": 4,
            "title": "Add Warning for High Latency",
            "description": "Implement logic to warn when recorded latency exceeds 100ms.",
            "dependencies": [
              3
            ],
            "details": "In the endLatency method or a separate check, compare the calculated latency against 100ms and log a warning if exceeded. Use console.warn or a custom logging mechanism.",
            "status": "done",
            "testStrategy": "Unit test the warning logic by simulating latencies above and below 100ms.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:29:35.440Z"
          },
          {
            "id": 5,
            "title": "Implement getStats Method for Percentiles",
            "description": "Create a getStats method that computes and returns p50, p95, and p99 percentiles from the latency history.",
            "dependencies": [
              4
            ],
            "details": "Implement getStats() to sort the history array, calculate the percentiles using appropriate formulas (e.g., for p50, median; for p95, 95th percentile), and return an object with p50, p95, p99 values.",
            "status": "done",
            "testStrategy": "Unit test getStats with sample latency data to verify correct percentile calculations.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:29:36.829Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": "2025-10-14T16:29:36.829Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-14T16:29:36.830Z",
      "taskCount": 11,
      "completedCount": 10,
      "tags": [
        "perf"
      ],
      "created": "2025-10-14T16:32:33.526Z",
      "description": "Tasks for perf context",
      "updated": "2025-10-14T16:32:33.527Z"
    }
  }
}