{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up project structure and dependencies",
        "description": "Initialize the backend and frontend project structures, install required libraries and tools as specified in the technical stack.",
        "details": "For backend: Use Roswell to set up SBCL Common Lisp project with ASDF system definition. Install Hunchentoot, Hunchensocket, cl-sqlite, Jonathan, Ironclad, Bordeaux-threads via Quicklisp. For frontend: Initialize Vite project with PixiJS v7, vanilla JavaScript ES6+. Create directory structures as per architecture (backend/src/, frontend/src/). Ensure Docker setup with Debian base.",
        "testStrategy": "Verify backend loads in REPL with (ql:quickload :collabcanvas). Check frontend builds with npm run build. Confirm all dependencies are installed without errors.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize backend project structure with Roswell and SBCL",
            "description": "Set up the Common Lisp project using Roswell to initialize SBCL with ASDF system definition and create the backend/src/ directory structure.",
            "dependencies": [],
            "details": "Use Roswell to create a new SBCL project named 'collabcanvas' with ASDF system definition. Ensure the project structure includes backend/src/ for source files. Verify that the ASDF system loads correctly in the REPL.",
            "status": "done",
            "testStrategy": "Load the project in SBCL REPL and check that the ASDF system is defined without errors.",
            "updatedAt": "2025-10-13T21:24:51.583Z"
          },
          {
            "id": 2,
            "title": "Install backend dependencies via Quicklisp",
            "description": "Install the required Common Lisp libraries including Hunchentoot, Hunchensocket, cl-sqlite, Jonathan, Ironclad, and Bordeaux-threads using Quicklisp.",
            "dependencies": [],
            "details": "After setting up the backend project, use Quicklisp to install Hunchentoot for web server, Hunchensocket for WebSockets, cl-sqlite for database, Jonathan for JSON handling, Ironclad for cryptography, and Bordeaux-threads for threading. Ensure all packages are available and loadable.",
            "status": "done",
            "testStrategy": "Run (ql:quickload :collabcanvas) in the REPL and confirm all dependencies load without errors.",
            "updatedAt": "2025-10-13T21:24:52.880Z"
          },
          {
            "id": 3,
            "title": "Initialize frontend project with Vite and PixiJS",
            "description": "Set up the frontend project using Vite for build tooling and initialize with PixiJS v7 and vanilla JavaScript ES6+, creating the frontend/src/ directory.",
            "dependencies": [],
            "details": "Use npm or yarn to initialize a Vite project in the frontend directory. Install PixiJS v7 as a dependency. Create the frontend/src/ structure for source files. Configure Vite for vanilla JS ES6+ development.",
            "status": "done",
            "testStrategy": "Run npm run build in the frontend directory and verify that the build completes successfully with PixiJS integrated.",
            "updatedAt": "2025-10-13T21:24:54.220Z"
          },
          {
            "id": 4,
            "title": "Install frontend dependencies",
            "description": "Ensure all frontend dependencies are installed, focusing on PixiJS v7 and any additional tools required for the project.",
            "dependencies": [],
            "details": "After initializing the Vite project, install PixiJS v7 and confirm that the package.json includes all necessary dependencies for vanilla JS ES6+ development. Check for any peer dependencies and resolve them.",
            "status": "done",
            "testStrategy": "Check that npm install completes without errors and that PixiJS can be imported in a test JS file.",
            "updatedAt": "2025-10-13T21:24:55.568Z"
          },
          {
            "id": 5,
            "title": "Set up Docker environment with Debian base",
            "description": "Create a Docker setup using Debian base image to containerize the project, ensuring both backend and frontend can run within the container.",
            "dependencies": [],
            "details": "Write a Dockerfile with Debian base image. Include instructions to install SBCL, Roswell, Node.js, and other necessary tools. Copy project files and set up commands to run the backend and frontend. Ensure the container can build and run the application.",
            "status": "done",
            "testStrategy": "Build the Docker image and run the container, verifying that both backend and frontend start without errors.",
            "updatedAt": "2025-10-13T21:24:56.916Z"
          }
        ],
        "updatedAt": "2025-10-13T21:24:56.916Z"
      },
      {
        "id": 2,
        "title": "Implement database schema and setup",
        "description": "Create and initialize the SQLite database with the required tables for users, sessions, and canvas states.",
        "details": "Use cl-sqlite to execute the schema.sql file creating users, sessions, and canvas_states tables. Include indexes for performance. Ensure database file is created in data/ directory. Implement utility functions in database.lisp for connecting and executing queries.",
        "testStrategy": "Run SQLite commands to verify tables exist and constraints are enforced. Insert test data and query to confirm integrity.",
        "priority": "high",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Create schema.sql file with table definitions",
            "description": "Define the SQL schema for users, sessions, and canvas_states tables including columns, data types, and constraints.",
            "dependencies": [],
            "details": "Write a schema.sql file that includes CREATE TABLE statements for users (id, email, username, password_hash), sessions (id, user_id, session_id, expires_at), and canvas_states (id, session_id, state_json). Add PRIMARY KEY and UNIQUE constraints, and indexes for performance on frequently queried columns like email and session_id.",
            "status": "pending",
            "testStrategy": "Validate the SQL syntax by attempting to execute it in a SQLite environment and check for errors."
          },
          {
            "id": 2,
            "title": "Implement database connection utility",
            "description": "Create functions in database.lisp to establish a connection to the SQLite database.",
            "dependencies": [],
            "details": "In database.lisp, define a function to connect to the SQLite database file located in the data/ directory, using cl-sqlite. Ensure the connection is reusable and handle any connection errors gracefully.",
            "status": "pending",
            "testStrategy": "Call the connection function and verify that the database file is created in data/ if it doesn't exist, and that subsequent calls reuse the connection."
          },
          {
            "id": 3,
            "title": "Execute schema.sql to initialize database",
            "description": "Run the schema.sql file to create the tables and indexes in the database.",
            "dependencies": [],
            "details": "Implement a function in database.lisp that reads and executes the schema.sql file using the established database connection. Ensure all tables are created with their indexes and constraints.",
            "status": "pending",
            "testStrategy": "After execution, query the database to confirm that tables users, sessions, and canvas_states exist with the correct columns and indexes."
          },
          {
            "id": 4,
            "title": "Implement query execution utilities",
            "description": "Add functions for executing SQL queries and statements in database.lisp.",
            "dependencies": [],
            "details": "Define utility functions for executing SELECT, INSERT, UPDATE, and DELETE queries, handling parameters securely to prevent SQL injection. Include functions for fetching results and handling transactions.",
            "status": "pending",
            "testStrategy": "Write and execute test queries to insert sample data into the tables and retrieve it, verifying that the utilities work correctly and data integrity is maintained."
          },
          {
            "id": 5,
            "title": "Verify database setup and file location",
            "description": "Ensure the database file is correctly placed and the setup is complete.",
            "dependencies": [],
            "details": "Check that the SQLite database file is created in the data/ directory. Run a final verification to ensure all tables, indexes, and constraints are properly set up and functional.",
            "status": "pending",
            "testStrategy": "Use SQLite commands to inspect the database file, confirm table structures, and perform basic operations to ensure everything is working as expected."
          }
        ],
        "updatedAt": "2025-10-13T21:24:58.407Z"
      },
      {
        "id": 3,
        "title": "Implement authentication backend",
        "description": "Develop the authentication system including user registration, login, logout, and session management using SHA-256 hashing.",
        "details": "In auth.lisp, implement functions for hashing passwords with Ironclad, creating sessions, validating logins. Add HTTP endpoints /api/register, /api/login, /api/logout using Hunchentoot. Store sessions in SQLite with 24-hour expiry. Handle unique constraints for email and username.",
        "testStrategy": "Use curl to test registration, login, and logout endpoints. Verify session persistence and expiry. Check database for correct data insertion.",
        "priority": "high",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up database schema for users and sessions",
            "description": "Create SQLite tables for users (with email, username, hashed password) and sessions (with session ID, user ID, expiry timestamp). Ensure unique constraints on email and username.",
            "dependencies": [],
            "details": "In the database setup, define a 'users' table with columns: id (primary key), email (unique), username (unique), password_hash (text). Define a 'sessions' table with columns: id (primary key), user_id (foreign key to users), session_id (unique), created_at (timestamp), expires_at (timestamp). Use SQLite pragmas for foreign keys.\n<info added on 2025-10-13T20:19:17.572Z>\nInstead of creating new tables, this subtask should confirm that Task 2 successfully created the users and sessions tables with the correct columns and constraints. Query the SQLite database schema using PRAGMA table_info or similar to validate the structure: users table with id (primary key), email (unique), username (unique), password_hash (text); sessions table with id (primary key), user_id (foreign key to users), session_id (unique), created_at (timestamp), expires_at (timestamp). Ensure foreign key constraints are enabled and unique constraints are in place on email and username. Raise errors if the schema does not match expectations.\n</info added on 2025-10-13T20:19:17.572Z>",
            "status": "pending",
            "testStrategy": "Verify table creation by querying the database schema and inserting test data to confirm unique constraints."
          },
          {
            "id": 2,
            "title": "Implement password hashing function",
            "description": "Develop a function to hash passwords using SHA-256 with Ironclad library.",
            "dependencies": [],
            "details": "In auth.lisp, define a function hash-password that takes a plain password string, uses Ironclad to compute SHA-256 hash, and returns the hex-encoded string. Ensure it handles UTF-8 encoding properly.",
            "status": "pending",
            "testStrategy": "Unit test the function with known inputs and verify outputs match expected SHA-256 hashes."
          },
          {
            "id": 3,
            "title": "Implement user registration endpoint",
            "description": "Create the /api/register HTTP endpoint to handle user registration with email, username, and password.",
            "dependencies": [],
            "details": "Using Hunchentoot, add a POST handler for /api/register that parses JSON body for email, username, password. Validate inputs, hash password, insert into users table, handle unique constraint violations by returning appropriate error responses.",
            "status": "pending",
            "testStrategy": "Use curl to send POST requests with valid and invalid data, check for successful registration and error messages for duplicates."
          },
          {
            "id": 4,
            "title": "Implement login endpoint with session creation",
            "description": "Create the /api/login HTTP endpoint to validate credentials and create a session.",
            "dependencies": [],
            "details": "Add a POST handler for /api/login that takes email/username and password. Query user by email or username, verify password hash, generate a unique session ID, insert into sessions table with 24-hour expiry, return session ID in response.",
            "status": "pending",
            "testStrategy": "Test login with correct and incorrect credentials using curl, verify session creation in database and response contains session ID."
          },
          {
            "id": 5,
            "title": "Implement logout endpoint and session management",
            "description": "Create the /api/logout HTTP endpoint to invalidate sessions.",
            "dependencies": [],
            "details": "Add a POST handler for /api/logout that takes session ID, deletes the session from the database. Optionally, implement session validation middleware for protected endpoints to check expiry.",
            "status": "pending",
            "testStrategy": "Login to get a session, call logout, verify session is removed from database, and test that expired sessions are invalidated."
          }
        ],
        "updatedAt": "2025-10-13T21:24:59.652Z"
      },
      {
        "id": 4,
        "title": "Implement authentication frontend",
        "description": "Create the login/register modal UI and logic for handling authentication on the client side.",
        "details": "In auth.js, build modal with tabs for login/register, fields for email, password, username. Use fetch API to call backend endpoints. Store sessionId in localStorage. Block canvas access until authenticated. Handle errors and display messages.",
        "testStrategy": "Open app, attempt registration and login. Verify modal blocks canvas, session persists on refresh. Test invalid credentials error handling.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create modal UI structure with tabs",
            "description": "Build the basic HTML structure for the authentication modal including tabs for login and register.",
            "dependencies": [],
            "details": "In auth.js, create a modal element with two tabs: one for login and one for register. Use CSS to style the modal as an overlay that appears when authentication is required. Ensure the modal is hidden by default and can be toggled.",
            "status": "done",
            "testStrategy": "Open the app and verify the modal appears with login and register tabs visible.",
            "updatedAt": "2025-10-13T21:27:24.151Z"
          },
          {
            "id": 2,
            "title": "Add form fields for login and register",
            "description": "Implement input fields for email, password, and username in the respective tabs.",
            "dependencies": [],
            "details": "In the login tab, add fields for email and password. In the register tab, add fields for email, password, and username. Include submit buttons for each form. Validate that required fields are filled before submission.",
            "status": "done",
            "testStrategy": "Switch between tabs and confirm fields are present and functional.",
            "updatedAt": "2025-10-13T21:28:10.289Z"
          },
          {
            "id": 3,
            "title": "Implement fetch API calls to backend endpoints",
            "description": "Set up logic to send POST requests to /api/login and /api/register using fetch API.",
            "dependencies": [],
            "details": "On form submission, collect form data and use fetch to call the appropriate backend endpoint. Handle the response asynchronously. Prepare for storing sessionId on success.",
            "status": "done",
            "testStrategy": "Submit forms with valid data and check network requests in browser dev tools.",
            "updatedAt": "2025-10-13T21:28:11.618Z"
          },
          {
            "id": 4,
            "title": "Handle authentication success and session storage",
            "description": "Process successful login/register responses by storing sessionId and unblocking canvas access.",
            "dependencies": [],
            "details": "Upon successful response, store the sessionId in localStorage. Hide the modal and allow access to the canvas. Check for existing sessionId on app load to skip modal if already authenticated.",
            "status": "done",
            "testStrategy": "Register and login, then refresh the page to verify session persists and canvas is accessible.",
            "updatedAt": "2025-10-13T21:28:12.950Z"
          },
          {
            "id": 5,
            "title": "Implement error handling and message display",
            "description": "Add logic to display error messages for failed authentication attempts.",
            "dependencies": [],
            "details": "On failed responses, parse error messages from the backend and display them in the modal. Clear messages on successful attempts. Ensure the modal remains open on errors.",
            "status": "done",
            "testStrategy": "Attempt login/register with invalid credentials and verify error messages appear.",
            "updatedAt": "2025-10-13T21:28:14.350Z"
          }
        ],
        "updatedAt": "2025-10-13T21:28:14.350Z"
      },
      {
        "id": 5,
        "title": "Set up WebSocket server infrastructure",
        "description": "Establish the WebSocket server with room management for canvas collaboration.",
        "details": "In websocket.lisp, create canvas-room class with thread-safe client lists. Implement connection handling, message routing for auth, cursor, object operations. Use Hunchensocket for WebSocket acceptor. Add functions for broadcasting messages to room members.",
        "testStrategy": "Start server and connect via browser console WebSocket. Send test messages and verify routing and broadcasting. Check room creation and client addition/removal.",
        "priority": "high",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Hunchensocket WebSocket acceptor",
            "description": "Initialize the WebSocket server using Hunchensocket library in websocket.lisp.",
            "dependencies": [],
            "details": "Configure Hunchensocket to create a WebSocket acceptor that listens on a specified port, handling the basic setup for WebSocket connections.",
            "status": "pending",
            "testStrategy": "Start the server and verify that it listens on the port without errors, using a simple connection test."
          },
          {
            "id": 2,
            "title": "Create canvas-room class with thread-safe client lists",
            "description": "Define the canvas-room class to manage rooms for canvas collaboration.",
            "dependencies": [],
            "details": "In websocket.lisp, implement a canvas-room class that includes thread-safe lists for managing connected clients, ensuring safe concurrent access.",
            "status": "pending",
            "testStrategy": "Instantiate the class and perform basic operations like adding/removing clients in a multi-threaded environment to check for race conditions."
          },
          {
            "id": 3,
            "title": "Implement WebSocket connection handling",
            "description": "Handle client connections and disconnections for the WebSocket server.",
            "dependencies": [],
            "details": "Add logic to accept incoming WebSocket connections, associate them with canvas rooms, and manage client addition/removal from room lists upon connect/disconnect.",
            "status": "pending",
            "testStrategy": "Connect multiple clients via browser console and verify they are added to the room; disconnect and check removal."
          },
          {
            "id": 4,
            "title": "Implement message routing for auth, cursor, and object operations",
            "description": "Set up routing for different types of WebSocket messages.",
            "dependencies": [],
            "details": "In websocket.lisp, create handlers for message types including authentication, cursor updates, and object operations, parsing incoming messages and dispatching to appropriate functions.",
            "status": "pending",
            "testStrategy": "Send test messages of each type from a client and verify they are routed correctly, logging the handling process."
          },
          {
            "id": 5,
            "title": "Add broadcasting functions for room members",
            "description": "Implement functions to broadcast messages to all clients in a room.",
            "dependencies": [],
            "details": "Create utility functions in websocket.lisp that iterate over the thread-safe client lists in a canvas-room and send messages to all connected members.",
            "status": "pending",
            "testStrategy": "Connect multiple clients to a room, send a broadcast message, and verify all clients receive it via console logs."
          }
        ],
        "updatedAt": "2025-10-13T21:25:01.037Z"
      },
      {
        "id": 6,
        "title": "Implement canvas rendering with PixiJS",
        "description": "Set up the PixiJS application for the infinite canvas with basic rendering.",
        "details": "In canvas.js, initialize PIXI.Application with full viewport. Create Container for world space. Implement grid rendering at 50px intervals. Set up event listeners for mouse interactions. Define screenToWorld and worldToScreen conversion functions.",
        "testStrategy": "Load canvas, verify PixiJS renders grid correctly. Check coordinate conversions with console logs. Ensure canvas fills viewport without scrollbars.",
        "priority": "high",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize PIXI.Application with full viewport",
            "description": "Set up the PIXI.Application instance to fill the entire viewport without scrollbars.",
            "dependencies": [],
            "details": "In canvas.js, create a new PIXI.Application with options for width and height set to window.innerWidth and window.innerHeight, and append its view to the document body. Ensure it resizes dynamically with window resize events.",
            "status": "pending",
            "testStrategy": "Load the canvas and verify that PixiJS application renders and fills the viewport completely without any scrollbars appearing."
          },
          {
            "id": 2,
            "title": "Create Container for world space",
            "description": "Establish a PIXI.Container to represent the infinite world space for objects.",
            "dependencies": [],
            "details": "After initializing the PIXI.Application, create a new PIXI.Container instance and add it to the application's stage. This container will hold all world-space objects and transformations.",
            "status": "pending",
            "testStrategy": "Check that the container is added to the stage and can hold child objects by adding a test sprite and confirming it renders."
          },
          {
            "id": 3,
            "title": "Implement grid rendering at 50px intervals",
            "description": "Render a visual grid on the canvas to aid in object placement and navigation.",
            "dependencies": [],
            "details": "In the world container, create PIXI.Graphics to draw horizontal and vertical lines at 50px intervals in world coordinates. Update the grid rendering on zoom and pan events to maintain visibility.",
            "status": "pending",
            "testStrategy": "Zoom and pan the canvas, verify the grid lines appear at correct 50px intervals and adjust dynamically with transformations."
          },
          {
            "id": 4,
            "title": "Set up event listeners for mouse interactions",
            "description": "Add mouse event handlers for basic interactions like clicking and dragging.",
            "dependencies": [],
            "details": "Attach event listeners to the PIXI.Application view for 'mousedown', 'mousemove', and 'mouseup' events. Store mouse positions and states to handle interactions such as panning or selecting.",
            "status": "pending",
            "testStrategy": "Click and drag on the canvas, use console logs to verify that mouse events are captured and positions are recorded accurately."
          },
          {
            "id": 5,
            "title": "Define screenToWorld and worldToScreen conversion functions",
            "description": "Implement utility functions to convert between screen and world coordinates.",
            "dependencies": [],
            "details": "Create functions screenToWorld(x, y) and worldToScreen(x, y) that account for the world container's position, scale, and rotation. Use these for accurate object placement and interaction in world space.",
            "status": "pending",
            "testStrategy": "Use console logs to test coordinate conversions by logging screen positions and their world equivalents, ensuring accuracy during zoom and pan."
          }
        ],
        "updatedAt": "2025-10-13T21:25:02.354Z"
      },
      {
        "id": 7,
        "title": "Implement pan and zoom functionality",
        "description": "Add pan and zoom controls to the canvas for navigation.",
        "details": "In canvas.js, handle middle-click or Alt+left-click drag for pan. Implement mouse wheel zoom with cursor centering, range 0.1x to 10x. Update viewport tracking. Ensure 60 FPS performance using requestAnimationFrame.",
        "testStrategy": "Test pan with middle-click and Alt+drag, verify smooth movement. Zoom in/out with wheel, check cursor centering and FPS via DevTools. Confirm no frame drops with rapid interactions.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up event listeners for pan and zoom",
            "description": "Initialize event listeners in canvas.js for mouse events to handle pan and zoom interactions.",
            "dependencies": [],
            "details": "Add event listeners for mousedown, mousemove, mouseup, and wheel events on the canvas element. Track mouse state variables like isPanning, lastMouseX, lastMouseY, and zoomLevel. Ensure listeners are attached when the canvas is initialized.",
            "status": "done",
            "testStrategy": "Verify that event listeners are attached by checking console logs on mouse interactions.",
            "updatedAt": "2025-10-13T21:27:39.201Z"
          },
          {
            "id": 2,
            "title": "Implement pan functionality",
            "description": "Handle middle-click or Alt+left-click drag to pan the canvas view.",
            "dependencies": [],
            "details": "In the mousedown event, check for middle button or Alt+left-click to set isPanning to true and record initial mouse position. In mousemove, if isPanning, calculate delta movement and update the viewport offset. Reset on mouseup. Prevent default drag behavior.",
            "status": "done",
            "testStrategy": "Test middle-click drag and Alt+left-click drag to ensure the canvas pans smoothly without selecting text or other elements.",
            "updatedAt": "2025-10-13T21:28:15.758Z"
          },
          {
            "id": 3,
            "title": "Implement zoom functionality",
            "description": "Add mouse wheel zoom with cursor centering and enforce zoom range from 0.1x to 10x.",
            "dependencies": [],
            "details": "In the wheel event, calculate zoom factor based on deltaY, clamp between 0.1 and 10. Adjust zoom level and recompute viewport to center on cursor position. Use transform or scale on the canvas rendering context. Update zoomLevel variable.",
            "status": "done",
            "testStrategy": "Scroll mouse wheel in and out, check that zoom scales from 0.1x to 10x and centers on cursor. Verify zoom stops at limits.",
            "updatedAt": "2025-10-13T21:28:17.092Z"
          },
          {
            "id": 4,
            "title": "Update viewport tracking",
            "description": "Maintain and update viewport properties like offset and zoom level for accurate rendering.",
            "dependencies": [],
            "details": "Create a viewport object with properties: offsetX, offsetY, zoom. Update these in pan and zoom handlers. Use these to transform world coordinates to screen coordinates in rendering functions. Ensure viewport is reset or initialized properly.",
            "status": "done",
            "testStrategy": "After pan and zoom, inspect viewport values and confirm they match expected changes based on mouse movements.",
            "updatedAt": "2025-10-13T21:28:18.386Z"
          },
          {
            "id": 5,
            "title": "Optimize for 60 FPS performance",
            "description": "Ensure smooth performance using requestAnimationFrame for updates.",
            "dependencies": [],
            "details": "Wrap pan and zoom updates in requestAnimationFrame to limit to 60 FPS. Debounce rapid events if necessary. Profile with DevTools to confirm no frame drops during interactions. Optimize rendering by only updating changed parts if possible.",
            "status": "done",
            "testStrategy": "Use DevTools Performance tab to record interactions, verify frame rate stays at 60 FPS with no drops during rapid pan and zoom.",
            "updatedAt": "2025-10-13T21:28:20.031Z"
          }
        ],
        "updatedAt": "2025-10-13T21:28:20.031Z"
      },
      {
        "id": 8,
        "title": "Implement object creation",
        "description": "Enable creation of rectangles and circles on the canvas via click-and-drag.",
        "details": "In canvas.js, add tool modes for rectangle ('R') and circle ('C'). On mouse down, start creation; on mouse up, finalize object with properties (id, type, x, y, width/height/radius, color). Use PIXI.Graphics for rendering. Generate unique IDs.",
        "testStrategy": "Switch to rectangle tool, click-drag to create. Repeat for circle. Verify objects appear with correct properties. Check keyboard shortcuts switch modes.",
        "priority": "high",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Add tool modes for rectangle and circle creation",
            "description": "Implement tool modes in canvas.js to switch between rectangle ('R') and circle ('C') creation modes using keyboard shortcuts.",
            "dependencies": [],
            "details": "Modify the canvas.js file to include a mode variable that can be set to 'rectangle' or 'circle' based on key presses 'R' and 'C'. Ensure the mode affects the creation behavior.",
            "status": "pending",
            "testStrategy": "Press 'R' and 'C' keys and verify the mode changes via console logs or UI indicators."
          },
          {
            "id": 2,
            "title": "Handle mouse down event to start object creation",
            "description": "Add event listener for mouse down to initiate the creation of a rectangle or circle based on the current tool mode.",
            "dependencies": [],
            "details": "In canvas.js, attach a mousedown event listener to the canvas. On mousedown, record the starting point (x, y) and create a temporary PIXI.Graphics object for previewing the shape being drawn.",
            "status": "pending",
            "testStrategy": "Switch to rectangle mode, click on canvas, and check if a temporary graphic appears at the click position."
          },
          {
            "id": 3,
            "title": "Handle mouse move event to update shape during drag",
            "description": "Implement mouse move event to dynamically update the dimensions of the rectangle or circle as the user drags.",
            "dependencies": [],
            "details": "Add a mousemove event listener that, while dragging, calculates width/height for rectangle or radius for circle based on current mouse position and starting point, then redraws the temporary PIXI.Graphics object.",
            "status": "pending",
            "testStrategy": "Start dragging after mousedown, move mouse, and verify the shape resizes in real-time on the canvas."
          },
          {
            "id": 4,
            "title": "Handle mouse up event to finalize object creation",
            "description": "On mouse up, finalize the object by assigning properties and adding it to the canvas permanently.",
            "dependencies": [],
            "details": "In the mouseup event listener, remove the temporary graphic, create a new PIXI.Graphics object with final dimensions, assign properties like id, type, x, y, width/height/radius, color, and add it to the canvas stage.",
            "status": "pending",
            "testStrategy": "Complete a click-drag action, release mouse, and confirm a permanent object appears with correct size and properties."
          },
          {
            "id": 5,
            "title": "Implement unique ID generation for objects",
            "description": "Add functionality to generate unique IDs for each created object to ensure no duplicates.",
            "dependencies": [],
            "details": "Create a function in canvas.js that generates unique IDs, perhaps using a counter or timestamp-based method. Assign this ID to each new object upon finalization in the mouseup handler.",
            "status": "pending",
            "testStrategy": "Create multiple objects and verify each has a unique ID by inspecting object properties or logging them."
          }
        ],
        "updatedAt": "2025-10-14T02:52:42.112Z"
      },
      {
        "id": 9,
        "title": "Implement object manipulation",
        "description": "Add selection, dragging, multi-select, and deletion for objects.",
        "details": "In canvas.js, implement select mode ('V') for clicking to select, Shift+click for multi-select. Enable dragging selected objects. Add Delete key handler for removal. Update object positions in world coordinates.",
        "testStrategy": "Create objects, select single/multiple, drag to new positions. Verify positions update correctly. Delete selected objects and confirm removal.",
        "priority": "high",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement select mode activation",
            "description": "Add keyboard shortcut 'V' to activate select mode in canvas.js.",
            "dependencies": [],
            "details": "Modify canvas.js to listen for the 'V' key press event and set the current tool mode to 'select'. Ensure this mode allows for object selection without creating new objects.",
            "status": "pending",
            "testStrategy": "Press 'V' key and verify select mode is activated, preventing object creation."
          },
          {
            "id": 2,
            "title": "Implement single object selection",
            "description": "Enable clicking on objects to select them in select mode.",
            "dependencies": [],
            "details": "In canvas.js, add mouse click event handler in select mode to detect clicks on objects using PIXI's hit detection. Mark the clicked object as selected and visually indicate selection (e.g., highlight).",
            "status": "pending",
            "testStrategy": "Create an object, enter select mode, click on it, and verify it is selected and highlighted."
          },
          {
            "id": 3,
            "title": "Implement multi-select with Shift+click",
            "description": "Allow selecting multiple objects by holding Shift and clicking.",
            "dependencies": [],
            "details": "Extend the click handler in canvas.js to check for Shift key during click. If Shift is held, add the clicked object to the selection without deselecting others. Maintain a list of selected objects.",
            "status": "pending",
            "testStrategy": "Create multiple objects, select one, then Shift+click another, and verify both are selected."
          },
          {
            "id": 4,
            "title": "Implement dragging of selected objects",
            "description": "Enable dragging selected objects to new positions.",
            "dependencies": [],
            "details": "In canvas.js, add mouse down, move, and up event handlers for dragging. On mouse down on selected objects, initiate drag. Update positions during move and finalize on mouse up, converting screen coordinates to world coordinates.",
            "status": "pending",
            "testStrategy": "Select an object, drag it to a new position, and verify the position updates correctly in world coordinates."
          },
          {
            "id": 5,
            "title": "Implement deletion of selected objects",
            "description": "Add Delete key handler to remove selected objects.",
            "dependencies": [],
            "details": "In canvas.js, add a keydown event listener for the Delete key. When pressed, remove all selected objects from the canvas and update the object list. Ensure positions are handled in world coordinates if needed.",
            "status": "pending",
            "testStrategy": "Select one or more objects, press Delete key, and verify they are removed from the canvas."
          }
        ],
        "updatedAt": "2025-10-14T02:52:43.333Z"
      },
      {
        "id": 10,
        "title": "Implement WebSocket client",
        "description": "Develop the client-side WebSocket connection and message handling.",
        "details": "In websocket.js, create WebSocketClient class to connect to ws://host/ws/{canvas-id}. Handle auth message on connect. Implement send/receive for cursor, object operations. Add reconnection logic and throttling for cursor updates (30/sec).",
        "testStrategy": "Connect to server, send auth, verify auth-success. Send test object-create message and check server response. Test reconnection after disconnect.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create WebSocketClient class structure",
            "description": "Set up the basic WebSocketClient class in websocket.js with constructor and initial properties.",
            "dependencies": [],
            "details": "In websocket.js, define a WebSocketClient class with a constructor that takes host, canvasId, and authToken. Initialize properties like ws (WebSocket instance), isConnected (boolean), and message handlers. Ensure the class is exportable for use in other modules.",
            "status": "done",
            "testStrategy": "Basic verification: run and ensure no errors.",
            "updatedAt": "2025-10-13T21:27:55.378Z"
          },
          {
            "id": 2,
            "title": "Implement WebSocket connection and authentication",
            "description": "Establish the WebSocket connection to the server and handle the initial authentication message.",
            "dependencies": [],
            "details": "In the WebSocketClient class, add a connect() method that creates a new WebSocket connection to ws://host/ws/{canvas-id}. On connection open, send an auth message with the authToken. Listen for auth-success or auth-failure responses and handle accordingly, updating connection status.",
            "status": "done",
            "testStrategy": "Connect to a test server, verify WebSocket opens, send auth message, and check for auth-success response.",
            "updatedAt": "2025-10-13T21:28:21.428Z"
          },
          {
            "id": 3,
            "title": "Implement message sending and receiving for cursor and object operations",
            "description": "Add methods to send and receive messages for cursor updates and object manipulations.",
            "dependencies": [],
            "details": "In the WebSocketClient class, implement sendMessage() method to send JSON messages for cursor positions and object operations (create, update, delete). Add onMessage handler to parse incoming messages and dispatch to appropriate handlers for cursor updates and object changes. Ensure messages are properly formatted as JSON.",
            "status": "done",
            "testStrategy": "Send a test cursor update message and verify it's received. Send an object-create message and check the response.",
            "updatedAt": "2025-10-13T21:28:22.890Z"
          },
          {
            "id": 4,
            "title": "Add reconnection logic",
            "description": "Implement automatic reconnection when the WebSocket connection is lost.",
            "dependencies": [],
            "details": "In the WebSocketClient class, add an onClose handler that attempts to reconnect after a delay (e.g., exponential backoff). Track reconnection attempts and stop after a maximum number. Re-authenticate upon successful reconnection. Provide a method to manually disconnect.",
            "status": "done",
            "testStrategy": "Disconnect the WebSocket manually, verify automatic reconnection occurs, and auth is re-sent.",
            "updatedAt": "2025-10-13T21:28:24.212Z"
          },
          {
            "id": 5,
            "title": "Implement throttling for cursor updates",
            "description": "Add throttling to limit cursor update messages to 30 per second.",
            "dependencies": [],
            "details": "In the WebSocketClient class, implement a throttling mechanism using a timer or library to ensure cursor position updates are sent at most 30 times per second. Buffer or drop excess updates. Integrate this into the cursor sending logic to prevent flooding the server.",
            "status": "done",
            "testStrategy": "Simulate rapid cursor movements and verify that no more than 30 updates are sent per second.",
            "updatedAt": "2025-10-13T21:28:25.505Z"
          }
        ],
        "updatedAt": "2025-10-13T21:28:25.505Z"
      },
      {
        "id": 11,
        "title": "Implement real-time synchronization for objects",
        "description": "Sync object creation, updates, and deletions across all connected clients.",
        "details": "Integrate WebSocketClient with CanvasManager: on local object create/update/delete, send message. On receive, update canvas. Broadcast via server. Use last-write-wins for conflicts.",
        "testStrategy": "Open two browser windows, create/update/delete objects in one, verify immediate sync in the other. Check latency <100ms with network tools.",
        "priority": "high",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate WebSocketClient for sending object change messages",
            "description": "Modify CanvasManager to send WebSocket messages whenever an object is created, updated, or deleted locally.",
            "dependencies": [],
            "details": "In CanvasManager, hook into object creation, update, and deletion events to serialize the object data (id, type, position, etc.) into a JSON message and send it via WebSocketClient to the server.",
            "status": "pending",
            "testStrategy": "Use browser console to verify messages are sent on object actions, check network tab for WebSocket frames."
          },
          {
            "id": 2,
            "title": "Implement handling of incoming WebSocket messages for canvas updates",
            "description": "Update CanvasManager to listen for incoming WebSocket messages and apply the received object changes to the canvas.",
            "dependencies": [],
            "details": "Add a WebSocket message handler in CanvasManager that parses incoming JSON messages for object create, update, or delete operations, and updates the local canvas state accordingly, ensuring UI reflects changes.",
            "status": "pending",
            "testStrategy": "Send manual WebSocket messages from server and observe canvas updates in real-time without local actions."
          },
          {
            "id": 3,
            "title": "Set up server-side broadcasting of object change messages",
            "description": "Implement server logic to broadcast received WebSocket messages to all connected clients except the sender.",
            "dependencies": [],
            "details": "In the server code, upon receiving a message from a client, relay it to all other connected WebSocket clients, ensuring efficient broadcasting without echoing back to the originator.",
            "status": "pending",
            "testStrategy": "Connect multiple clients, perform an action on one, and verify the message is received by others via server logs or client-side logs."
          },
          {
            "id": 4,
            "title": "Implement last-write-wins conflict resolution",
            "description": "Add logic to handle concurrent updates by prioritizing the latest timestamped change.",
            "dependencies": [],
            "details": "Attach timestamps to all object change messages. In the message handler, compare timestamps on conflicts (e.g., simultaneous updates to the same object) and apply the most recent one, discarding older changes.",
            "status": "pending",
            "testStrategy": "Simulate conflicts by rapidly updating the same object from two clients and verify only the latest change persists."
          },
          {
            "id": 5,
            "title": "Test end-to-end real-time synchronization",
            "description": "Perform comprehensive testing to ensure synchronization works across clients with low latency.",
            "dependencies": [],
            "details": "Open multiple browser windows, create, update, and delete objects in one, and verify immediate reflection in others. Use network tools to confirm latency under 100ms and handle edge cases like disconnections.",
            "status": "pending",
            "testStrategy": "Follow the test strategy from the parent task: Open two browser windows, perform actions in one, check sync in the other, measure latency."
          }
        ],
        "updatedAt": "2025-10-14T02:52:44.596Z"
      },
      {
        "id": 12,
        "title": "Implement cursor synchronization",
        "description": "Enable real-time cursor position sharing with presence.",
        "details": "In websocket.js, send cursor updates on mouse move (throttled). On receive, render remote cursors with username labels in unique colors. Update presence list on connect/disconnect.",
        "testStrategy": "Move mouse in one window, verify cursor appears in others with <50ms latency. Check presence list updates on join/leave.",
        "priority": "medium",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up mouse move event listener with throttling",
            "description": "Implement a throttled mouse move event listener in the canvas to capture cursor positions efficiently.",
            "dependencies": [],
            "details": "In canvas.js, add an event listener for mousemove events on the canvas element. Use a throttling mechanism (e.g., lodash.throttle or custom implementation) to limit updates to every 50ms or less to avoid excessive sending.",
            "status": "pending",
            "testStrategy": "Move mouse rapidly and verify that position updates are throttled, not sent on every pixel movement."
          },
          {
            "id": 2,
            "title": "Send cursor position updates via WebSocket",
            "description": "Modify websocket.js to send cursor position data on throttled mouse moves.",
            "dependencies": [],
            "details": "In websocket.js, on each throttled mouse move, send a message containing the current cursor x, y coordinates, username, and a unique color identifier via the WebSocket connection.",
            "status": "pending",
            "testStrategy": "Move mouse and use browser dev tools to inspect WebSocket messages, confirming position data is sent with username and color."
          },
          {
            "id": 3,
            "title": "Receive and parse cursor updates from WebSocket",
            "description": "Handle incoming WebSocket messages for cursor positions from other users.",
            "dependencies": [],
            "details": "In websocket.js, add a message handler to receive cursor update messages, parse the JSON payload to extract position, username, and color, and store or update a list of remote cursors.",
            "status": "pending",
            "testStrategy": "Open multiple browser windows, move mouse in one, and check console logs in others for received messages with correct data."
          },
          {
            "id": 4,
            "title": "Render remote cursors with username labels and unique colors",
            "description": "Display remote cursors on the canvas with labels and colors.",
            "dependencies": [],
            "details": "In canvas.js, for each remote cursor in the list, render a cursor icon (e.g., a small arrow or dot) at the received position, add a text label with the username, and apply the unique color. Update positions in real-time as new messages arrive.",
            "status": "pending",
            "testStrategy": "With multiple users, move cursors and verify they appear in other windows with labels, colors, and <50ms latency using browser performance tools."
          },
          {
            "id": 5,
            "title": "Update presence list on user connect and disconnect",
            "description": "Maintain and display a list of online users based on WebSocket connections.",
            "dependencies": [],
            "details": "In websocket.js, on WebSocket open (connect), send a join message with username. On close (disconnect), send a leave message. Maintain a presence list and update the UI (e.g., a sidebar) to show current online users.",
            "status": "pending",
            "testStrategy": "Open/close browser windows and check that the presence list updates immediately on join/leave, reflecting accurate user counts."
          }
        ],
        "updatedAt": "2025-10-14T02:52:45.813Z"
      },
      {
        "id": 13,
        "title": "Implement state persistence",
        "description": "Save and load canvas state to/from SQLite database.",
        "details": "In canvas-state.lisp, implement save function with debounced updates (500ms). Load state on connection via GET /api/canvas/state. Store as JSON blob in canvas_states table.",
        "testStrategy": "Create objects, refresh page, verify state persists. Disconnect all users, reconnect, check state loads. Confirm debouncing prevents excessive saves.",
        "priority": "high",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Create canvas_states table in SQLite",
            "description": "Set up the database schema for storing canvas state as JSON blobs.",
            "dependencies": [],
            "details": "Create a table named 'canvas_states' with columns: id (primary key, auto-increment), state_json (text for JSON blob), and timestamp (datetime for last update). Ensure the table is created in the SQLite database used by the application.",
            "status": "pending",
            "testStrategy": "Run a database query to verify the table exists with correct columns."
          },
          {
            "id": 2,
            "title": "Implement debounced save function in canvas-state.lisp",
            "description": "Develop a function to save the current canvas state to the database with debouncing to prevent excessive saves.",
            "dependencies": [],
            "details": "In canvas-state.lisp, create a save-canvas-state function that serializes the canvas state to JSON and inserts/updates it in the canvas_states table. Implement debouncing using a timer (500ms delay) to batch saves and avoid overloading the database on rapid changes.",
            "status": "pending",
            "testStrategy": "Simulate rapid canvas changes and check that saves occur only after 500ms of inactivity, verifying database entries."
          },
          {
            "id": 3,
            "title": "Implement load state function for GET /api/canvas/state",
            "description": "Create a backend endpoint to retrieve and return the persisted canvas state.",
            "dependencies": [],
            "details": "In canvas-state.lisp, add a handler for GET /api/canvas/state that queries the canvas_states table for the latest state JSON, parses it, and returns it in the response. Handle cases where no state exists (return empty or default state).",
            "status": "pending",
            "testStrategy": "Use curl or a browser to call the endpoint and verify it returns the correct JSON state or default when no data is present."
          },
          {
            "id": 4,
            "title": "Integrate saving on canvas state changes",
            "description": "Connect the save function to trigger whenever the canvas state is modified.",
            "dependencies": [],
            "details": "Modify the canvas manipulation code (e.g., in canvas.js or related Lisp functions) to call the debounced save function whenever objects are created, moved, or deleted. Ensure the state includes all necessary object properties for accurate restoration.",
            "status": "pending",
            "testStrategy": "Create and modify objects on the canvas, then check the database to confirm the state is saved correctly after debouncing."
          },
          {
            "id": 5,
            "title": "Integrate loading on client connection",
            "description": "Ensure the canvas state is loaded from the database when a user connects or refreshes the page.",
            "dependencies": [],
            "details": "In the client-side code (e.g., canvas.js), add logic to fetch the state via GET /api/canvas/state on page load or connection, and populate the canvas with the loaded objects. Handle authentication if required, and merge or replace existing state appropriately.",
            "status": "pending",
            "testStrategy": "Refresh the page after making changes, verify that the canvas reloads with the persisted state. Test with multiple users or disconnections."
          }
        ],
        "updatedAt": "2025-10-14T02:52:47.049Z"
      },
      {
        "id": 14,
        "title": "Implement user interface components",
        "description": "Build the UI for toolbar, presence list, and status bar.",
        "details": "In HTML/CSS/JS, create toolbar for tools (select, rectangle, circle), color picker. Add presence list in top-right. Implement status bar for tool, position, zoom. Ensure dark theme consistency.",
        "testStrategy": "Verify toolbar switches tools, presence shows online users, status updates correctly. Check UI doesn't obstruct canvas and is responsive.",
        "priority": "medium",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Create toolbar with tool buttons and color picker",
            "description": "Design and implement the toolbar containing buttons for select, rectangle, and circle tools, along with a color picker component.",
            "dependencies": [],
            "details": "In HTML, add a div for the toolbar. Use CSS for styling with dark theme. In JS, create buttons for each tool and a color input. Attach event listeners to switch tool modes in canvas.js.",
            "status": "pending",
            "testStrategy": "Click each tool button and verify the active tool changes. Select a color and confirm it applies to new objects."
          },
          {
            "id": 2,
            "title": "Implement presence list in top-right corner",
            "description": "Build the presence list component to display online users in the top-right area of the interface.",
            "dependencies": [],
            "details": "Add a div in the top-right of the page layout. Use JS to fetch and display user list from backend. Style with dark theme CSS. Update list on user join/leave events.",
            "status": "pending",
            "testStrategy": "Simulate multiple users logging in and verify the list updates in real-time. Check positioning doesn't overlap with other UI elements."
          },
          {
            "id": 3,
            "title": "Develop status bar for tool, position, and zoom info",
            "description": "Create the status bar at the bottom to show current tool, mouse position, and zoom level.",
            "dependencies": [],
            "details": "Insert a status bar div at the bottom of the page. In JS, update text content based on current tool, mouse coordinates, and zoom factor. Ensure responsive design and dark theme.",
            "status": "pending",
            "testStrategy": "Switch tools and move mouse; verify status bar updates accurately. Zoom in/out and check zoom display changes."
          },
          {
            "id": 4,
            "title": "Apply dark theme consistency across UI components",
            "description": "Ensure all toolbar, presence list, and status bar elements adhere to the dark theme color scheme.",
            "dependencies": [],
            "details": "Define CSS variables for dark theme colors (e.g., background, text, borders). Apply these to all UI elements created. Test for consistency in visibility and aesthetics.",
            "status": "pending",
            "testStrategy": "Inspect UI in browser dev tools for color consistency. Verify readability and contrast in dark mode."
          },
          {
            "id": 5,
            "title": "Integrate UI components into main layout",
            "description": "Position and integrate the toolbar, presence list, and status bar into the overall page layout without obstructing the canvas.",
            "dependencies": [],
            "details": "Use CSS flexbox or grid to arrange components: toolbar top-left, presence top-right, status bottom. Ensure canvas remains central and unobstructed. Make layout responsive.",
            "status": "pending",
            "testStrategy": "Resize browser window and confirm UI elements adjust properly. Verify canvas interaction isn't blocked by UI overlays."
          }
        ],
        "updatedAt": "2025-10-14T02:52:48.264Z"
      },
      {
        "id": 15,
        "title": "Deploy application to Fly.io",
        "description": "Containerize and deploy the application to Fly.io for public access.",
        "details": "Create Dockerfile as specified. Build frontend and backend. Configure fly.toml. Use fly deploy. Ensure health check endpoint.",
        "testStrategy": "Access deployed URL, test full flow: register, login, create objects, sync with another user. Verify performance and no errors in logs.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Dockerfile and containerize the application",
            "description": "Develop a Dockerfile to containerize both the frontend and backend components of the application, ensuring all dependencies are included and the app can run in a containerized environment.",
            "dependencies": [],
            "details": "Use a Debian base image, install necessary tools like SBCL, Quicklisp, Node.js for Vite build. Copy backend and frontend code, run builds for both, expose necessary ports (e.g., 8080 for backend), and set the entrypoint to start the server. Ensure the Dockerfile follows best practices for multi-stage builds if applicable.",
            "status": "pending",
            "testStrategy": "Build the Docker image locally and run it to verify the application starts without errors, checking logs for successful initialization."
          },
          {
            "id": 2,
            "title": "Configure Fly.io deployment settings",
            "description": "Set up the fly.toml configuration file with necessary settings for deploying the containerized application to Fly.io, including app name, region, and health checks.",
            "dependencies": [],
            "details": "Create or edit fly.toml to specify the app name, source directory, build command (if needed), services with internal port mapping, health check endpoint (e.g., /health), and any environment variables required for the application. Ensure compatibility with Fly.io's deployment requirements.",
            "status": "pending",
            "testStrategy": "Validate the fly.toml file using Fly CLI commands like 'fly config validate' to ensure no syntax errors and proper configuration."
          },
          {
            "id": 3,
            "title": "Deploy to Fly.io and verify functionality",
            "description": "Execute the deployment to Fly.io using the configured settings and perform end-to-end testing to ensure the application is publicly accessible and fully functional.",
            "dependencies": [],
            "details": "Run 'fly deploy' to push the containerized app to Fly.io. Monitor the deployment logs for success. Once deployed, access the public URL and test the full application flow including user registration, login, canvas object creation, and synchronization between users. Check application logs for any errors.",
            "status": "pending",
            "testStrategy": "Access the deployed URL and perform manual tests: register a user, log in, create and manipulate canvas objects, verify real-time sync with another user session. Monitor performance and check for no errors in Fly.io logs or console."
          }
        ],
        "updatedAt": "2025-10-14T02:52:04.930Z"
      },
      {
        "id": 16,
        "title": "Phase 0: Library Validation & Architecture Proof",
        "description": "Validate cl-fast-ecs framework works as expected. Test ECS component/system patterns, ball spawning with custom physics, and performance benchmarking with 500 balls at 60 Hz. Create database schema for physics tables.",
        "details": "**Objective**: Prove the technical approach before full implementation.\n\n**Key Deliverables**:\n1. Install cl-fast-ecs from zip to ~/quicklisp/local-projects/ (NOT from Quicklisp)\n2. Create standalone ECS test: spawn 500 balls with custom physics (position, velocity, acceleration components)\n3. Benchmark performance locally (target: <16ms per frame)\n4. Verify ECS component definitions (ecs:define-component) and systems (ecs:define-system) work\n5. Create database schema SQL files for physics tables (physics_canvas_settings, physics_components)\n6. Optional: Create simple custom ghost predictor test (no Matter.js needed)\n\n**Success Criteria**:\n- cl-fast-ecs loads successfully from local-projects directory\n- 500 balls simulate at 60 Hz using ECS systems with <16ms frame time\n- Component and system macros work as expected\n- Database schema files created and validated\n\n**Files to Create**:\n- backend/tests/ecs-physics-benchmark.lisp (ECS-based physics test)\n- backend/db/physics-schema.sql\n- frontend/tests/simple-predictor-test.html (optional)",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Phase 1: Backend Physics Core",
        "description": "Implement the authoritative physics simulation backend using cl-fast-ecs. Create ECS storage per canvas, define components (position, velocity, acceleration, ball, force-field, block), implement custom physics systems, fixed timestep background thread, and WebSocket message handlers.",
        "details": "**Objective**: Build server-authoritative ECS-based physics simulation infrastructure.\n\n**Key Deliverables**:\n\n1. **ECS Storage Management** (backend/src/physics-ecs.lisp):\n   - Create `*physics-canvases*` hash table (canvas-id → ecs-storage)\n   - Implement `init-canvas-physics`, `get-canvas-ecs-storage`, `destroy-canvas-physics`\n   - Configure gravity, simulation rate from database settings\n\n2. **Component Definitions** (backend/src/physics-components.lisp):\n   - Define components using `ecs:define-component`:\n     - `position` (x, y)\n     - `velocity` (vx, vy)\n     - `acceleration` (ax, ay)\n     - `ball` (radius, mass, restitution)\n     - `force-field` (field-type, strength, radius, direction)\n     - `block` (width, height)\n     - `sleeping` (tag component)\n\n3. **Physics Systems** (backend/src/physics-systems.lisp):\n   - `apply-forces-system` - Apply force fields to nearby balls\n   - `apply-acceleration-system` - Update velocity from acceleration\n   - `apply-velocity-system` - Update position from velocity\n   - `collision-system` - Circle-circle and circle-rectangle collision detection\n   - `check-sleeping-system` - Mark/unmark bodies as sleeping\n\n4. **Fixed Timestep Loop** (backend/src/physics-loop.lisp):\n   - Background thread per canvas running at 60 Hz\n   - Call `ecs:run-systems` with dt parameter\n   - Delta broadcasting at 20 Hz (every 3rd tick)\n\n5. **WebSocket Integration** (backend/src/websocket-adapter.lisp):\n   - Add handlers: `physics-spawn-ball`, `physics-toggle-fan`, `physics-adjust-gravity`\n   - Use `ecs:make-object` to create entities\n   - Integrate with existing `handle-ws-message` dispatch\n\n6. **Database Setup**:\n   - Execute physics-schema.sql to create tables\n   - Implement save/load for physics settings and components\n\n**Success Criteria**:\n- Backend simulates 500 balls at 60 Hz using ECS systems\n- Custom physics formulas (gravity, forces, collisions) work correctly\n- Delta updates broadcast to clients at 20 Hz\n- Physics state persists across server restarts",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          16
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Phase 2: Frontend Integration",
        "description": "Implement simple client-side ghost prediction (no physics engine needed) and integrate with existing PixiJS canvas. Create custom ghost predictor, extend CanvasManager for physics rendering, add WebSocket message handling, and build UI controls for spawning balls and toggling fans.",
        "details": "**Objective**: Create responsive client-side experience with simple custom prediction.\n\n**Key Deliverables**:\n\n1. **Simple Ghost Predictor** (frontend/src/physics-predictor.js):\n   - NO physics engine needed - just custom position + velocity prediction\n   - `spawnGhost(ghostId, x, y, vx, vy)` - create ghost with initial velocity\n   - `step(dt)` - simple update: `ghost.x += ghost.vx * dt; ghost.y += ghost.vy * dt`\n   - `removeGhost(ghostId)` - remove ghost after server confirmation\n   - Optional: add simple gravity (`ghost.vy += 9.8 * dt`)\n   - Optional: add boundary bounce for realism\n\n2. **Physics Renderer** (frontend/src/physics-renderer.js):\n   - Extend existing CanvasManager class\n   - Render ghost balls (semi-transparent, dashed outline)\n   - Render server balls with interpolation (20 Hz → 60 FPS smoothing)\n   - Interpolation: `ball.currentX += (ball.serverX - ball.currentX) * 0.3`\n   - Render force field visualizations (fans with arrows, gravity wells)\n   - Preserve existing viewport culling and performance monitoring\n\n3. **WebSocket Message Handling** (frontend/src/websocket.js):\n   - Add cases: `physics-ball-created`, `physics-update`, `physics-fan-toggled`\n   - Handle delta updates and apply to server ball state\n   - Trigger ghost confirmation on ball creation confirmation\n\n4. **UI Controls** (frontend/index.html + physics-ui.js):\n   - \"Spawn Ball\" button (or click-to-spawn mode)\n   - Fan toggle buttons for existing fans\n   - Gravity adjustment slider (-20 to +20 m/s²)\n   - Physics stats overlay (FPS, object count, active/sleeping)\n\n**Success Criteria**:\n- Ghost balls appear instantly on client click (<5ms perceived latency)\n- Simple velocity-based prediction feels responsive\n- Server confirmation smoothly transitions ghost → server object\n- Force fields visually indicate active state\n- Maintains 60 FPS with 500 active balls",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          17
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Phase 3: Multiplayer Sync & Polish",
        "description": "Optimize real-time synchronization, implement delta compression, add bandwidth and latency monitoring, create determinism tests, and perform load testing with multiple clients and 500+ balls.",
        "details": "**Objective**: Ensure robust multiplayer experience with performance optimization.\n\n**Key Deliverables**:\n\n1. **Delta Compression Optimization**:\n   - Only send changed properties (position, velocity, rotation)\n   - Skip objects with velocity < 0.01 (sleeping)\n   - Batch deltas into single message per broadcast\n   - Measure bandwidth reduction (target: <280 KB/sec per client)\n\n2. **Monitoring & Metrics**:\n   - Extend existing LatencyMonitor for physics messages\n   - Track bandwidth per message type\n   - Add physics-specific stats: bodies active/sleeping, update rate\n   - Log high latency warnings (>100ms)\n\n3. **Determinism Testing**:\n   - Create test script that spawns identical scenarios on server\n   - Verify same initial conditions → same final state after 10 seconds\n   - Test edge cases: simultaneous spawns, rapid force field toggles\n\n4. **Load Testing**:\n   - Set up 2 clients + 500 balls scenario\n   - Measure frame times, network bandwidth, server CPU usage\n   - Identify bottlenecks and optimize hot paths\n   - Document performance results in .taskmaster/docs/\n\n5. **Error Handling**:\n   - Handle WebSocket disconnection during physics simulation\n   - Graceful degradation: disable ghost prediction if server lags\n   - Add reconnection recovery (full state sync on reconnect)\n\n**Success Criteria**:\n- Bandwidth reduced by >50% compared to full state broadcasting\n- Server maintains 60 Hz simulation with 500 balls across 2 clients\n- Determinism test passes 100% of time\n- Perceived latency <50ms for ghost spawns\n- No visual artifacts during reconnection",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          18
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Phase 4: Component System & Extensibility",
        "description": "Demonstrate extensibility by implementing gravity adjustment UI and one post-MVP component (emitter or magnet). Document the component API for future additions, perform performance profiling, and create developer documentation.",
        "details": "**Objective**: Prove architecture supports easy addition of new physics features.\n\n**Key Deliverables**:\n\n1. **Gravity Adjustment Feature**:\n   - UI slider in physics control panel (range: -20 to +20 m/s²)\n   - Backend handler: `physics-adjust-gravity` message\n   - Update global gravity in ECS acceleration system\n   - Broadcast gravity change to all clients\n   - Persist gravity setting in physics_canvas_settings table\n\n2. **Post-MVP Component** (choose one):\n   - **Emitter**: Shoots balls at interval (rate, direction, velocity)\n   - **Magnet**: Attracts/repels balls within radius (strength, polarity)\n   - Implement full backend component lifecycle\n   - Create frontend visualization and controls\n\n3. **Developer Documentation** (.taskmaster/docs/PHYSICS_COMPONENTS.md):\n   - How to add new component types\n   - Component lifecycle: creation → force application → destruction\n   - Frontend rendering guide for component visualizations\n   - Example: Step-by-step emitter implementation walkthrough\n\n4. **Performance Profiling**:\n   - Profile backend physics loop with SBCL profiler\n   - Identify most expensive operations (collision detection, force application)\n   - Document results and optimization opportunities\n   - Create performance baseline for future comparison\n\n5. **Architecture Validation**:\n   - Review: Can magnets be added in <4 hours using existing API?\n   - Review: Can custom force field shapes be added easily?\n   - Document any API gaps or friction points\n\n**Success Criteria**:\n- Gravity slider works smoothly in real-time\n- Post-MVP component fully functional (emitter shoots balls OR magnet attracts)\n- Developer docs enable new team member to add component in <1 day\n- Performance profiling identifies top 3 optimization opportunities\n- No major refactoring needed for post-MVP component",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          19
        ],
        "priority": "low",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-10-14T14:40:42.116Z",
      "updated": "2025-10-17T22:21:41.509Z",
      "description": "Tasks for master context"
    }
  },
  "perf": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement Cursor Update Batching",
        "description": "Batch cursor updates on the backend and throttle sending on the frontend to reduce network traffic and ensure <50ms latency.",
        "details": "On the backend, create a message-queue struct with cursor-batch and object-batch. Implement queue-cursor-update to add updates to the batch and flush-cursor-batch to send batched updates every 50ms. On the frontend, create a CursorThrottle class that throttles updates to max 20/sec using setInterval. Ensure batch messages include all cursor positions and latency remains <50ms.",
        "testStrategy": "Unit test the batching logic to verify updates are queued and flushed correctly. Integration test with multiple clients to measure latency and ensure it stays under 50ms. Load test with 5 concurrent users to confirm no lag.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Backend Message Queue for Cursor Batching",
            "description": "Create a backend message-queue struct that includes cursor-batch and object-batch components. Implement functions to queue cursor updates and flush batches every 50ms to reduce network traffic.",
            "dependencies": [],
            "details": "On the backend, define a message-queue struct with arrays for cursor-batch and object-batch. Implement queue-cursor-update to append updates to the cursor-batch. Implement flush-cursor-batch to send the batched updates via WebSocket or similar every 50ms using a timer. Ensure the batch includes all cursor positions and handles multiple updates efficiently.",
            "status": "done",
            "testStrategy": "Unit test the queue and flush functions to verify updates are batched and sent at the correct intervals.",
            "updatedAt": "2025-10-14T15:59:40.899Z"
          },
          {
            "id": 2,
            "title": "Implement Frontend Cursor Throttling Logic",
            "description": "Create a CursorThrottle class on the frontend to limit cursor updates to a maximum of 20 per second using setInterval, ensuring low latency.",
            "dependencies": [],
            "details": "On the frontend, develop a CursorThrottle class that uses setInterval to throttle cursor position updates to no more than 20 per second. Capture cursor movements, buffer them, and send batched updates at the throttled rate. Integrate with the backend batching to maintain overall latency under 50ms.",
            "status": "done",
            "testStrategy": "Unit test the throttling mechanism to ensure it limits updates to 20/sec and handles rapid cursor movements without exceeding the rate.",
            "updatedAt": "2025-10-14T15:59:42.195Z"
          },
          {
            "id": 3,
            "title": "Conduct Comprehensive Testing Including Latency Measurements",
            "description": "Perform unit, integration, and load testing to verify batching and throttling work correctly, with a focus on measuring and ensuring latency remains under 50ms.",
            "dependencies": [],
            "details": "Execute unit tests for backend batching and frontend throttling. Run integration tests with multiple clients to simulate real-world usage. Conduct load tests with 5 concurrent users to measure latency using tools like performance.now(). Ensure all tests confirm latency <50ms and no network overload.",
            "status": "done",
            "testStrategy": "Use automated testing frameworks for unit and integration tests; employ load testing tools to measure latency percentiles and verify compliance with <50ms requirement under various conditions.",
            "updatedAt": "2025-10-14T15:59:43.450Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down the task into backend queue implementation, frontend throttling logic, and comprehensive testing including latency measurements.",
        "updatedAt": "2025-10-14T15:59:43.450Z"
      },
      {
        "id": 2,
        "title": "Implement Delta Compression for Object Updates",
        "description": "Send only changed fields for object updates to reduce bandwidth by 60-80%.",
        "details": "On the backend, create create-object-delta function to compare old and new objects and return only changed properties like x, y, width, height, rotation, color. On the frontend, implement applyDelta method to update only the changed properties on the object. Send full object state on creation and deltas thereafter.",
        "testStrategy": "Unit test delta creation to ensure only changed fields are included. Integration test to verify deltas are applied correctly across clients. Measure bandwidth usage before and after implementation to confirm 60-80% reduction.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Backend Delta Creation Function",
            "description": "Create the create-object-delta function on the backend to compare old and new objects and return only changed properties such as x, y, width, height, rotation, and color.",
            "dependencies": [],
            "details": "On the backend, implement a function that takes old and new object states, performs a deep comparison to identify changed fields, and returns a delta object containing only the modified properties. Ensure the function handles nested objects if necessary and is efficient for real-time updates.",
            "status": "done",
            "testStrategy": "Unit test the delta creation to ensure only changed fields are included and no unchanged fields are present."
          },
          {
            "id": 2,
            "title": "Implement Frontend Delta Application and Bandwidth Testing",
            "description": "Implement the applyDelta method on the frontend to update only the changed properties on objects and measure bandwidth reduction.",
            "dependencies": [],
            "details": "On the frontend, create an applyDelta method that merges the delta into the existing object state without overwriting unchanged fields. Send full object state on creation and deltas thereafter. Conduct bandwidth measurement tests by comparing network usage before and after implementation to confirm 60-80% reduction.",
            "status": "done",
            "testStrategy": "Integration test to verify deltas are applied correctly across clients. Measure bandwidth usage before and after implementation using network profiling tools to confirm the 60-80% reduction."
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Separate into backend delta creation, frontend delta application, and bandwidth measurement testing."
      },
      {
        "id": 3,
        "title": "Implement Priority Queue for Messages",
        "description": "Prioritize cursor and presence updates over object updates to prevent cursor lag.",
        "details": "On the backend, create a priority-queue struct with high-priority (cursors, presence), normal-priority (object updates), and low-priority queues. Implement process-message-queue to process high-priority first, then normal with a limit. Ensure message ordering within priorities.",
        "testStrategy": "Unit test queue processing to verify priority order. Integration test during heavy object updates to ensure cursor updates are not delayed. Performance test to confirm no cursor lag with high object update frequency.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Priority Queue Structure",
            "description": "Create a priority-queue struct with three levels: high-priority for cursors and presence updates, normal-priority for object updates, and low-priority queues to manage message ordering.",
            "dependencies": [],
            "details": "Implement a data structure using arrays or linked lists for each priority level, ensuring FIFO ordering within each priority. Include methods to enqueue messages with their priority and dequeue based on priority order.",
            "status": "done",
            "testStrategy": "Unit test the queue structure to verify correct enqueuing and dequeuing across priorities."
          },
          {
            "id": 2,
            "title": "Implement Message Processing Logic",
            "description": "Develop process-message-queue function to process high-priority messages first, then normal-priority with a limit, ensuring no lag in cursor updates.",
            "dependencies": [],
            "details": "Write logic to iterate through high-priority queue completely, then process up to a configurable limit from normal-priority, and optionally low-priority. Maintain message ordering within priorities using timestamps or sequence numbers.",
            "status": "done",
            "testStrategy": "Unit test the processing logic to confirm priority order and limits are respected."
          },
          {
            "id": 3,
            "title": "Test Priority Handling Under High Load",
            "description": "Perform testing to ensure priority queue prevents cursor lag during heavy object updates and concurrent presence changes.",
            "dependencies": [],
            "details": "Set up load tests simulating high-frequency object updates while monitoring cursor and presence update delays. Use performance metrics to verify that high-priority messages are processed without significant lag.",
            "status": "done",
            "testStrategy": "Integration and performance tests under simulated high load to measure latency and confirm no cursor lag."
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Divide into queue structure design, processing logic, and priority testing under high load."
      },
      {
        "id": 4,
        "title": "Implement Object Culling for Rendering",
        "description": "Only render objects visible in the viewport plus padding to maintain 60 FPS with 500+ objects.",
        "details": "In CanvasManager, add setupViewportCulling to listen for viewport moved/zoomed events and call updateVisibleObjects. Implement updateVisibleObjects to calculate visible bounds with 200px padding and set obj.visible and obj.renderable based on intersection. Use getVisibleBounds and isIntersecting helper functions.",
        "testStrategy": "Unit test bounds calculation and intersection logic. Integration test by creating 500+ objects and verifying only visible ones are rendered. Performance test to ensure 60 FPS during pan/zoom operations.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Viewport Calculation and Culling Logic",
            "description": "Add setupViewportCulling to listen for viewport events and implement updateVisibleObjects to calculate bounds with padding and set object visibility.",
            "dependencies": [],
            "details": "In CanvasManager, add setupViewportCulling method to listen for viewport moved/zoomed events and call updateVisibleObjects. Implement updateVisibleObjects to calculate visible bounds with 200px padding using getVisibleBounds, and set obj.visible and obj.renderable based on intersection using isIntersecting helper functions.",
            "status": "done",
            "testStrategy": "Unit test bounds calculation and intersection logic."
          },
          {
            "id": 2,
            "title": "Performance Testing with Many Objects",
            "description": "Test rendering performance with 500+ objects to ensure 60 FPS during pan/zoom operations.",
            "dependencies": [],
            "details": "Create integration tests by generating 500+ objects and verifying only visible ones are rendered. Perform performance tests to measure FPS during pan/zoom operations, ensuring it maintains 60 FPS with the culling logic in place.",
            "status": "done",
            "testStrategy": "Integration test with 500+ objects to verify visibility. Performance test for 60 FPS during pan/zoom.",
            "updatedAt": "2025-10-14T16:02:47.879Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Split into viewport calculation, culling logic, and performance testing with many objects.",
        "updatedAt": "2025-10-14T16:02:47.879Z"
      },
      {
        "id": 5,
        "title": "Add FPS Monitoring",
        "description": "Track and log FPS to detect drops below 55 and provide performance stats.",
        "details": "Create PerformanceMonitor class that uses app.ticker to track FPS in a history array of max 60 entries. Log warnings when FPS < 55, including object count and average FPS. Provide getStats method for current, average, min, max FPS.",
        "testStrategy": "Unit test FPS tracking accuracy. Integration test by simulating load and checking logs for warnings. Manual test to access stats via console and verify no performance impact from monitoring.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create PerformanceMonitor Class Structure",
            "description": "Set up the basic PerformanceMonitor class with necessary properties and initialization.",
            "dependencies": [],
            "details": "Define the PerformanceMonitor class with properties for FPS history array (max 60 entries), current FPS, and methods stubs for tracking and stats. Ensure it integrates with app.ticker for updates.",
            "status": "done",
            "testStrategy": "Unit test class instantiation and property initialization.",
            "updatedAt": "2025-10-14T16:18:10.090Z"
          },
          {
            "id": 2,
            "title": "Implement FPS Tracking with Ticker",
            "description": "Use app.ticker to calculate and track FPS in real-time.",
            "dependencies": [],
            "details": "In the PerformanceMonitor class, add a ticker listener that calculates FPS based on delta time from the ticker. Update the current FPS value on each tick and prepare for adding to history.",
            "status": "done",
            "testStrategy": "Unit test FPS calculation accuracy by mocking ticker events.",
            "updatedAt": "2025-10-14T16:18:11.375Z"
          },
          {
            "id": 3,
            "title": "Add FPS History Array Management",
            "description": "Maintain a history array of FPS values with a maximum of 60 entries.",
            "dependencies": [],
            "details": "Implement logic to add current FPS to the history array on each update, ensuring the array does not exceed 60 entries by removing oldest values. Calculate average FPS from the history.",
            "status": "done",
            "testStrategy": "Unit test array management, including adding, removing, and average calculation.",
            "updatedAt": "2025-10-14T16:18:12.803Z"
          },
          {
            "id": 4,
            "title": "Implement Warning Logging for Low FPS",
            "description": "Log warnings when FPS drops below 55, including object count and average FPS.",
            "dependencies": [],
            "details": "Add logic to check if current FPS is below 55, and if so, log a warning message that includes the current object count (assuming access to object count) and the average FPS from history. Use console.warn or similar.",
            "status": "done",
            "testStrategy": "Integration test by simulating low FPS scenarios and verifying logs are generated correctly.",
            "updatedAt": "2025-10-14T16:18:14.154Z"
          },
          {
            "id": 5,
            "title": "Provide getStats Method for FPS Statistics",
            "description": "Implement getStats method to return current, average, min, and max FPS.",
            "dependencies": [],
            "details": "Create the getStats method that computes and returns an object with current FPS, average FPS (from history), minimum FPS, and maximum FPS from the history array. Ensure calculations are accurate and efficient.",
            "status": "done",
            "testStrategy": "Unit test the getStats method with various history arrays to verify correct stats output.",
            "updatedAt": "2025-10-14T16:18:15.523Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": "2025-10-14T16:18:15.523Z"
      },
      {
        "id": 6,
        "title": "Optimize Remote Cursor Rendering",
        "description": "Use shared textures for cursors to improve performance with multiple remote cursors.",
        "details": "In createRemoteCursor, create a shared cursorTexture once using PIXI.Graphics for the cursor shape. Use PIXI.Sprite with tint for color instead of individual graphics. Add username label as PIXI.Text. Ensure smooth movement at 60 FPS with 10+ cursors.",
        "testStrategy": "Unit test texture sharing and sprite creation. Performance test rendering 10+ cursors to confirm no FPS drop. Visual test to ensure cursors are readable and performant.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Shared Cursor Texture",
            "description": "Generate a single shared texture for the cursor shape using PIXI.Graphics to avoid recreating graphics for each cursor.",
            "dependencies": [],
            "details": "In the PIXI application, create a function to draw a cursor shape (e.g., arrow or pointer) using PIXI.Graphics, render it to a texture once, and store it as a shared resource. This texture will be reused for all remote cursors to optimize memory and rendering performance.",
            "status": "done",
            "testStrategy": "Unit test to verify the texture is created correctly and can be reused without errors."
          },
          {
            "id": 2,
            "title": "Refactor createRemoteCursor to Use Shared Texture and Sprite",
            "description": "Update the createRemoteCursor function to use the shared texture with PIXI.Sprite and apply tint for color variations instead of individual graphics.",
            "dependencies": [],
            "details": "Modify createRemoteCursor to instantiate a PIXI.Sprite using the shared cursorTexture, set its tint property for different colors based on user, and position it accordingly. Remove any code that creates individual PIXI.Graphics for each cursor to reduce overhead.",
            "status": "done",
            "testStrategy": "Unit test sprite creation and tint application to ensure colors are applied correctly."
          },
          {
            "id": 3,
            "title": "Add Username Label to Remote Cursors",
            "description": "Attach a PIXI.Text label displaying the username to each remote cursor for identification.",
            "dependencies": [],
            "details": "In createRemoteCursor, create a PIXI.Text object with the username, style it appropriately (e.g., font size, color), and add it as a child to the cursor sprite. Position the text relative to the cursor (e.g., above or beside it) to ensure readability.",
            "status": "done",
            "testStrategy": "Visual test to confirm labels are displayed correctly and do not overlap or obscure the cursor."
          },
          {
            "id": 4,
            "title": "Implement Smooth Cursor Movement",
            "description": "Ensure cursor positions are updated smoothly to achieve 60 FPS movement with multiple cursors.",
            "dependencies": [],
            "details": "Update the cursor update logic to interpolate positions between received updates for fluid animation. Use requestAnimationFrame or PIXI's ticker to animate cursor movement, ensuring it handles 10+ cursors without dropping below 60 FPS.",
            "status": "done",
            "testStrategy": "Performance test rendering and animating 10+ cursors to measure FPS and confirm smooth movement."
          },
          {
            "id": 5,
            "title": "Optimize and Test Overall Rendering Performance",
            "description": "Conduct performance optimizations and tests to ensure the system maintains 60 FPS with 10+ remote cursors.",
            "dependencies": [],
            "details": "Profile the rendering pipeline, optimize any bottlenecks in texture usage, sprite management, and animation. Run comprehensive tests including unit tests for components, performance benchmarks for FPS, and visual checks for readability and performance.",
            "status": "done",
            "testStrategy": "Performance test with 10+ cursors to confirm no FPS drop; visual test for readability; integration test to ensure all components work together seamlessly."
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": ""
      },
      {
        "id": 7,
        "title": "Implement Memory Cleanup on Disconnect",
        "description": "Properly clean up user data and objects on disconnect to prevent memory leaks.",
        "details": "On backend, in handle-client-disconnect, remove client from room, broadcast user-left, and clean up user data. On frontend, handleUserLeft to destroy cursors (keeping shared texture), remove from activeUsers, and update UI. Add startPeriodicCleanup to remove orphaned objects every minute.",
        "testStrategy": "Unit test cleanup functions. Integration test connect/disconnect cycles to verify memory stability. Run 24-hour session test to ensure no memory growth.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Backend Disconnect Handling",
            "description": "Handle client disconnection on the backend by removing the client from the room, broadcasting user-left events, and cleaning up associated user data to prevent memory leaks.",
            "dependencies": [],
            "details": "In the handle-client-disconnect function, ensure the client is removed from the room structure, broadcast a user-left event to other clients, and perform thorough cleanup of user-specific data such as session variables and temporary caches. This prevents orphaned references that could lead to memory accumulation.",
            "status": "done",
            "testStrategy": "Unit test the cleanup functions to verify that user data is properly removed upon disconnect.",
            "updatedAt": "2025-10-14T16:16:03.329Z"
          },
          {
            "id": 2,
            "title": "Implement Frontend Memory Cleanup",
            "description": "On the frontend, handle user-left events to destroy cursors while preserving shared textures, remove users from active lists, and update the UI accordingly.",
            "dependencies": [],
            "details": "In the handleUserLeft function, destroy individual cursor objects but keep shared textures intact to avoid unnecessary reloading. Remove the disconnected user from the activeUsers array and update any UI elements that display user presence. Ensure no references to the user remain in the DOM or memory.",
            "status": "done",
            "testStrategy": "Integration test connect/disconnect cycles to verify that frontend memory is stable and no leaks occur during repeated user joins and leaves.",
            "updatedAt": "2025-10-14T16:16:04.616Z"
          },
          {
            "id": 3,
            "title": "Add Periodic Memory Cleanup and Long-Term Testing",
            "description": "Implement a periodic cleanup mechanism to remove orphaned objects every minute and conduct thorough testing to ensure no memory growth over time.",
            "dependencies": [],
            "details": "Add a startPeriodicCleanup function that runs every minute to scan for and remove orphaned objects, such as unused PIXI elements or stale data structures. Integrate this into the application's main loop. Conduct a 24-hour session test to monitor memory usage and confirm no gradual leaks occur under sustained load.",
            "status": "done",
            "testStrategy": "Run a 24-hour session test to ensure no memory growth, combined with memory profiling to detect any leaks during periodic cleanup operations.",
            "updatedAt": "2025-10-14T16:16:05.909Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Separate into backend disconnect handling, frontend cleanup, and long-term memory testing.",
        "updatedAt": "2025-10-14T16:16:05.909Z"
      },
      {
        "id": 8,
        "title": "Implement Object Deletion with Proper Cleanup",
        "description": "Ensure deleted objects are fully removed from memory and textures are managed.",
        "details": "In deleteObject, use obj.destroy with options to destroy children but keep shared textures. Remove from objects and selectedObjects maps. For bulk delete, process multiple IDs and broadcast deletions once. Ensure no orphaned PIXI objects.",
        "testStrategy": "Unit test deletion and bulk operations. Memory profiling test to confirm no leaks after deletions. Integration test to verify objects are removed across clients.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Single and Bulk Object Deletion Logic",
            "description": "Develop the core logic for deleting individual objects and handling bulk deletions, ensuring proper cleanup of PIXI objects and removal from maps.",
            "dependencies": [],
            "details": "In the deleteObject function, use obj.destroy with options to destroy children but preserve shared textures. Remove the object from both objects and selectedObjects maps. For bulk delete, process an array of IDs, perform deletions, and broadcast the deletions once to avoid multiple broadcasts. Ensure no orphaned PIXI objects remain in the scene graph.",
            "status": "done",
            "testStrategy": "Unit tests for deleteObject and bulkDelete functions to verify objects are removed from maps and destroyed correctly. Integration tests to confirm broadcasts are sent properly for bulk operations."
          },
          {
            "id": 2,
            "title": "Implement Memory Leak Verification for Object Deletion",
            "description": "Add mechanisms to verify that deleted objects are fully removed from memory and no leaks occur, including texture management checks.",
            "dependencies": [],
            "details": "After deletion, implement checks to ensure PIXI objects are not retained in memory. Use memory profiling tools or custom checks to confirm textures are managed properly (shared ones kept, others released). Add logging or assertions to detect orphaned objects. Integrate with the deletion logic to run verifications post-deletion.",
            "status": "done",
            "testStrategy": "Memory profiling tests using tools like Chrome DevTools to confirm no leaks after deletions. Unit tests for verification functions to ensure they detect potential issues. Integration tests to verify no orphaned objects in the PIXI stage after bulk deletions."
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break into deletion logic, bulk operations, and memory leak verification."
      },
      {
        "id": 9,
        "title": "Add Rate Limiting and Input Validation",
        "description": "Protect against abuse with rate limiting and validate input to prevent invalid data.",
        "details": "On backend, create rate-limiter struct with message count and window. Implement check-rate-limit to allow max 100 messages/sec, resetting window. Add validate-object-update and validate-canvas-state for bounds checking. Reject invalid data with errors.",
        "testStrategy": "Unit test rate limiter and validation functions. Load test to attempt DoS and verify limits are enforced. Integration test invalid inputs are rejected with error messages.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Rate Limiter Struct and Logic",
            "description": "Create a rate-limiter struct with message count and window, and implement check-rate-limit to allow max 100 messages/sec, resetting the window as needed.",
            "dependencies": [],
            "details": "On the backend, define a rate-limiter struct that tracks message counts within a time window. Implement the check-rate-limit function to enforce a maximum of 100 messages per second, automatically resetting the window when the time period expires. Ensure thread-safety for concurrent access.",
            "status": "done",
            "testStrategy": "Unit test the rate limiter to verify it correctly allows up to 100 messages per second and resets the window appropriately."
          },
          {
            "id": 2,
            "title": "Add Input Validation Functions",
            "description": "Implement validate-object-update and validate-canvas-state functions to perform bounds checking on input data.",
            "dependencies": [],
            "details": "Add validation functions on the backend to check bounds for object updates and canvas states. These functions should verify that provided values are within acceptable ranges, such as position coordinates, sizes, and other properties, to prevent invalid data from being processed.",
            "status": "done",
            "testStrategy": "Unit test the validation functions to ensure they correctly identify and flag invalid inputs based on defined bounds."
          },
          {
            "id": 3,
            "title": "Conduct Abuse and DoS Testing",
            "description": "Perform load testing to simulate abuse scenarios, including attempts at DoS attacks, and verify that rate limits are enforced.",
            "dependencies": [],
            "details": "Set up load tests that attempt to exceed the rate limits by sending high volumes of messages. Monitor the system to ensure the rate limiter blocks excessive requests and prevents DoS conditions. Use tools to simulate concurrent high-traffic scenarios.",
            "status": "done",
            "testStrategy": "Load test to attempt DoS and verify that limits are enforced, preventing system overload."
          },
          {
            "id": 4,
            "title": "Implement Error Handling for Invalid Data",
            "description": "Add error handling mechanisms to reject invalid data and return appropriate error messages to clients.",
            "dependencies": [],
            "details": "Integrate error responses into the validation functions so that when invalid data is detected, the system rejects it and sends back clear error messages indicating what was wrong (e.g., out-of-bounds values). Ensure errors are logged and communicated properly without exposing sensitive information.",
            "status": "done",
            "testStrategy": "Integration test to verify that invalid inputs are rejected with appropriate error messages."
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Divide into rate limiter implementation, validation functions, abuse testing, and error handling."
      },
      {
        "id": 10,
        "title": "Optimize Database Access with Pooling and Indexing",
        "description": "Implement connection pooling and add indexes to improve query performance.",
        "details": "Create db-pool struct with 10 connections and thread-safe access using bt:make-lock. Implement with-db-connection macro for reusing connections. Add SQL indexes on canvas_id, session_id, user_id, email. Optimize save-canvas-state-optimized with transactions and INSERT OR REPLACE.",
        "testStrategy": "Unit test connection pooling for reuse and thread-safety. Performance test query execution times to ensure <10ms. Load test database operations to confirm no contention or leaks.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Database Connection Pooling",
            "description": "Set up a connection pool to manage database connections efficiently with thread-safe access.",
            "dependencies": [],
            "details": "Create a db-pool struct with 10 connections and ensure thread-safe access using bt:make-lock. Implement the with-db-connection macro to allow reusing connections from the pool, preventing connection exhaustion and improving concurrency.",
            "status": "done",
            "testStrategy": "Unit test connection pooling for reuse and thread-safety, verifying that connections are properly acquired and released without leaks.",
            "updatedAt": "2025-10-14T16:24:32.583Z"
          },
          {
            "id": 2,
            "title": "Add SQL Indexes on Key Columns",
            "description": "Create indexes on frequently queried columns to speed up database lookups.",
            "dependencies": [],
            "details": "Add SQL indexes on canvas_id, session_id, user_id, and email columns in the relevant database tables. This will reduce query execution time by allowing faster searches and joins on these fields.",
            "status": "done",
            "testStrategy": "Performance test query execution times after indexing to ensure they remain under 10ms, comparing before and after metrics.",
            "updatedAt": "2025-10-14T16:24:33.878Z"
          },
          {
            "id": 3,
            "title": "Optimize Canvas State Saving with Transactions",
            "description": "Enhance the save-canvas-state-optimized function using transactions and efficient insert operations.",
            "dependencies": [],
            "details": "Modify save-canvas-state-optimized to use database transactions for atomic operations and employ INSERT OR REPLACE statements to handle updates and inserts efficiently, minimizing overhead and ensuring data consistency.",
            "status": "done",
            "testStrategy": "Unit test the transaction logic to verify atomicity and correctness of INSERT OR REPLACE operations under various scenarios.",
            "updatedAt": "2025-10-14T16:24:35.189Z"
          },
          {
            "id": 4,
            "title": "Perform Performance and Load Testing",
            "description": "Conduct comprehensive testing to validate database performance under load and ensure no issues.",
            "dependencies": [],
            "details": "Execute load tests on database operations to confirm there is no contention, connection leaks, or performance degradation. Monitor query times to maintain sub-10ms performance even under high concurrency.",
            "status": "done",
            "testStrategy": "Load test database operations to confirm no contention or leaks, and performance test query execution times to ensure they stay under 10ms with simulated high-load conditions.",
            "updatedAt": "2025-10-14T16:24:36.586Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Split into pooling setup, indexing, transaction optimization, and performance/load testing.",
        "updatedAt": "2025-10-14T16:24:36.586Z"
      },
      {
        "id": 11,
        "title": "Implement Performance Monitoring for Latency",
        "description": "Track message latency and provide stats for optimization.",
        "details": "Create LatencyMonitor class to track round-trip latency for messages using performance.now() and messageId. Record latencies in history, warn on >100ms. Provide getStats for percentiles (p50, p95, p99).",
        "testStrategy": "Unit test latency tracking. Integration test with message sending to verify stats accuracy. Performance profiling to ensure monitoring adds minimal overhead.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define LatencyMonitor Class Structure",
            "description": "Create the basic LatencyMonitor class with constructor, properties for storing latency history, and initial setup.",
            "dependencies": [],
            "details": "Initialize the class with a Map or array to store message IDs and their start times. Include a history array to record completed latencies. Set up any necessary imports for performance.now().",
            "status": "done",
            "testStrategy": "Unit test the class instantiation and basic properties.",
            "updatedAt": "2025-10-14T16:29:30.329Z"
          },
          {
            "id": 2,
            "title": "Implement Latency Start Tracking",
            "description": "Add a method to start tracking latency for a message using performance.now() and messageId.",
            "dependencies": [],
            "details": "Create a startLatency(messageId) method that records the current performance.now() timestamp associated with the messageId in the tracking map.",
            "status": "done",
            "testStrategy": "Unit test the startLatency method to verify timestamps are recorded correctly.",
            "updatedAt": "2025-10-14T16:29:31.795Z"
          },
          {
            "id": 3,
            "title": "Implement Latency End Tracking and Recording",
            "description": "Add a method to stop tracking and calculate round-trip latency, then record it in history.",
            "dependencies": [],
            "details": "Create an endLatency(messageId) method that calculates the latency by subtracting the start time from current performance.now(), removes the entry from tracking map, and pushes the latency to the history array.",
            "status": "done",
            "testStrategy": "Unit test the endLatency method to ensure accurate latency calculation and recording.",
            "updatedAt": "2025-10-14T16:29:33.524Z"
          },
          {
            "id": 4,
            "title": "Add Warning for High Latency",
            "description": "Implement logic to warn when recorded latency exceeds 100ms.",
            "dependencies": [],
            "details": "In the endLatency method or a separate check, compare the calculated latency against 100ms and log a warning if exceeded. Use console.warn or a custom logging mechanism.",
            "status": "done",
            "testStrategy": "Unit test the warning logic by simulating latencies above and below 100ms.",
            "updatedAt": "2025-10-14T16:29:35.440Z"
          },
          {
            "id": 5,
            "title": "Implement getStats Method for Percentiles",
            "description": "Create a getStats method that computes and returns p50, p95, and p99 percentiles from the latency history.",
            "dependencies": [],
            "details": "Implement getStats() to sort the history array, calculate the percentiles using appropriate formulas (e.g., for p50, median; for p95, 95th percentile), and return an object with p50, p95, p99 values.",
            "status": "done",
            "testStrategy": "Unit test getStats with sample latency data to verify correct percentile calculations.",
            "updatedAt": "2025-10-14T16:29:36.829Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": "2025-10-14T16:29:36.829Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-16T20:18:53.900Z",
      "taskCount": 11,
      "completedCount": 11,
      "tags": [
        "perf"
      ],
      "created": "2025-10-14T16:32:33.526Z",
      "description": "Tasks for perf context",
      "updated": "2025-10-16T20:18:53.900Z"
    }
  },
  "pixi-upgrade": {
    "tasks": [
      {
        "id": 1,
        "title": "Backup Current Codebase",
        "description": "Verify the current codebase backup on the 'pixi-upgrade' branch and commit any pending changes before starting the upgrade.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "We are already on a separate branch 'pixi-upgrade' in a dedicated worktree. Verify repository status and commit any pending changes before starting the upgrade.",
        "testStrategy": "Verify that we are on the 'pixi-upgrade' branch and no uncommitted changes remain.",
        "subtasks": [
          {
            "id": 1,
            "title": "Verify Branch and Repository State",
            "description": "Verify that we are on the correct 'pixi-upgrade' branch in the worktree and that the repository is in a clean state ready for the upgrade work.",
            "dependencies": [],
            "details": "Run 'git status' to check if there are any uncommitted changes, confirm the current branch is 'pixi-upgrade', and ensure we are in the dedicated worktree.",
            "status": "done",
            "testStrategy": "Ensure no uncommitted changes are present, the branch is 'pixi-upgrade', and we are in the correct worktree."
          },
          {
            "id": 2,
            "title": "Commit Pending Changes",
            "description": "Commit any outstanding changes to the repository before starting the upgrade.",
            "dependencies": [],
            "details": "If there are uncommitted changes, stage them with 'git add .' and commit with 'git commit -m \"Commit before upgrade\"'.",
            "status": "done",
            "testStrategy": "Run 'git status' again to confirm no changes are pending."
          },
          {
            "id": 3,
            "title": "Verify Backup Integrity",
            "description": "Confirm the backup on the 'pixi-upgrade' branch is intact and contains the codebase.",
            "dependencies": [],
            "details": "Run 'git log --oneline' to verify the branch history and ensure the codebase is intact.",
            "status": "done",
            "testStrategy": "Attempt to build or run a basic check on the branch to ensure no issues."
          }
        ],
        "complexity": 2,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this is a straightforward Git operation.",
        "updatedAt": "2025-10-15T20:44:31.501Z"
      },
      {
        "id": 2,
        "title": "Update Package Dependencies",
        "description": "Update package.json to use PixiJS v8 and remove individual sub-packages.",
        "details": "Remove all @pixi/* dependencies from package.json. Add a single 'pixi.js': '^8.x.x'. Run npm install to update node_modules.",
        "testStrategy": "Check package.json for correct dependencies and ensure npm install completes without errors.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Backup current package.json",
            "description": "Create a backup of the current package.json file to allow for easy rollback if needed.",
            "dependencies": [],
            "details": "Make a copy of package.json in the project root, naming it package.json.backup or similar, to preserve the original state before modifications.",
            "status": "done",
            "testStrategy": "Verify that the backup file exists and matches the original package.json content."
          },
          {
            "id": 2,
            "title": "Remove @pixi/* dependencies",
            "description": "Remove all individual @pixi/* package dependencies from the package.json file.",
            "dependencies": [],
            "details": "Open package.json and delete all lines or entries for packages starting with @pixi/, such as @pixi/app, @pixi/graphics, etc., ensuring no remnants are left.",
            "status": "done",
            "testStrategy": "Check package.json to confirm no @pixi/* entries remain in the dependencies or devDependencies sections."
          },
          {
            "id": 3,
            "title": "Add pixi.js v8 dependency",
            "description": "Add the single 'pixi.js' dependency with version '^8.x.x' to package.json.",
            "dependencies": [],
            "details": "In the dependencies section of package.json, add a new entry: \"pixi.js\": \"^8.x.x\", ensuring it is properly formatted as valid JSON.",
            "status": "done",
            "testStrategy": "Inspect package.json to verify the 'pixi.js' entry is present with the correct version specifier."
          },
          {
            "id": 4,
            "title": "Save updated package.json",
            "description": "Save the modified package.json file after removing old dependencies and adding the new one.",
            "dependencies": [],
            "details": "After editing, save the file in the project root, ensuring the JSON syntax is valid by running a quick validation if possible.",
            "status": "done",
            "testStrategy": "Use a JSON validator or attempt to parse the file to confirm it is syntactically correct."
          },
          {
            "id": 5,
            "title": "Run npm install",
            "description": "Execute npm install to update node_modules with the new PixiJS v8 dependency.",
            "dependencies": [],
            "details": "In the terminal, navigate to the project root and run 'npm install', waiting for the command to complete successfully without errors.",
            "status": "done",
            "testStrategy": "Check that npm install finishes without errors, and verify that node_modules contains the updated pixi.js package."
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this involves editing a single file and running a command.",
        "updatedAt": "2025-10-15T20:59:48.115Z"
      },
      {
        "id": 3,
        "title": "Refactor Imports Across Codebase",
        "description": "Change all PixiJS imports from individual sub-packages to single 'pixi.js' import.",
        "details": "Search and replace all imports like 'import { Application } from '@pixi/app'' with 'import { Application } from 'pixi.js''. Update in main.js, canvas.js, and any other files using PixiJS.",
        "testStrategy": "Run the application and check for import errors in the console. Ensure no @pixi/* imports remain.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Refactor PixiJS Imports in main.js",
            "description": "Update all PixiJS imports in main.js from individual sub-packages to the single 'pixi.js' import.",
            "dependencies": [],
            "details": "Locate all import statements in main.js that use '@pixi/*' sub-packages, such as 'import { Application } from '@pixi/app'', and replace them with 'import { Application } from 'pixi.js''. Ensure all necessary exports are available from the single import.",
            "status": "done",
            "testStrategy": "Run the application and check the console for any import errors related to PixiJS in main.js."
          },
          {
            "id": 2,
            "title": "Refactor PixiJS Imports in canvas.js",
            "description": "Update all PixiJS imports in canvas.js from individual sub-packages to the single 'pixi.js' import.",
            "dependencies": [],
            "details": "Search for and replace all imports in canvas.js that reference '@pixi/*' packages, like 'import { Graphics } from '@pixi/graphics'', with 'import { Graphics } from 'pixi.js''. Verify that the file compiles without import issues after changes.",
            "status": "done",
            "testStrategy": "Execute the app and inspect the console for import-related errors in canvas.js, ensuring PixiJS objects are accessible."
          },
          {
            "id": 3,
            "title": "Refactor PixiJS Imports in Other Files",
            "description": "Update PixiJS imports in any remaining files across the codebase that use individual sub-packages.",
            "dependencies": [],
            "details": "Perform a global search across the project for any files importing from '@pixi/*' packages and replace them with imports from 'pixi.js'. This includes checking all JavaScript or TypeScript files not covered in main.js or canvas.js to ensure complete refactoring.",
            "status": "done",
            "testStrategy": "Run the application and monitor the console for any remaining @pixi/* import errors, confirming all PixiJS imports are now from 'pixi.js'."
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Generate subtasks for searching and replacing imports in each specific file (e.g., main.js, canvas.js, and any other PixiJS-using files).",
        "updatedAt": "2025-10-15T20:59:50.717Z"
      },
      {
        "id": 4,
        "title": "Implement Asynchronous Initialization",
        "description": "Refactor main.js to use async initialization for PixiJS Application.",
        "details": "Convert the main function to async. Separate Application constructor from init(). Await app.init() with options before creating PixiJS objects.",
        "testStrategy": "Run the app and verify it initializes without errors. Check console for async-related issues.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze Current main.js Structure",
            "description": "Review the existing main.js file to understand the current synchronous initialization of the PixiJS Application, identifying where the Application constructor is called and how PixiJS objects are created.",
            "dependencies": [],
            "details": "Examine the code in main.js to map out the current flow, noting any synchronous calls to Application() and the sequence of object creation. This will provide a baseline for refactoring.",
            "status": "done",
            "testStrategy": "Manually inspect the code and document the current structure in comments or a separate note."
          },
          {
            "id": 2,
            "title": "Convert Main Function to Async",
            "description": "Modify the main function in main.js to be declared as an async function to support asynchronous operations.",
            "dependencies": [],
            "details": "Change the function declaration from 'function main()' or similar to 'async function main()' in main.js. Ensure the function signature is updated correctly to allow awaiting promises inside it.",
            "status": "done",
            "testStrategy": "Run a syntax check or linter to verify the async keyword is properly applied without syntax errors."
          },
          {
            "id": 3,
            "title": "Separate Application Constructor from Init",
            "description": "Refactor the code to create the PixiJS Application instance without immediately initializing it, preparing for a separate init call.",
            "dependencies": [],
            "details": "Locate the Application constructor call in main.js and separate it from any immediate initialization. Store the app instance in a variable, ensuring no objects are created until after init() is awaited.",
            "status": "done",
            "testStrategy": "Execute the code up to this point and confirm that the Application is instantiated but not yet initialized, checking for any runtime errors."
          },
          {
            "id": 4,
            "title": "Await app.init() with Options",
            "description": "Add an await call to app.init() with the necessary options before proceeding to create PixiJS objects.",
            "dependencies": [],
            "details": "After the Application constructor, insert 'await app.init(options);' where options include any required configuration like canvas settings. Ensure this is placed before any PixiJS object creation to comply with PixiJS v8 async requirements.",
            "status": "done",
            "testStrategy": "Run the application and monitor the console for successful initialization messages or errors related to async init."
          },
          {
            "id": 5,
            "title": "Create PixiJS Objects After Init",
            "description": "Move or ensure that all PixiJS object creation (like sprites, containers) happens after the awaited app.init() call.",
            "dependencies": [],
            "details": "Review and adjust the code in main.js so that any creation of PixiJS objects, such as adding children to the stage or setting up viewports, occurs only after app.init() has resolved. This prevents initialization issues in PixiJS v8.",
            "status": "done",
            "testStrategy": "Run the app and verify it initializes without errors, checking console for async-related issues and ensuring PixiJS objects render correctly."
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this focuses on refactoring a single file's initialization logic.",
        "updatedAt": "2025-10-15T20:59:53.678Z"
      },
      {
        "id": 5,
        "title": "Replace app.view with app.canvas",
        "description": "Update all references to app.view to use app.canvas instead.",
        "details": "Search for app.view in the codebase and replace with app.canvas, primarily in main.js and canvas.js.",
        "testStrategy": "Inspect the DOM to ensure the canvas element is correctly referenced. Test canvas rendering.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Search for all app.view references in the codebase",
            "description": "Perform a comprehensive search across the entire codebase to locate every instance of 'app.view' that needs to be replaced.",
            "dependencies": [],
            "details": "Use grep or a code search tool to find all occurrences of 'app.view' in files, noting the exact lines and files for replacement. Focus on main.js and canvas.js as primary targets, but check all files to ensure completeness.",
            "status": "done",
            "testStrategy": "Verify the search results by manually checking a few files to confirm no instances are missed."
          },
          {
            "id": 2,
            "title": "Replace app.view in main.js",
            "description": "Update all references to app.view with app.canvas in the main.js file.",
            "dependencies": [],
            "details": "Open main.js and replace each instance of 'app.view' with 'app.canvas'. Ensure the replacement is done accurately without affecting surrounding code. Save the file after changes.",
            "status": "done",
            "testStrategy": "Run a diff or search in main.js to confirm all 'app.view' have been replaced and no new instances remain."
          },
          {
            "id": 3,
            "title": "Replace app.view in canvas.js",
            "description": "Update all references to app.view with app.canvas in the canvas.js file.",
            "dependencies": [],
            "details": "Open canvas.js and replace each instance of 'app.view' with 'app.canvas'. Carefully check for any context-specific usages to avoid breaking functionality. Save the file after changes.",
            "status": "done",
            "testStrategy": "Run a diff or search in canvas.js to confirm all 'app.view' have been replaced and no new instances remain."
          },
          {
            "id": 4,
            "title": "Check and replace app.view in other files if any",
            "description": "Review search results for any additional files containing app.view and perform replacements.",
            "dependencies": [],
            "details": "From the search results, identify any files beyond main.js and canvas.js that have 'app.view'. Replace them with 'app.canvas' in each file, ensuring consistency across the codebase.",
            "status": "done",
            "testStrategy": "Perform another search post-replacement to ensure no 'app.view' instances are left in any file."
          },
          {
            "id": 5,
            "title": "Test canvas rendering after replacements",
            "description": "Verify that the app functions correctly with app.canvas references.",
            "dependencies": [],
            "details": "Run the application and inspect the DOM to ensure the canvas element is correctly referenced. Test canvas rendering functionality to confirm no errors or broken behaviors due to the replacements.",
            "status": "done",
            "testStrategy": "Use browser developer tools to inspect the DOM for correct canvas references and perform visual checks on rendering."
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this is a simple find-and-replace operation.",
        "updatedAt": "2025-10-15T20:59:56.060Z"
      },
      {
        "id": 6,
        "title": "Migrate Graphics API to Builder Pattern",
        "description": "Refactor all Graphics drawing logic to use the new builder pattern.",
        "details": "Change from beginFill/drawShape/endFill to shape().fill().stroke(). Update functions like createRectangle and createCircle in canvas.js.",
        "testStrategy": "Create shapes and verify they render correctly without visual artifacts.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update createRectangle function to builder pattern",
            "description": "Refactor the createRectangle function in canvas.js to use the new builder pattern, changing from beginFill/drawShape/endFill to shape().fill().stroke().",
            "dependencies": [],
            "details": "Locate the createRectangle function in canvas.js. Replace the old API calls with the new builder pattern syntax, ensuring the rectangle is created using shape().rect().fill().stroke(). Update any related parameters and ensure compatibility with PixiJS v8.",
            "status": "done",
            "testStrategy": "Create a rectangle shape using the updated function and verify it renders correctly on the canvas without visual artifacts, checking dimensions and fill/stroke properties."
          },
          {
            "id": 2,
            "title": "Update createCircle function to builder pattern",
            "description": "Refactor the createCircle function in canvas.js to use the new builder pattern, changing from beginFill/drawShape/endFill to shape().fill().stroke().",
            "dependencies": [],
            "details": "Locate the createCircle function in canvas.js. Replace the old API calls with the new builder pattern syntax, ensuring the circle is created using shape().circle().fill().stroke(). Update any related parameters and ensure compatibility with PixiJS v8.",
            "status": "done",
            "testStrategy": "Create a circle shape using the updated function and verify it renders correctly on the canvas without visual artifacts, checking radius and fill/stroke properties."
          },
          {
            "id": 3,
            "title": "Update createTriangle function to builder pattern",
            "description": "Refactor the createTriangle function in canvas.js to use the new builder pattern, changing from beginFill/drawShape/endFill to shape().fill().stroke().",
            "dependencies": [],
            "details": "Locate the createTriangle function in canvas.js. Replace the old API calls with the new builder pattern syntax, ensuring the triangle is created using shape().polygon().fill().stroke() with appropriate vertices. Update any related parameters and ensure compatibility with PixiJS v8.",
            "status": "done",
            "testStrategy": "Create a triangle shape using the updated function and verify it renders correctly on the canvas without visual artifacts, checking vertices and fill/stroke properties."
          },
          {
            "id": 4,
            "title": "Update createLine function to builder pattern",
            "description": "Refactor the createLine function in canvas.js to use the new builder pattern, changing from beginFill/drawShape/endFill to shape().fill().stroke().",
            "dependencies": [],
            "details": "Locate the createLine function in canvas.js. Replace the old API calls with the new builder pattern syntax, ensuring the line is created using shape().moveTo().lineTo().stroke(). Update any related parameters and ensure compatibility with PixiJS v8.",
            "status": "done",
            "testStrategy": "Create a line shape using the updated function and verify it renders correctly on the canvas without visual artifacts, checking start/end points and stroke properties."
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Generate subtasks for updating each drawing function (e.g., createRectangle, createCircle) to the new builder pattern, including testing each shape individually.",
        "updatedAt": "2025-10-15T20:59:58.456Z"
      },
      {
        "id": 7,
        "title": "Update Shape Function Names",
        "description": "Rename drawShape methods to their v8 equivalents.",
        "details": "Replace drawRect with rect, drawCircle with circle, etc., in all Graphics usage.",
        "testStrategy": "Test drawing various shapes and confirm they appear as expected.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify all Graphics usage files",
            "description": "Search the codebase to find all files that import or use the Graphics class from PixiJS.",
            "dependencies": [],
            "details": "Use grep or a code search tool to locate files containing 'Graphics' and method calls like drawRect, drawCircle, etc. Compile a list of affected files.",
            "status": "done",
            "testStrategy": "Basic verification: run and ensure no errors."
          },
          {
            "id": 2,
            "title": "Replace drawRect with rect",
            "description": "Update all instances of drawRect method calls to use rect instead.",
            "dependencies": [],
            "details": "In each identified file, perform a find-and-replace operation to change drawRect() to rect(). Ensure the parameters remain compatible.",
            "status": "done",
            "testStrategy": "Verify that rectangles are drawn correctly after replacement."
          },
          {
            "id": 3,
            "title": "Replace drawCircle with circle",
            "description": "Update all instances of drawCircle method calls to use circle instead.",
            "dependencies": [],
            "details": "In each identified file, perform a find-and-replace operation to change drawCircle() to circle(). Check parameter compatibility.",
            "status": "done",
            "testStrategy": "Verify that circles are drawn correctly after replacement."
          },
          {
            "id": 4,
            "title": "Replace other drawShape methods",
            "description": "Update remaining drawShape methods like drawEllipse, drawPolygon, etc., to their v8 equivalents.",
            "dependencies": [],
            "details": "Identify and replace methods such as drawEllipse with ellipse, drawPolygon with polygon, etc. Ensure all Graphics shape drawing methods are updated.",
            "status": "done",
            "testStrategy": "Test rendering of ellipses, polygons, and other shapes to confirm they appear as expected."
          },
          {
            "id": 5,
            "title": "Verify and test all Graphics updates",
            "description": "Run tests to ensure all shape drawing works correctly after renaming methods.",
            "dependencies": [],
            "details": "Execute the project's test suite, particularly focusing on rendering tests. Manually check that shapes are drawn without errors in the application.",
            "status": "done",
            "testStrategy": "Run automated tests and perform visual checks on shape rendering in the app."
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this is a rename operation across Graphics usage.",
        "updatedAt": "2025-10-15T21:00:09.432Z"
      },
      {
        "id": 8,
        "title": "Use Style Objects for Fills and Strokes",
        "description": "Update fill() and stroke() calls to use style objects where applicable.",
        "details": "Change calls like fill(color) to fill({color: color}) and stroke(width, color) to stroke({width: width, color: color}).",
        "testStrategy": "Render shapes with fills and strokes and check for correct styling.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify Files with Fill and Stroke Calls",
            "description": "Scan the codebase to find all files that use fill() or stroke() methods.",
            "dependencies": [],
            "details": "Use grep or search tools to locate all instances of fill( and stroke( in the project files, ensuring to cover all shape creation code.",
            "status": "done",
            "testStrategy": "Basic verification: run and ensure no errors."
          },
          {
            "id": 2,
            "title": "Convert Fill Calls to Style Objects",
            "description": "Change all fill(color) calls to fill({color: color}) format.",
            "dependencies": [],
            "details": "For each identified fill call, modify the parameters to pass an object with the color property, ensuring compatibility with PixiJS v8 API.",
            "status": "done",
            "testStrategy": "Basic verification: run and ensure no errors."
          },
          {
            "id": 3,
            "title": "Convert Stroke Calls to Style Objects",
            "description": "Change stroke(width, color) calls to stroke({width: width, color: color}) format.",
            "dependencies": [],
            "details": "For each stroke call, update to use an object with width and color properties, matching the new PixiJS v8 style object structure.",
            "status": "done",
            "testStrategy": "Basic verification: run and ensure no errors."
          },
          {
            "id": 4,
            "title": "Review and Fix Edge Cases",
            "description": "Check for any complex fill or stroke usages that need special handling.",
            "dependencies": [],
            "details": "Ensure all changes are syntactically correct, handle any edge cases like multiple parameters or conditional calls, and verify no errors introduced.",
            "status": "done",
            "testStrategy": "Basic verification: run and ensure no errors."
          },
          {
            "id": 5,
            "title": "Test Shape Rendering with New Styles",
            "description": "Render shapes and verify fills and strokes appear correctly.",
            "dependencies": [],
            "details": "Run the application, render various shapes with fills and strokes, and visually inspect to confirm correct styling and no visual regressions.",
            "status": "done",
            "testStrategy": "Render shapes with fills and strokes and check for correct styling."
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this updates API calls in shape creation.",
        "updatedAt": "2025-10-15T21:00:12.099Z"
      },
      {
        "id": 9,
        "title": "Replace updateTransform with onRender",
        "description": "Update custom logic using updateTransform to use the new onRender hook.",
        "details": "Create an _onRender method and bind it in the constructor. Replace updateTransform calls with onRender.",
        "testStrategy": "Test custom rendering logic to ensure it executes correctly during render cycles.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify classes using updateTransform",
            "description": "Locate all classes in the codebase that currently use the updateTransform method to understand the scope of refactoring needed.",
            "dependencies": [],
            "details": "Search the codebase for 'updateTransform' calls using grep or IDE search tools. Document the classes, methods, and contexts where it's used to prepare for replacement.",
            "status": "done",
            "testStrategy": "Verify that all instances are identified by cross-checking with code review."
          },
          {
            "id": 2,
            "title": "Create _onRender method in identified classes",
            "description": "Add a new _onRender method to each class that previously used updateTransform, implementing the custom logic.",
            "dependencies": [],
            "details": "In each identified class, define a new private method named _onRender that encapsulates the logic previously in updateTransform. Ensure the method signature matches the onRender hook requirements.",
            "status": "done",
            "testStrategy": "Check that the _onRender method is syntactically correct and compiles without errors."
          },
          {
            "id": 3,
            "title": "Bind _onRender in constructors",
            "description": "Bind the _onRender method in the constructor of each affected class to ensure proper context.",
            "dependencies": [],
            "details": "In the constructor of each class, add a binding statement like this._onRender = this._onRender.bind(this); to maintain the correct 'this' context when the method is used as a hook.",
            "status": "done",
            "testStrategy": "Run unit tests to confirm that the binding works and the method can be called without context errors."
          },
          {
            "id": 4,
            "title": "Replace updateTransform calls with onRender",
            "description": "Update all calls to updateTransform to use the new onRender hook instead.",
            "dependencies": [],
            "details": "Replace each updateTransform() call with the appropriate onRender hook invocation, ensuring that the _onRender method is passed or registered as needed in the PixiJS application lifecycle.",
            "status": "done",
            "testStrategy": "Test that the application renders correctly and that custom logic executes during render cycles by observing visual output and console logs."
          },
          {
            "id": 5,
            "title": "Verify and test the refactoring",
            "description": "Perform comprehensive testing to ensure the refactoring from updateTransform to onRender works as expected.",
            "dependencies": [],
            "details": "Run the full application, check for any runtime errors, and validate that rendering behavior matches the original functionality. Use debugging tools to step through render cycles.",
            "status": "done",
            "testStrategy": "Conduct integration tests focusing on render cycle execution, including edge cases like multiple objects and performance benchmarks."
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this refactors custom logic in specific classes.",
        "updatedAt": "2025-10-15T21:00:14.776Z"
      },
      {
        "id": 10,
        "title": "Update getBounds Usage",
        "description": "Refactor getBounds() calls to use the new return format.",
        "details": "Change container.getBounds() to container.getBounds().rectangle where a PIXI.Rectangle is expected.",
        "testStrategy": "Test bounding box calculations for containers and ensure selections work.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify all getBounds() call sites",
            "description": "Search the codebase to locate every instance where getBounds() is called on containers, ensuring a comprehensive list for refactoring.",
            "dependencies": [],
            "details": "Use grep or IDE search tools to find all occurrences of .getBounds() in the project files, excluding comments and documentation. Document the file paths and line numbers for each call.",
            "status": "done",
            "testStrategy": "Verify the list by manually checking a sample of files to ensure no calls are missed."
          },
          {
            "id": 2,
            "title": "Update getBounds() calls to use .rectangle",
            "description": "Modify each identified getBounds() call to append .rectangle where a PIXI.Rectangle is expected, based on the new return format.",
            "dependencies": [],
            "details": "For each call site identified in subtask 1, change container.getBounds() to container.getBounds().rectangle. Ensure the context confirms PIXI.Rectangle is expected, and handle any necessary imports or type checks.",
            "status": "done",
            "testStrategy": "Compile the code after changes and check for TypeScript errors or runtime issues related to rectangle access."
          },
          {
            "id": 3,
            "title": "Handle edge cases and conditional usages",
            "description": "Address any conditional or complex usages of getBounds() that might require special handling in the refactoring.",
            "dependencies": [],
            "details": "Review the identified call sites for scenarios like conditional checks, loops, or assignments. Adjust the code to properly access .rectangle in these cases, ensuring the logic remains intact.",
            "status": "done",
            "testStrategy": "Run unit tests on affected components to confirm edge cases behave as expected."
          },
          {
            "id": 4,
            "title": "Update related bounding box calculations",
            "description": "Adjust any calculations or operations that depend on the getBounds() return value to work with the new .rectangle format.",
            "dependencies": [],
            "details": "Locate and modify code that performs operations on the getBounds() result, such as width/height calculations or intersection checks, to use the rectangle properties correctly.",
            "status": "done",
            "testStrategy": "Test bounding box calculations manually or via automated tests to ensure accuracy."
          },
          {
            "id": 5,
            "title": "Verify and test overall functionality",
            "description": "Run comprehensive tests to ensure the refactored getBounds() usages work correctly and selections or bounding boxes function as intended.",
            "dependencies": [],
            "details": "Execute the project's test suite, focusing on rendering, selections, and any features relying on bounding boxes. Manually test UI interactions that depend on getBounds() to confirm no regressions.",
            "status": "done",
            "testStrategy": "Use visual inspections and automated tests to validate that shapes, containers, and selections render and behave correctly with the new format."
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this adjusts getBounds calls to new format.",
        "updatedAt": "2025-10-15T21:00:17.386Z"
      },
      {
        "id": 11,
        "title": "Update Ticker Callback",
        "description": "Adjust Ticker callback to use ticker.deltaTime instead of direct deltaTime.",
        "details": "Modify Ticker.shared.add() callback to access deltaTime via ticker.deltaTime.",
        "testStrategy": "Test animations and updates that rely on ticker to ensure smooth performance.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Locate Ticker Callbacks",
            "description": "Search the codebase for all instances of Ticker.shared.add() callbacks that use direct deltaTime.",
            "dependencies": [],
            "details": "Use grep or IDE search to find all Ticker.shared.add() calls and note where deltaTime is accessed directly instead of via ticker.deltaTime. This ensures we identify all locations needing updates.",
            "status": "done",
            "testStrategy": "Verify that all identified callbacks are listed and none are missed by cross-checking with code review."
          },
          {
            "id": 2,
            "title": "Modify Callback Signatures",
            "description": "Update the callback functions to accept the ticker parameter and access deltaTime via ticker.deltaTime.",
            "dependencies": [],
            "details": "For each identified callback, change the function signature to include 'ticker' as the first parameter, and replace any direct deltaTime references with ticker.deltaTime. Ensure the callback is properly bound if necessary.",
            "status": "done",
            "testStrategy": "Compile the code and check for syntax errors in the modified callbacks."
          },
          {
            "id": 3,
            "title": "Update Ticker Registration",
            "description": "Ensure Ticker.shared.add() calls pass the callback correctly with the new signature.",
            "dependencies": [],
            "details": "Review and adjust the Ticker.shared.add() calls to ensure they are registering the updated callbacks properly. If the callback was previously anonymous, consider making it a named function for clarity.",
            "status": "done",
            "testStrategy": "Run the application and confirm that callbacks are registered without errors, checking console logs for any Ticker-related warnings."
          },
          {
            "id": 4,
            "title": "Test Animation Performance",
            "description": "Run tests to verify that animations using the updated callbacks perform smoothly.",
            "dependencies": [],
            "details": "Execute unit tests or manual tests for animations and updates that rely on the ticker. Measure frame rates and ensure deltaTime calculations are accurate, preventing issues like variable time steps.",
            "status": "done",
            "testStrategy": "Use performance profiling tools to monitor frame times and deltaTime values during animation playback."
          },
          {
            "id": 5,
            "title": "Code Review and Final Validation",
            "description": "Conduct a final review of all changes and validate the migration to ticker.deltaTime.",
            "dependencies": [],
            "details": "Perform a code review to ensure all Ticker callbacks now use ticker.deltaTime consistently. Run a full test suite to confirm no regressions in animation or update logic.",
            "status": "done",
            "testStrategy": "Integrate with CI/CD pipeline to run automated tests, ensuring the changes pass all existing test cases related to rendering and updates."
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this modifies a single callback.",
        "updatedAt": "2025-10-15T21:00:19.870Z"
      },
      {
        "id": 12,
        "title": "Replace PIXI.utils Imports",
        "description": "Update all PIXI.utils.* calls to direct imports from 'pixi.js'.",
        "details": "Change imports like PIXI.utils.isMobile to import { isMobile } from 'pixi.js'.",
        "testStrategy": "Run the app and check for any utils-related errors or warnings.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify Files Using PIXI.utils Imports",
            "description": "Scan the entire codebase to find all files that contain PIXI.utils.* calls or imports.",
            "dependencies": [],
            "details": "Use grep or a code search tool to locate all instances of PIXI.utils in the project files, including JavaScript, TypeScript, and any other relevant files. Document the list of files and specific lines for reference.",
            "status": "done",
            "testStrategy": "Verify the list by manually checking a few files to ensure no instances are missed."
          },
          {
            "id": 2,
            "title": "Update Import Statements in Identified Files",
            "description": "Replace PIXI.utils imports with direct imports from 'pixi.js' in each identified file.",
            "dependencies": [],
            "details": "For each file from subtask 1, change statements like 'import PIXI from 'pixi.js';' followed by PIXI.utils usage, to direct imports such as 'import { isMobile } from 'pixi.js';'. Ensure all necessary utils functions are imported.",
            "status": "done",
            "testStrategy": "Check the import sections of updated files to confirm they match the new direct import pattern."
          },
          {
            "id": 3,
            "title": "Replace PIXI.utils Usage with Direct Calls",
            "description": "Update all code references from PIXI.utils.something to just something, assuming the direct import is in place.",
            "dependencies": [],
            "details": "Go through each file and replace usages like PIXI.utils.isMobile() with isMobile(), ensuring the function is imported directly. Handle any potential naming conflicts or scope issues.",
            "status": "done",
            "testStrategy": "Run a linter or static analysis tool to detect any undefined references or syntax errors after replacements."
          },
          {
            "id": 4,
            "title": "Verify No Remaining PIXI.utils References",
            "description": "Perform a final check to ensure all PIXI.utils calls have been replaced and no references remain.",
            "dependencies": [],
            "details": "Re-scan the codebase using the same search method as in subtask 1 to confirm zero instances of PIXI.utils. Review any build or compilation logs for related warnings.",
            "status": "done",
            "testStrategy": "Attempt to build the project and check for any errors related to missing PIXI.utils imports."
          },
          {
            "id": 5,
            "title": "Test Application Functionality",
            "description": "Run the application and verify that all utils-related functionality works correctly after the import changes.",
            "dependencies": [],
            "details": "Start the app, interact with features that use the updated utils (e.g., mobile detection), and monitor for runtime errors. Ensure rendering and logic dependent on these utils perform as expected.",
            "status": "done",
            "testStrategy": "Run the app and check console for any utils-related errors or warnings, as per the parent task's test strategy."
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this updates import statements.",
        "updatedAt": "2025-10-15T21:00:30.253Z"
      },
      {
        "id": 13,
        "title": "Implement CullerPlugin for Performance",
        "description": "Add and configure the CullerPlugin for automatic culling.",
        "details": "Import { extensions, CullerPlugin } from 'pixi.js' and add extensions.add(CullerPlugin). Set cullable = true on the main viewport container.",
        "testStrategy": "Monitor FPS during scene rendering with many objects to ensure culling improves performance.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Import CullerPlugin from PixiJS",
            "description": "Import the CullerPlugin and extensions from the pixi.js library to prepare for plugin addition.",
            "dependencies": [],
            "details": "In the main application file, add the import statement: import { extensions, CullerPlugin } from 'pixi.js';. Ensure this is done after the PixiJS application is initialized.",
            "status": "done",
            "testStrategy": "Verify that the import does not cause any syntax errors or runtime issues during application startup."
          },
          {
            "id": 2,
            "title": "Add CullerPlugin to Extensions",
            "description": "Register the CullerPlugin with the PixiJS extensions system to enable automatic culling functionality.",
            "dependencies": [],
            "details": "After importing, add the plugin by calling extensions.add(CullerPlugin);. This should be done in the initialization phase of the application, ensuring it happens before creating any renderable objects.",
            "status": "done",
            "testStrategy": "Check the console for any errors related to plugin registration and confirm that the plugin is listed in the extensions."
          },
          {
            "id": 3,
            "title": "Configure Main Viewport as Cullable",
            "description": "Set the cullable property to true on the main viewport container to allow the CullerPlugin to manage its visibility.",
            "dependencies": [],
            "details": "Locate the main viewport container in the code and set its cullable property: viewport.cullable = true;. This enables culling for objects within this container, improving performance by not rendering off-screen elements.",
            "status": "done",
            "testStrategy": "Inspect the viewport object in the debugger to confirm the cullable property is set to true."
          },
          {
            "id": 4,
            "title": "Integrate Culling into Application Lifecycle",
            "description": "Ensure the culling logic is properly integrated into the application's rendering loop or initialization sequence.",
            "dependencies": [],
            "details": "Verify that the CullerPlugin is active during the application's update and render cycles. This may involve checking that the plugin hooks into the ticker or render events appropriately.",
            "status": "done",
            "testStrategy": "Run the application and observe that culling is occurring by checking for reduced draw calls in performance tools."
          },
          {
            "id": 5,
            "title": "Monitor Performance Improvements",
            "description": "Test and monitor the performance gains from enabling culling, especially in scenes with many objects.",
            "dependencies": [],
            "details": "Use performance monitoring tools to measure FPS before and after enabling culling. Load a scene with numerous objects and compare rendering times, ensuring the plugin reduces unnecessary computations.",
            "status": "done",
            "testStrategy": "Monitor FPS during scene rendering with many objects using browser dev tools or a performance monitor, verifying that culling improves performance without introducing errors."
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this adds and configures a plugin.",
        "updatedAt": "2025-10-15T21:08:50.754Z"
      },
      {
        "id": 14,
        "title": "Optimize Event System",
        "description": "Review and set interactiveChildren to false on non-interactive containers.",
        "details": "Identify containers like grid backgrounds and set interactiveChildren = false to reduce event traversal.",
        "testStrategy": "Test interaction with interactive elements and ensure non-interactive ones don't interfere.",
        "priority": "low",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify Container Objects in Codebase",
            "description": "Scan the codebase to locate all instances of container objects such as DisplayObjectContainers, Sprites, or other PixiJS objects that hold child elements.",
            "dependencies": [],
            "details": "Use grep or manual search in files like main.js, canvas.js, and other relevant files to find all container declarations and usages. Document their locations and types.",
            "status": "done",
            "testStrategy": "Verify the list of identified containers matches expected structures in the code."
          },
          {
            "id": 2,
            "title": "Classify Containers as Interactive or Non-Interactive",
            "description": "Review each identified container to determine if it requires interactivity or is purely for layout/background purposes.",
            "dependencies": [],
            "details": "Examine the purpose of each container, such as grid backgrounds being non-interactive. Categorize them based on whether they handle user events or not.",
            "status": "done",
            "testStrategy": "Cross-check classifications with code comments or usage patterns to ensure accuracy."
          },
          {
            "id": 3,
            "title": "Set interactiveChildren to False on Non-Interactive Containers",
            "description": "Apply the interactiveChildren = false property to all containers classified as non-interactive.",
            "dependencies": [],
            "details": "Modify the code in the relevant files to add or set interactiveChildren = false on the identified non-interactive containers, ensuring no interactive children are affected.",
            "status": "done",
            "testStrategy": "Run the application and check that no errors occur during initialization or rendering."
          },
          {
            "id": 4,
            "title": "Test Interactive Element Functionality",
            "description": "Verify that interactive elements within the containers still respond correctly to user interactions.",
            "dependencies": [],
            "details": "Interact with buttons, clickable areas, or other interactive components in the app to ensure they trigger events as expected after the changes.",
            "status": "done",
            "testStrategy": "Use manual testing or automated scripts to simulate interactions and log event firings."
          },
          {
            "id": 5,
            "title": "Validate Event Traversal Optimization",
            "description": "Confirm that setting interactiveChildren reduces unnecessary event processing on non-interactive containers.",
            "dependencies": [],
            "details": "Monitor event handling performance, perhaps by adding temporary logging or using browser dev tools to check event propagation paths and ensure efficiency improvements.",
            "status": "done",
            "testStrategy": "Compare event logs or performance metrics before and after changes to quantify the optimization."
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this sets properties on containers.",
        "updatedAt": "2025-10-15T21:10:30.101Z"
      },
      {
        "id": 15,
        "title": "Conduct Functional and Performance Testing",
        "description": "Run full testing suite including functional checks and performance benchmarks.",
        "details": "Execute QA checklist for user stories. Run performance tests using PerformanceMonitor, comparing to v7 baseline. Ensure FPS meets criteria.",
        "testStrategy": "Validate all acceptance criteria: no errors, tests pass, performance met, no deprecations.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Run Functional Checks on User Stories",
            "description": "Execute the QA checklist to verify that all user stories meet their acceptance criteria, ensuring no errors occur and all tests pass.",
            "dependencies": [],
            "details": "Go through each user story in the QA checklist, perform functional tests to check for correct behavior, error handling, and compliance with requirements. Document any issues found and ensure all tests are passing before proceeding.",
            "status": "done",
            "testStrategy": "Validate all acceptance criteria including no errors and tests passing."
          },
          {
            "id": 2,
            "title": "Run Performance Benchmarks Against v7 Baseline",
            "description": "Execute performance tests using PerformanceMonitor to compare current performance against the v7 baseline and ensure FPS meets the required criteria.",
            "dependencies": [],
            "details": "Set up and run PerformanceMonitor on the application, measure FPS and other key metrics during benchmarks, compare results directly to the v7 baseline data, and verify that performance thresholds are met or exceeded.",
            "status": "done",
            "testStrategy": "Monitor FPS and other performance metrics, ensuring they meet or exceed the v7 baseline criteria."
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Generate subtasks for running functional checks on user stories and separate subtasks for performance benchmarks against v7 baseline.",
        "updatedAt": "2025-10-15T21:00:32.389Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-16T20:18:53.900Z",
      "taskCount": 15,
      "completedCount": 15,
      "tags": [
        "pixi-upgrade"
      ],
      "created": "2025-10-16T21:25:04.764Z",
      "description": "Tasks for pixi-upgrade context",
      "updated": "2025-10-16T21:25:04.764Z"
    }
  },
  "auth0": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up Auth0 configuration and environment variables",
        "description": "Configure Auth0 domain, client ID, client secret, callback URL, and audience in the application configuration to enable OAuth2 integration.",
        "details": "Create a configuration file or module (e.g., src/auth0-config.lisp) with parameters like *auth0-domain*, *auth0-client-id*, etc., using environment variables. Implement helper functions such as auth0-authorize-url, auth0-token-url, auth0-userinfo-url, and auth0-logout-url as specified in the PRD. Ensure secure handling of secrets and validate that all required environment variables are set.",
        "testStrategy": "Unit test the configuration functions to verify correct URL generation and parameter inclusion. Mock environment variables and check for proper error handling if variables are missing.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break down the setup of Auth0 configuration into subtasks focusing on creating the configuration module, implementing helper functions, and adding validation for environment variables."
      },
      {
        "id": 2,
        "title": "Update database schema to support Auth0 fields",
        "description": "Modify the users table to include Auth0-specific fields like auth0_sub, display_name, avatar_url, email_verified, and last_login_at, making password_hash nullable.",
        "details": "Execute the SQL schema changes as provided in the PRD, recreating the users table with new columns and copying existing data. Add indexes for auth0_sub, email, and username. Ensure backward compatibility by keeping password_hash nullable for legacy users.",
        "testStrategy": "Integration test by running the schema migration on a test database, verifying that existing data is preserved and new columns are added correctly. Check for no data loss and proper indexing.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Divide the database schema update into subtasks for executing SQL changes and ensuring data migration with backward compatibility."
      },
      {
        "id": 3,
        "title": "Implement OAuth2 authorization flow initiation",
        "description": "Create the handler to redirect users to Auth0's authorization endpoint with proper state parameter for CSRF protection.",
        "details": "Implement handle-auth0-login function in src/auth0-oauth.lisp, generating a secure state token, storing it temporarily, and redirecting to the Auth0 authorize URL. Include state expiry mechanism using threads for cleanup after 5 minutes.",
        "testStrategy": "Unit test the handler to ensure correct redirect URL generation and state storage. Simulate requests and verify state validation in subsequent steps.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Expand the OAuth2 flow initiation into subtasks covering state token generation, temporary storage, and redirect handling with expiry mechanisms."
      },
      {
        "id": 4,
        "title": "Implement OAuth2 callback and token exchange",
        "description": "Handle the Auth0 callback, validate state, exchange authorization code for tokens, and process the response.",
        "details": "Implement handle-auth0-callback function, checking for errors and state validity, then calling exchange-code-for-tokens to POST to Auth0's token endpoint. Parse the response for access_token and id_token. Handle errors gracefully with logging.",
        "testStrategy": "Integration test by mocking the callback request with valid/invalid codes and states. Verify token exchange via HTTP calls to a test Auth0 endpoint and check error responses.",
        "priority": "high",
        "dependencies": [
          "1",
          "3"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down the callback handling into subtasks for state validation, token exchange via HTTP, response parsing, and error handling."
      },
      {
        "id": 5,
        "title": "Implement JWT ID token decoding and validation",
        "description": "Decode the ID token, validate its signature, issuer, audience, and expiration, and extract user claims.",
        "details": "Implement decode-id-token and validate-jwt-signature functions, fetching JWKS from Auth0 for signature verification using RS256. Cache JWKS for 24 hours. Validate claims as per OAuth2 standards and return user info like sub, email, name, etc.",
        "testStrategy": "Unit test with mock JWTs, verifying signature validation, claim checks, and error handling for expired or invalid tokens. Use test JWKS data to simulate Auth0 responses.",
        "priority": "high",
        "dependencies": [
          "1",
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 8,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Subdivide JWT handling into tasks for decoding, signature validation with JWKS, claim validation, and caching mechanisms."
      },
      {
        "id": 6,
        "title": "Implement user finding and creation from OAuth data",
        "description": "Check for existing users by auth0_sub or email, update or create new users, and handle linking for legacy accounts.",
        "details": "Implement find-or-create-user-from-oauth, get-user-by-auth0-sub, update-user-from-oauth, link-auth0-to-user, and create-user-from-oauth functions. Use database transactions for safety. Generate usernames from emails if needed.",
        "testStrategy": "Unit test the functions with mock OAuth user info, verifying user creation, updates, and linking. Integration test by inserting test data and checking database state after operations.",
        "priority": "medium",
        "dependencies": [
          "2",
          "5"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Expand user management into subtasks for finding existing users, creating new ones, updating records, and handling legacy account linking with transactions."
      },
      {
        "id": 7,
        "title": "Implement session creation and cookie management",
        "description": "Create user sessions upon successful OAuth authentication and set secure session cookies.",
        "details": "After validating tokens and finding/creating users, call create-session-for-user and set-session-cookie with HttpOnly, Secure, SameSite=strict flags, and 24-hour expiry. Ensure sessions are stored securely.",
        "testStrategy": "Integration test the full flow, checking cookie setting and session retrieval. Verify cookie security attributes and session validity across requests.",
        "priority": "medium",
        "dependencies": [
          "5",
          "6"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Divide session handling into subtasks for creating sessions and setting secure cookies with proper attributes."
      },
      {
        "id": 8,
        "title": "Update frontend for Auth0 login integration",
        "description": "Modify the frontend to include Auth0 login buttons, handle redirects, and support dual-mode authentication during transition.",
        "details": "Update frontend/src/auth.js with AuthManager class, adding loginWithAuth0, loginWithGoogle, loginWithGithub methods. Modify UI in login page to show Auth0 and social login options, keeping legacy login for transition.",
        "testStrategy": "Manual testing in browser: click login buttons, verify redirects to Auth0, and successful callback. Check UI rendering and error handling for failed logins.",
        "priority": "medium",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down frontend updates into subtasks for modifying the AuthManager class, updating UI elements, and supporting dual-mode authentication."
      },
      {
        "id": 9,
        "title": "Implement user migration and linking flow",
        "description": "Allow existing users to link their Auth0 accounts to legacy profiles during Phase 2.",
        "details": "Implement handle-link-auth0-account function, requiring legacy login first, then initiating OAuth with metadata to link. Update user records with auth0_sub upon successful linking. Add UI banners and email campaigns as per PRD.",
        "testStrategy": "Integration test the linking flow: simulate legacy login, initiate link, complete OAuth, and verify database updates. Manual test with real users to ensure no disruption.",
        "priority": "medium",
        "dependencies": [
          "6",
          "8"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Expand the migration flow into subtasks for implementing the linking handler, updating UI banners, managing email campaigns, and ensuring database updates."
      },
      {
        "id": 10,
        "title": "Implement monitoring, testing, and deprecation of legacy auth",
        "description": "Add metrics collection, comprehensive testing, and gradual removal of legacy authentication in Phase 3.",
        "details": "Implement get-auth-metrics for monitoring key stats. Conduct unit, integration, and manual tests as outlined. Add feature flags for Auth0 enablement and deprecate legacy endpoints after migration thresholds.",
        "testStrategy": "Run full test suite including OAuth flow simulations, social logins, and migration. Monitor metrics for errors and usage. Manual checklist verification for security and functionality.",
        "priority": "low",
        "dependencies": [
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 9,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Subdivide the final phase into tasks for metrics collection, comprehensive testing, feature flag implementation, legacy deprecation, and monitoring setup."
      },
      {
        "id": 11,
        "title": "Implement JWT Signature Validation with RS256 and JWKS",
        "description": "Enhance JWT validation to include cryptographic signature verification using RS256 algorithm and Auth0's JWKS endpoint, ensuring secure token authenticity beyond claims validation.",
        "details": "Update the existing JWT validation logic (likely in Task 5's functions) to incorporate signature verification. Use a robust JWT library such as 'jose' or 'cl-jwt' for Common Lisp to handle decoding, signature verification, and JWKS management. Implement a function to fetch Auth0's JWKS (JSON Web Key Set) from the configured endpoint (e.g., https://your-domain.auth0.com/.well-known/jwks.json), parse the keys, and select the appropriate RSA public key based on the 'kid' (Key ID) in the JWT header. Verify the JWT signature using RS256 (RSA with SHA-256) against the public key. Implement caching for the JWKS with a TTL (Time-To-Live) of 24 hours to minimize network calls and improve performance; use a thread-safe cache mechanism like a hash table with expiry timestamps or a library such as 'cl-cache'. Ensure the cache handles key rotation by re-fetching if a 'kid' is not found. Validate standard claims (iss, aud, exp, iat) as before, but now as part of a comprehensive validation function that returns true only if both signature and claims are valid. Handle errors gracefully, such as invalid signatures, network failures during JWKS fetch, or malformed JWKS, by logging and returning appropriate error responses. Consider security best practices: avoid storing private keys, use HTTPS for JWKS fetches, and implement rate limiting if needed. Integrate this into the OAuth callback flow after token exchange (from Task 4).",
        "testStrategy": "Conduct unit tests with mock JWTs: create valid and invalid signed tokens using test keys, verify signature validation passes/fails correctly, and check JWKS caching behavior (e.g., simulate cache expiry and re-fetch). Use integration tests to simulate the full OAuth flow: mock Auth0 responses including JWKS, exchange code for tokens, and validate the ID token with signature verification. Test edge cases like key rotation (new 'kid'), network timeouts during JWKS fetch, and malformed JWKS. Perform manual tests in a staging environment with real Auth0 integration, monitoring logs for signature validation successes/failures and cache hits/misses. Verify performance impact by measuring response times with and without caching. Ensure compliance with OAuth2 and JWT RFC standards.",
        "status": "done",
        "dependencies": [
          "4"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement JWKS Fetching Function",
            "description": "Create a function to fetch the JSON Web Key Set (JWKS) from Auth0's endpoint, handling network requests and parsing the response.",
            "dependencies": [],
            "details": "Implement a function named 'fetch-jwks' that makes an HTTPS GET request to the configured Auth0 JWKS endpoint (e.g., https://your-domain.auth0.com/.well-known/jwks.json). Use a Common Lisp HTTP library like Drakma to perform the request. Parse the JSON response into a usable structure, such as a list of key objects. Handle errors like network failures or invalid JSON by logging and returning nil or an error indicator. Ensure the function is thread-safe if called concurrently.",
            "status": "pending",
            "testStrategy": "Unit test the function with mocked HTTP responses: simulate successful fetches, network errors, and malformed JSON to verify correct parsing and error handling.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement JWKS Caching Mechanism",
            "description": "Set up a thread-safe caching system for JWKS data with a 24-hour TTL to reduce network calls and handle key rotation.",
            "dependencies": [],
            "details": "Implement a cache using a thread-safe hash table or a library like cl-cache. Store the fetched JWKS with an expiry timestamp set to 24 hours from fetch time. Create functions to check cache validity, retrieve keys, and refresh the cache if expired or if a key ID is not found. Ensure the cache handles concurrent access using locks or atomic operations. Integrate this with the fetching function to automatically re-fetch when needed.",
            "status": "pending",
            "testStrategy": "Unit test caching behavior: simulate cache hits, misses, expiries, and key rotations by mocking time and verifying re-fetch calls.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement RSA Public Key Selection",
            "description": "Add logic to select the appropriate RSA public key from the JWKS based on the 'kid' in the JWT header.",
            "dependencies": [],
            "details": "In the JWT validation process, decode the JWT header to extract the 'kid' (Key ID). Query the cached JWKS to find the matching key. If not found, trigger a cache refresh. Convert the selected key (in JWK format) to an RSA public key object using the JWT library (e.g., 'jose' or 'cl-jwt'). Handle cases where the key is not RSA or RS256 compatible by raising appropriate errors. This ensures the correct public key is used for signature verification.",
            "status": "pending",
            "testStrategy": "Unit test key selection: create mock JWKS with multiple keys, test matching 'kid', non-matching cases, and invalid key types.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement JWT Signature Verification with RS256",
            "description": "Verify the JWT signature using the selected RSA public key and RS256 algorithm.",
            "dependencies": [],
            "details": "Using the JWT library, implement signature verification by decoding the JWT, extracting the signature, and verifying it against the RSA public key using RS256 (RSA with SHA-256). Ensure the verification process checks the entire token integrity. Return true if valid, false otherwise. Integrate error handling for invalid signatures, mismatched algorithms, or corrupted tokens, logging details for debugging.",
            "status": "pending",
            "testStrategy": "Unit test signature verification: use mock JWTs signed with test keys, verify valid signatures pass and invalid ones fail, including algorithm mismatches.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate Comprehensive JWT Validation",
            "description": "Combine signature verification with claims validation into a single function and integrate it into the OAuth callback flow.",
            "dependencies": [],
            "details": "Create a comprehensive 'validate-jwt' function that first performs signature verification (from subtask 4) and then validates standard claims (iss, aud, exp, iat) as in Task 5. Return true only if both are valid. Handle errors gracefully, such as by returning error responses. Integrate this into the OAuth callback handler after token exchange (from Task 4), ensuring the flow proceeds only on successful validation. Update existing logic from Task 5 to use this new function.",
            "status": "pending",
            "testStrategy": "Integration test the full validation: mock OAuth flow with valid/invalid tokens, verify signature and claims checks, and ensure proper error responses in the callback handler.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-16T22:33:53.155Z"
      },
      {
        "id": 12,
        "title": "Implement Rate Limiting for OAuth Endpoints",
        "description": "Add rate limiting middleware to the OAuth endpoints (/auth0/login, /auth0/callback, /auth0/link) to prevent abuse by enforcing a limit of 10 requests per hour per IP address using IP-based tracking with a sliding window mechanism.",
        "details": "Implement rate limiting as middleware in the Common Lisp application to protect the specified OAuth endpoints from abuse. Create a global hash table *rate-limit-store* to track request timestamps per IP address, where each key is an IP string and the value is a list of timestamps (in Unix epoch seconds) for recent requests. Develop a check-rate-limit function that, for a given IP, removes timestamps older than 1 hour (3600 seconds) from the list (sliding window), counts the remaining timestamps, and returns true if the count is less than 10, otherwise false. If allowed, append the current timestamp to the list. Apply this middleware to the handlers for /auth0/login (from Task 3), /auth0/callback (from Task 4), and /auth0/link (from Task 9), checking the rate limit before processing the request and returning a 429 Too Many Requests HTTP status with an appropriate error message if exceeded. Use the client's IP address from the request headers (e.g., X-Forwarded-For or remote-addr), with considerations for proxies. For best practices, ensure thread-safety by using locks or atomic operations on the hash table in a multi-threaded environment like Hunchentoot. Periodically clean up the hash table to remove entries for IPs with no recent requests to prevent memory leaks. Research indicates using a sliding window over fixed windows reduces burstiness; consider libraries like cl-store for persistence if needed, but in-memory suffices for this scale. Handle IPv4 and IPv6 addresses uniformly.",
        "testStrategy": "Conduct unit tests for the check-rate-limit function using mock IP addresses and timestamps: simulate multiple requests within an hour to verify blocking after 10, and test window sliding by advancing time and checking if older requests are pruned. Integration tests: Use a test framework to send repeated requests to each endpoint (/auth0/login, /auth0/callback, /auth0/link) from the same IP, verifying that the 11th request returns 429 status and subsequent requests are allowed after the hour window. Mock the IP extraction and test with various header scenarios. Load test with concurrent requests to ensure thread-safety and performance. Manual verification: Deploy to a staging environment, simulate abuse patterns, and monitor logs for rate limit hits without affecting legitimate traffic.",
        "status": "done",
        "dependencies": [
          "3",
          "4",
          "9"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Global Rate Limit Store",
            "description": "Set up a global hash table to track request timestamps per IP address for rate limiting.",
            "dependencies": [],
            "details": "Implement a global hash table *rate-limit-store* in the Common Lisp application, where keys are IP strings and values are lists of Unix epoch timestamps for recent requests. Ensure it handles IPv4 and IPv6 uniformly.",
            "status": "pending",
            "testStrategy": "Unit test the hash table creation and basic operations like insertion and retrieval of timestamps for mock IP addresses.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Check Rate Limit Function",
            "description": "Develop the check-rate-limit function to enforce the sliding window rate limiting logic.",
            "dependencies": [],
            "details": "Create a check-rate-limit function that takes an IP address, removes timestamps older than 3600 seconds from the list, counts remaining timestamps, and returns true if count < 10, appending current timestamp if allowed. Implement sliding window mechanism.",
            "status": "pending",
            "testStrategy": "Unit tests with mock IPs and timestamps: simulate requests to verify blocking after 10 within an hour, and test pruning of old timestamps by advancing time.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Extract Client IP Address from Request",
            "description": "Implement logic to reliably extract the client's IP address from HTTP request headers.",
            "dependencies": [],
            "details": "Develop a function to get the client's IP from headers like X-Forwarded-For or remote-addr, considering proxy scenarios. Handle both IPv4 and IPv6 addresses uniformly for rate limiting purposes.",
            "status": "pending",
            "testStrategy": "Unit tests with various header combinations, including proxies, to ensure correct IP extraction. Mock requests to verify handling of forwarded headers.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Apply Rate Limiting Middleware to OAuth Endpoints",
            "description": "Integrate the rate limiting check as middleware for the specified OAuth handlers.",
            "dependencies": [],
            "details": "Modify the handlers for /auth0/login, /auth0/callback, and /auth0/link to check rate limit before processing. If exceeded, return 429 status with error message. Apply this middleware ensuring it uses the extracted IP.",
            "status": "pending",
            "testStrategy": "Integration tests using a test framework to send requests to the endpoints, verifying rate limiting blocks after 10 requests per hour per IP and allows within limits.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Ensure Thread-Safety and Periodic Cleanup",
            "description": "Add thread-safety and cleanup mechanisms to the rate limiting system.",
            "dependencies": [],
            "details": "Use locks or atomic operations for hash table access in multi-threaded Hunchentoot environment. Implement periodic cleanup to remove entries for IPs with no recent requests, preventing memory leaks. Consider in-memory storage sufficiency.",
            "status": "pending",
            "testStrategy": "Stress tests in a multi-threaded setup to verify thread-safety. Unit tests for cleanup function, simulating time passage and checking hash table size reduction.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-16T22:35:49.751Z"
      },
      {
        "id": 13,
        "title": "Implement Environment-Dependent Secure Cookie Flag",
        "description": "Modify the auth0-oauth.lisp file to make the :secure cookie flag dynamic based on the ENVIRONMENT environment variable, setting it to true for production to ensure cookies are only sent over HTTPS, while allowing insecure cookies in development.",
        "details": "In the auth0-oauth.lisp file, replace the hardcoded :secure nil with a dynamic parameter. Define a global parameter *use-secure-cookies* that checks the ENVIRONMENT environment variable using (uiop:getenv \"ENVIRONMENT\") or similar. Set *use-secure-cookies* to t if ENVIRONMENT is \"production\" (or matches production values like \"prod\"), otherwise nil. This follows security best practices where secure cookies prevent transmission over insecure connections in production, reducing risks like session hijacking. Consider using a configuration module (e.g., from Task 1) to centralize environment checks. Ensure the parameter is evaluated at runtime or load time, and document the behavior. For Common Lisp, leverage libraries like uiop for environment access. Update any cookie-setting functions to use this parameter, such as in Hunchentoot or similar web frameworks. Best practices include defaulting to secure in production and providing clear logging or warnings if the environment is misconfigured.",
        "testStrategy": "Unit test the *use-secure-cookies* parameter by mocking the ENVIRONMENT variable: set it to \"production\" and verify it returns t, set to \"development\" and verify nil. Integration test by simulating OAuth login in a test environment, checking that cookies are set with :secure t in production mode and nil in development. Use a test web server to inspect cookie headers in responses. Verify no regressions in existing OAuth flows by running full integration tests for login and callback endpoints.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-10-16T22:22:42.589Z"
      },
      {
        "id": 14,
        "title": "Fix Thread Safety in State Token Cleanup",
        "description": "Modify the cleanup-expired-states function in auth0-oauth.lisp to ensure thread-safe removal of expired state tokens by collecting keys first and removing them in a separate pass, preventing issues from modifying the hash table during iteration.",
        "details": "In the cleanup-expired-states function around line 60 of auth0-oauth.lisp, address the thread safety issue where the hash table is modified during iteration, which can lead to undefined behavior or errors in Common Lisp implementations. Current best practices for thread-safe hash table operations in Common Lisp recommend avoiding modifications during iteration to prevent race conditions in multi-threaded environments. Implement the fix by first iterating over the hash table to collect expired keys into a list (e.g., using maphash or loop to check expiration based on timestamps), then perform a second pass to remove those keys from the hash table using remhash. Ensure the function uses appropriate locking if the hash table is accessed concurrently, such as with a mutex or bordeaux-threads locks, to synchronize access. Consider using a read-write lock for better performance if reads are more frequent than writes. Update any related documentation or comments to reflect the thread-safe approach. This aligns with Common Lisp concurrency patterns, drawing from libraries like bordeaux-threads for synchronization primitives, and ensures robustness in production environments where multiple threads might access the state store simultaneously.",
        "testStrategy": "Conduct unit tests for the cleanup-expired-states function using a testing framework like FiveAM or Prove. Create a mock hash table populated with state tokens, some expired and some not, based on simulated timestamps. Test the function in a single-threaded context first to verify expired keys are correctly identified and removed without errors. For thread safety, use bordeaux-threads to spawn multiple threads that concurrently access and modify the hash table while the cleanup runs periodically (e.g., every few seconds in a loop). Monitor for race conditions by checking hash table integrity post-cleanup, ensuring no keys are lost or corrupted. Use tools like SBCL's thread inspector or add logging to detect any iteration-related exceptions. Integration tests should simulate the full OAuth flow with concurrent requests, verifying that state cleanup does not interfere with active sessions. Run stress tests with high concurrency to confirm no deadlocks or performance degradation, measuring execution time and memory usage.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-10-16T22:19:20.381Z"
      },
      {
        "id": 15,
        "title": "Enhance Error Handling in OAuth Token Exchange",
        "description": "Improve error handling in the exchange-code-for-token function within auth0-oauth.lisp by replacing the generic error handler with specific conditions for network errors and JSON parsing issues, providing appropriate HTTP status codes and user-friendly error messages.",
        "details": "In the auth0-oauth.lisp file, locate the exchange-code-for-token function and modify its error handling from the generic (error (e)) clause to handle specific error types. Use drakma:drakma-error for network-related issues, such as connection failures or HTTP errors like 502 Bad Gateway, and define a custom json-parse-error condition for malformed JSON responses, typically associated with 500 Internal Server Error. For each error type, set the appropriate HTTP status code in the response and include user-friendly messages, e.g., 'Network error occurred during token exchange' for drakma:drakma-error and 'Invalid response format from authorization server' for json-parse-error. Ensure the error handling integrates with the application's web framework (e.g., Hunchentoot or similar) to return proper HTTP responses. Consider using Common Lisp's condition system to define and signal these errors, allowing for clean separation of concerns. Research indicates that specific error handling improves debugging and user experience, aligning with best practices in robust web application development. Avoid catching all errors generically to prevent masking underlying issues. If using libraries like Drakma for HTTP requests and a JSON parser like Yason or Jonathon, ensure compatibility. Update any related logging to capture error details for monitoring.",
        "testStrategy": "Conduct unit tests for the exchange-code-for-token function using a testing framework like FiveAM or Prove. Mock network failures by simulating drakma:drakma-error conditions (e.g., using a test double for HTTP requests) and verify that a 502 status code is returned with the appropriate message. For JSON parsing errors, mock malformed responses and check for 500 status code and user-friendly message. Integration tests should simulate the full OAuth callback flow: use a test server to trigger the function with invalid codes or network disruptions, ensuring the application handles errors gracefully without crashing and logs details appropriately. Verify that valid token exchanges still succeed and that error responses are properly formatted (e.g., JSON or HTML based on the application's response type).",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-10-16T22:23:48.199Z"
      },
      {
        "id": 16,
        "title": "Enhance Frontend Error Handling for OAuth Methods in auth.js",
        "description": "Improve error handling in the OAuth login methods (loginWithAuth0, loginWithGoogle, loginWithGithub) within auth.js by replacing simple console logging with comprehensive checks for HTTP response status, safe JSON parsing, and displaying user-friendly error messages via the showError method, while gracefully managing network failures.",
        "details": "In the auth.js file, locate the AuthManager class and its OAuth methods (loginWithAuth0, loginWithGoogle, loginWithGithub). Currently, these methods likely use fetch or similar for API calls and only log errors to console. Enhance each method with robust error handling following modern JavaScript best practices: wrap the fetch calls in try-catch blocks to handle network failures (e.g., connection timeouts or DNS errors), check response.ok to identify HTTP errors (4xx/5xx), and safely parse JSON responses using response.json() within a try-catch to handle malformed JSON. For errors, extract relevant details from the response (e.g., error message from JSON body if available) and call the existing showError method to display user-friendly messages, such as 'Login failed: Invalid credentials' or 'Network error: Please check your connection'. Implement exponential backoff for retryable network errors (e.g., 5xx status codes) using a utility function with setTimeout, limiting retries to 3 attempts. Ensure error messages are localized if an i18n system is in place, and log detailed errors to console.error for debugging while keeping user-facing messages generic. Use async/await for readability and avoid callback hell. Consider integrating with a global error boundary or logging service like Sentry for production monitoring. This approach aligns with current best practices for frontend error handling, emphasizing user experience and security by not exposing sensitive details.",
        "testStrategy": "Conduct manual testing in a browser environment: simulate various error scenarios using browser developer tools (e.g., throttle network to 'Offline' for network failures, use mock servers like Postman or a local Express server to return 4xx/5xx responses with error JSON). Verify that user-friendly messages appear via showError for each method, and check console.error logs for detailed debugging info. For unit tests, use Jest or Mocha to mock fetch responses: test successful logins, HTTP errors (e.g., 400 with error JSON), network failures (throwing errors), and malformed JSON. Assert that showError is called with appropriate messages, retries occur for 5xx errors, and no unhandled exceptions propagate. Integration tests should cover the full login flow, ensuring errors don't break the UI state and redirects work post-error. Validate accessibility by checking error messages are announced via screen readers if showError supports ARIA.",
        "status": "done",
        "dependencies": [
          "8"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-10-16T22:24:51.125Z"
      },
      {
        "id": 17,
        "title": "Add Docstrings to Core OAuth Functions in auth0-oauth.lisp",
        "description": "Add comprehensive docstrings to key functions in auth0-oauth.lisp, including parse-jwt, exchange-code-for-token, validate-id-token, and other core OAuth functions, following Common Lisp conventions with detailed descriptions of parameters, return values, and behavior.",
        "details": "In the auth0-oauth.lisp file, identify the core OAuth functions such as parse-jwt, exchange-code-for-token, validate-id-token, and any other essential functions (e.g., those handling token validation, state management, or error responses). For each function, add a docstring immediately following the function definition using Common Lisp's standard docstring placement. Follow established Common Lisp docstring conventions: start with a brief description of the function's purpose, then list parameters with their types and descriptions, followed by return value details including types and possible values. Include any side effects, error conditions, or examples where relevant. Use clear, concise language and ensure consistency across functions. For instance, for exchange-code-for-token, describe parameters like authorization-code and redirect-uri, and specify return values such as a token object or error signals. Research and incorporate best practices from Common Lisp documentation standards, such as those outlined in the CLHS (Common Lisp HyperSpec) and tools like SLIME for docstring formatting. Ensure docstrings are machine-readable for tools like documentation generators (e.g., using DECLARE or custom macros if needed, but stick to standard strings). Consider internationalization if applicable, but prioritize English for clarity. Update any related comments or inline documentation to avoid redundancy.",
        "testStrategy": "Verify docstring addition by manually inspecting the auth0-oauth.lisp file to ensure each targeted function has a docstring in the correct position (after DEFUN or similar). Use a Common Lisp REPL or IDE like Emacs with SLIME to query function documentation via DESCRIBE or DOCUMENTATION functions, confirming that parameters, return values, and descriptions are accurately reflected. Conduct peer code review to assess clarity and adherence to conventions. Run automated checks if available (e.g., via linters like lisp-critic or custom scripts) to detect missing docstrings. Test that the functions still operate correctly after docstring addition by running existing unit tests for parse-jwt, exchange-code-for-token, etc., ensuring no functional changes were introduced. Document the docstrings in project documentation or README to confirm they enhance code maintainability.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-10-16T22:21:53.015Z"
      },
      {
        "id": 18,
        "title": "Extract Magic Numbers to Named Constants in auth0-oauth.lisp",
        "description": "Refactor the auth0-oauth.lisp file to replace hardcoded magic numbers, such as the 300-second state token TTL, with named constants following Common Lisp conventions, including rate limits, timeouts, and other similar values to improve code readability and maintainability.",
        "details": "In the auth0-oauth.lisp file, identify all hardcoded magic numbers related to OAuth functionality, including but not limited to the state token TTL (e.g., 300 seconds), rate limiting thresholds, timeout values, HTTP status codes used in responses, and any other numeric literals that represent configurable or meaningful constants. Define these as named constants using Common Lisp's DEFCONSTANT macro, adhering to naming conventions by enclosing the names in plus signs, such as +STATE-TOKEN-TTL+, +RATE-LIMIT-THRESHOLD+, +REQUEST-TIMEOUT+, etc. Place these constant definitions at the top of the file or in a dedicated constants section for easy reference and modification. Ensure that the constants are evaluated at compile-time where possible for efficiency. Replace all occurrences of the magic numbers with references to these constants throughout the file, using tools like grep or manual inspection to avoid missing any instances. Consider grouping related constants (e.g., all time-related constants together) and adding comments explaining their purpose and units. This refactoring aligns with Common Lisp best practices for code maintainability, as outlined in resources like 'Practical Common Lisp' by Peter Seibel, which emphasizes avoiding magic numbers to make code self-documenting and easier to configure. Be cautious with DEFCONSTANT, as it creates true constants that cannot be redefined without warnings; if runtime configurability is needed, consider DEFPARAMETER instead, but for fixed values like TTLs, DEFCONSTANT is appropriate. After changes, ensure the file compiles without errors and that the constants are accessible in the package namespace.",
        "testStrategy": "Verify the extraction by compiling the auth0-oauth.lisp file and checking for any compilation errors or warnings related to undefined variables. Use a Common Lisp REPL (e.g., SBCL or CCL) to load the file and inspect the defined constants using DESCRIBE or by evaluating them directly to confirm their values match the original magic numbers. Conduct unit tests with a framework like FiveAM or Prove to ensure that functions using these constants (e.g., state token expiration logic) behave identically before and after the change; for instance, create test cases that simulate token creation and expiration, asserting that TTL calculations use the new +STATE-TOKEN-TTL+ constant correctly. Perform integration tests by running the OAuth flow in a test environment, monitoring logs or responses to confirm that timeouts, rate limits, and other behaviors align with the constant values. Use code analysis tools like SLIME in Emacs to search for any remaining magic numbers in the file. Finally, document the constants in the code comments and verify that changing a constant value (e.g., via recompilation) propagates correctly without altering the source code elsewhere.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-10-16T22:20:30.489Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-16T22:35:49.752Z",
      "taskCount": 18,
      "completedCount": 18,
      "tags": [
        "auth0"
      ],
      "created": "2025-10-17T22:17:23.441Z",
      "description": "Tasks for auth0 context",
      "updated": "2025-10-17T22:17:23.441Z"
    }
  },
  "phys-engine": {
    "tasks": [
      {
        "id": 1,
        "title": "Phase 0: Library Validation & Architecture Proof",
        "description": "Validate cl-fast-ecs framework works as expected. Test ECS component/system patterns, ball spawning with custom physics, and performance benchmarking with 500 balls at 60 Hz. Create database schema for physics tables.",
        "details": "**Objective**: Prove the technical approach before full implementation.\n\n**Key Deliverables**:\n1. Install cl-fast-ecs from zip to ~/quicklisp/local-projects/ (NOT from Quicklisp)\n2. Create standalone ECS test: spawn 500 balls with custom physics (position, velocity, acceleration components)\n3. Benchmark performance locally (target: <16ms per frame)\n4. Verify ECS component definitions (ecs:define-component) and systems (ecs:define-system) work\n5. Create database schema SQL files for physics tables (physics_canvas_settings, physics_components)\n6. Optional: Create simple custom ghost predictor test (no Matter.js needed)\n\n**Success Criteria**:\n- cl-fast-ecs loads successfully from local-projects directory\n- 500 balls simulate at 60 Hz using ECS systems with <16ms frame time\n- Component and system macros work as expected\n- Database schema files created and validated\n\n**Files to Create**:\n- backend/tests/ecs-physics-benchmark.lisp (ECS-based physics test)\n- backend/db/physics-schema.sql\n- frontend/tests/simple-predictor-test.html (optional)",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and Verify cl-fast-ecs Framework",
            "description": "Install cl-fast-ecs from the provided zip file to ~/quicklisp/local-projects/ and verify that it loads correctly without errors.",
            "dependencies": [],
            "details": "Extract the cl-fast-ecs zip file to ~/quicklisp/local-projects/cl-fast-ecs/. Run (ql:quickload :cl-fast-ecs) in a Lisp environment to confirm no import errors occur. Verify that the ECS macros (ecs:define-component, ecs:define-system) are available. Document the installation steps and any issues encountered for future reference.",
            "status": "done",
            "testStrategy": "Manual verification by attempting to load the framework and checking that ECS macros are available without runtime errors."
          },
          {
            "id": 2,
            "title": "Create Standalone ECS Performance Test",
            "description": "Develop a standalone test script to spawn 500 balls using cl-fast-ecs with custom physics and measure frame times to assess simulation performance.",
            "dependencies": [
              1
            ],
            "details": "Write a Lisp script (backend/tests/ecs-physics-benchmark.lisp) that creates an ECS storage, defines position/velocity/acceleration components, defines physics systems (apply-acceleration-system, apply-velocity-system), spawns 500 balls with random positions and velocities, runs the simulation for a set duration calling ecs:run-systems, and logs average frame times. Ensure the test is isolated and uses only ECS patterns.",
            "status": "done",
            "testStrategy": "Run the script locally and verify that frame times are logged accurately with <16ms per frame at 60 Hz, aiming for consistency in measurements."
          },
          {
            "id": 3,
            "title": "Benchmark Performance on Fly.io Instance",
            "description": "Deploy and run the performance test on a Fly.io instance to benchmark frame times, targeting less than 16ms per frame at 60 Hz.",
            "dependencies": [
              2
            ],
            "details": "Package the test script for deployment on Fly.io, configure the instance appropriately, execute the benchmark, and collect performance metrics. Compare results against the target and document any optimizations needed for the cloud environment.",
            "status": "done",
            "testStrategy": "Automated execution on Fly.io with logging of frame times; validate that the average stays below 16ms through multiple runs."
          },
          {
            "id": 4,
            "title": "Create Simple Custom Predictor Test",
            "description": "Develop a test HTML page to spawn a ghost ball using simple custom prediction (position + velocity) without a physics engine.",
            "dependencies": [],
            "details": "Create frontend/tests/simple-predictor-test.html with vanilla JavaScript to spawn a ghost ball, update its position using simple velocity-based prediction (ghost.x += ghost.vx * dt), and optionally add simple gravity (ghost.vy += 9.8 * dt). Ensure the test is standalone, lightweight, and renders smoothly in a browser at 60 FPS.",
            "status": "done",
            "testStrategy": "Manual inspection in browser to confirm ghost ball moves correctly with velocity-based prediction and maintains 60 FPS."
          },
          {
            "id": 5,
            "title": "Verify Simple Prediction Accuracy",
            "description": "Test and verify that the simple custom predictor feels responsive and accurately predicts ball movement during the ~100ms server confirmation window.",
            "dependencies": [
              4
            ],
            "details": "Extend the test to spawn multiple ghost balls, simulate ~100ms delay, then replace ghosts with 'server' objects at final positions. Confirm that the prediction feels smooth and responsive. Test optional features like simple gravity and boundary bounce.",
            "status": "done",
            "testStrategy": "Run the test in a browser, spawn balls with various velocities, and verify smooth transitions from ghost to server objects."
          },
          {
            "id": 6,
            "title": "Create Database Schema for Physics Tables",
            "description": "Design and create SQL files for the physics-related database tables: physics_canvas_settings, physics_components, and physics_bodies.",
            "dependencies": [],
            "details": "Write backend/db/physics-schema.sql with CREATE TABLE statements for the specified tables, including appropriate columns, data types, and constraints. Validate the schema by attempting to execute it against a test database instance.",
            "status": "done",
            "testStrategy": "Execute the SQL script on a local database and verify table creation; perform basic INSERT/SELECT operations to ensure schema integrity."
          }
        ]
      },
      {
        "id": 2,
        "title": "Phase 1: Backend Physics Core",
        "description": "Implement the authoritative physics simulation backend using cl-fast-ecs. Create ECS storage per canvas, define components (position, velocity, acceleration, ball, force-field, block), implement custom physics systems, fixed timestep background thread, and WebSocket message handlers.",
        "details": "**Objective**: Build server-authoritative ECS-based physics simulation infrastructure.\n\n**Key Deliverables**:\n\n1. **ECS Storage Management** (backend/src/physics-ecs.lisp):\n   - Create `*physics-canvases*` hash table (canvas-id → ecs-storage)\n   - Implement `init-canvas-physics`, `get-canvas-ecs-storage`, `destroy-canvas-physics`\n   - Configure gravity, simulation rate from database settings\n\n2. **Component Definitions** (backend/src/physics-components.lisp):\n   - Define components using `ecs:define-component`:\n     - `position` (x, y)\n     - `velocity` (vx, vy)\n     - `acceleration` (ax, ay)\n     - `ball` (radius, mass, restitution)\n     - `force-field` (field-type, strength, radius, direction)\n     - `block` (width, height)\n     - `sleeping` (tag component)\n\n3. **Physics Systems** (backend/src/physics-systems.lisp):\n   - `apply-forces-system` - Apply force fields to nearby balls\n   - `apply-acceleration-system` - Update velocity from acceleration\n   - `apply-velocity-system` - Update position from velocity\n   - `collision-system` - Circle-circle and circle-rectangle collision detection\n   - `check-sleeping-system` - Mark/unmark bodies as sleeping\n\n4. **Fixed Timestep Loop** (backend/src/physics-loop.lisp):\n   - Background thread per canvas running at 60 Hz\n   - Call `ecs:run-systems` with dt parameter\n   - Delta broadcasting at 20 Hz (every 3rd tick)\n\n5. **WebSocket Integration** (backend/src/websocket-adapter.lisp):\n   - Add handlers: `physics-spawn-ball`, `physics-toggle-fan`, `physics-adjust-gravity`\n   - Use `ecs:make-object` to create entities\n   - Integrate with existing `handle-ws-message` dispatch\n\n6. **Database Setup**:\n   - Execute physics-schema.sql to create tables\n   - Implement save/load for physics settings and components\n\n**Success Criteria**:\n- Backend simulates 500 balls at 60 Hz using ECS systems\n- Custom physics formulas (gravity, forces, collisions) work correctly\n- Delta updates broadcast to clients at 20 Hz\n- Physics state persists across server restarts",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement ECS Storage Management",
            "description": "Create the ECS storage management system in backend/src/physics-ecs.lisp, including a hash table for canvases, initialization, retrieval, and destruction functions, with gravity and simulation rate configuration from database.",
            "dependencies": [
              6
            ],
            "details": "Develop `*physics-canvases*` hash table mapping canvas-id to ECS storage. Implement `init-canvas-physics`, `get-canvas-ecs-storage`, and `destroy-canvas-physics` functions. Ensure gravity and simulation rate are loaded from database settings. This forms the foundation for all ECS-based physics operations.",
            "status": "done",
            "testStrategy": "Unit tests for hash table operations and function calls; integration tests to verify ECS storage creation and destruction without errors."
          },
          {
            "id": 2,
            "title": "Define ECS Components",
            "description": "Define and implement the ECS components in backend/src/physics-components.lisp using ecs:define-component macros for position, velocity, acceleration, ball, force-field, block, and sleeping.",
            "dependencies": [
              6
            ],
            "details": "Use `ecs:define-component` to define: position (x, y), velocity (vx, vy), acceleration (ax, ay), ball (radius, mass, restitution), force-field (field-type, strength, radius, direction), block (width, height), and sleeping (tag). Ensure all components can be attached to ECS entities and data is properly typed.",
            "status": "done",
            "testStrategy": "Unit tests for component definitions; verify components can be attached to entities using ecs:make-object."
          },
          {
            "id": 3,
            "title": "Build Fixed Timestep Loop with ECS Systems",
            "description": "Implement the fixed timestep background thread in backend/src/physics-loop.lisp, running at 60 Hz calling ECS systems, with delta broadcasting at 20 Hz and body sleeping detection.",
            "dependencies": [
              1,
              2,
              7
            ],
            "details": "Create a background thread per canvas that runs at 60 Hz. Call `ecs:run-systems` with dt=0.016 to execute apply-forces-system, apply-acceleration-system, apply-velocity-system, collision-system, and check-sleeping-system. Broadcast delta updates every 3rd tick (20 Hz). Integrate with ECS storage management for proper storage access.",
            "status": "done",
            "testStrategy": "Performance benchmarks to confirm 60 Hz stability with 500 balls using ECS systems; tests for delta broadcasting frequency and body sleeping accuracy."
          },
          {
            "id": 4,
            "title": "Integrate WebSocket Handlers",
            "description": "Add WebSocket message handlers in backend/src/websocket-adapter.lisp for physics operations like spawning balls, toggling fans, and adjusting gravity, integrating with existing dispatch.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement handlers for `physics-spawn-ball`, `physics-toggle-fan`, and `physics-adjust-gravity`. Use `ecs:make-object` to create entities with appropriate components. Integrate seamlessly with the existing `handle-ws-message` dispatch system for real-time operations.",
            "status": "done",
            "testStrategy": "Integration tests for WebSocket message handling; end-to-end tests simulating client interactions and verifying ECS entity creation and state changes."
          },
          {
            "id": 5,
            "title": "Set Up Database Integration",
            "description": "Execute physics-schema.sql to create necessary tables and implement save/load functionality for physics settings and components.",
            "dependencies": [],
            "details": "Run the SQL script to set up database tables for physics data. Develop functions to save and load physics settings (e.g., gravity) and component states. Ensure persistence across server restarts, linking to universe management for configuration loading.",
            "status": "done",
            "testStrategy": "Database unit tests for save/load operations; integration tests to verify data persistence and retrieval after restarts."
          },
          {
            "id": 6,
            "title": "Integrate cl-fast-ecs into ASDF System",
            "description": "Update the collabcanvas.asd ASDF system definition to include cl-fast-ecs as a dependency and add all new physics module files to the :components list.",
            "details": "Modify backend/collabcanvas.asd to add :cl-fast-ecs to the :depends-on list. Add new physics files to :components: physics-ecs.lisp, physics-components.lisp, physics-systems.lisp, physics-loop.lisp, and websocket-adapter.lisp (if new). Ensure the load order is correct (components before systems, systems before loop). Verify the system loads with (ql:quickload :collabcanvas) and that cl-fast-ecs macros are available in the collabcanvas package. Create a package.lisp entry to export physics-related functions.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 7,
            "title": "Implement Physics Systems",
            "description": "Define and implement all ECS physics systems in backend/src/physics-systems.lisp using ecs:define-system macros for forces, acceleration, velocity, collision detection, and sleeping.",
            "details": "Use `ecs:define-system` to implement: (1) apply-forces-system - iterates through force-field components and applies forces to nearby ball entities based on distance/strength/type, (2) apply-acceleration-system - updates velocity components from acceleration (vx += ax*dt, vy += ay*dt), adds global gravity, (3) apply-velocity-system - updates position from velocity (x += vx*dt, y += vy*dt), (4) collision-system - detects circle-circle collisions between ball entities and circle-rectangle collisions with block entities, applies elastic collision response using restitution, (5) check-sleeping-system - marks entities with velocity magnitude < 0.01 as sleeping, unmarks when forces applied. Ensure proper system ordering and performance optimization for 500+ entities.",
            "status": "done",
            "dependencies": [
              2
            ],
            "parentTaskId": 2
          }
        ]
      },
      {
        "id": 3,
        "title": "Phase 2: Frontend Integration",
        "description": "Implement simple client-side ghost prediction (no physics engine needed) and integrate with existing PixiJS canvas. Create custom ghost predictor, extend CanvasManager for physics rendering, add WebSocket message handling, and build UI controls for spawning balls and toggling fans.",
        "details": "**Objective**: Create responsive client-side experience with simple custom prediction.\n\n**Key Deliverables**:\n\n1. **Simple Ghost Predictor** (frontend/src/physics-predictor.js):\n   - NO physics engine needed - just custom position + velocity prediction\n   - `spawnGhost(ghostId, x, y, vx, vy)` - create ghost with initial velocity\n   - `step(dt)` - simple update: `ghost.x += ghost.vx * dt; ghost.y += ghost.vy * dt`\n   - `removeGhost(ghostId)` - remove ghost after server confirmation\n   - Optional: add simple gravity (`ghost.vy += 9.8 * dt`)\n   - Optional: add boundary bounce for realism\n\n2. **Physics Renderer** (frontend/src/physics-renderer.js):\n   - Extend existing CanvasManager class\n   - Render ghost balls (semi-transparent, dashed outline)\n   - Render server balls with interpolation (20 Hz → 60 FPS smoothing)\n   - Interpolation: `ball.currentX += (ball.serverX - ball.currentX) * 0.3`\n   - Render force field visualizations (fans with arrows, gravity wells)\n   - Preserve existing viewport culling and performance monitoring\n\n3. **WebSocket Message Handling** (frontend/src/websocket.js):\n   - Add cases: `physics-ball-created`, `physics-update`, `physics-fan-toggled`\n   - Handle delta updates and apply to server ball state\n   - Trigger ghost confirmation on ball creation confirmation\n\n4. **UI Controls** (frontend/index.html + physics-ui.js):\n   - \"Spawn Ball\" button (or click-to-spawn mode)\n   - Fan toggle buttons for existing fans\n   - Gravity adjustment slider (-20 to +20 m/s²)\n   - Physics stats overlay (FPS, object count, active/sleeping)\n\n**Success Criteria**:\n- Ghost balls appear instantly on client click (<5ms perceived latency)\n- Simple velocity-based prediction feels responsive\n- Server confirmation smoothly transitions ghost → server object\n- Force fields visually indicate active state\n- Maintains 60 FPS with 500 active balls",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Simple Ghost Predictor",
            "description": "Create the physics-predictor.js module using simple custom prediction (position + velocity) for ghost objects, without any physics engine.",
            "dependencies": [],
            "details": "Develop frontend/src/physics-predictor.js with simple velocity-based prediction. Implement spawnGhost(ghostId, x, y, vx, vy) to create ghosts with initial velocity, step(dt) to update positions using ghost.x += ghost.vx * dt, and removeGhost(ghostId) to remove after server confirmation. Optionally add simple gravity (ghost.vy += 9.8 * dt) and boundary bounce. Ensure lightweight implementation with <5ms prediction latency.",
            "status": "done",
            "testStrategy": "Unit tests for spawn/step/remove methods, performance benchmarks to verify <5ms latency, and integration tests with 100+ ghosts."
          },
          {
            "id": 2,
            "title": "Extend Canvas Manager for Physics Rendering",
            "description": "Modify the existing CanvasManager class in physics-renderer.js to render ghost balls, server balls with interpolation, and force field visualizations while maintaining viewport culling and performance monitoring.",
            "dependencies": [
              1
            ],
            "details": "Extend frontend/src/physics-renderer.js to render semi-transparent ghost balls with dashed outlines, server balls with 20 Hz → 60 FPS interpolation (ball.currentX += (ball.serverX - ball.currentX) * 0.3), and force field visualizations (fans with arrows). Integrate with PixiJS canvas, preserve culling and monitoring, and ensure smooth ghost-to-server transitions.",
            "status": "done",
            "testStrategy": "Visual rendering tests for ghost appearances and interpolation smoothness, FPS monitoring with 500 active balls, and ghost transition tests."
          },
          {
            "id": 3,
            "title": "Add WebSocket Message Handling for Physics",
            "description": "Update websocket.js to handle new message types like physics-ball-created, physics-update, and physics-fan-toggled, applying delta updates and triggering ghost confirmations.",
            "dependencies": [
              1,
              2
            ],
            "details": "Enhance frontend/src/websocket.js with cases for physics messages. Handle delta updates to server ball states, confirm ghosts upon ball creation, and manage fan toggles. Ensure synchronization between client prediction and server state for responsive experience.",
            "status": "done",
            "testStrategy": "Message handling unit tests, end-to-end tests for WebSocket communication, and latency measurements for ghost confirmations."
          },
          {
            "id": 4,
            "title": "Develop UI Controls for Physics Interaction",
            "description": "Build UI elements in index.html and physics-ui.js for spawning balls, toggling fans, adjusting gravity, and displaying physics stats overlay.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Add 'Spawn Ball' button or click-to-spawn, fan toggle buttons, gravity slider (range -20 to +20 m/s²), and stats overlay for FPS and object count in frontend/index.html and physics-ui.js. Integrate with WebSocket for backend communication and ensure UI responsiveness.",
            "status": "done",
            "testStrategy": "UI interaction tests for button clicks and slider adjustments, integration tests with WebSocket messages, and performance checks for overlay updates."
          }
        ]
      },
      {
        "id": 4,
        "title": "Phase 3: Multiplayer Sync & Polish",
        "description": "Optimize real-time synchronization, implement delta compression, add bandwidth and latency monitoring, create determinism tests, and perform load testing with multiple clients and 500+ balls.",
        "details": "**Objective**: Ensure robust multiplayer experience with performance optimization.\n\n**Key Deliverables**:\n\n1. **Delta Compression Optimization**:\n   - Only send changed properties (position, velocity, rotation)\n   - Skip objects with velocity < 0.01 (sleeping)\n   - Batch deltas into single message per broadcast\n   - Measure bandwidth reduction (target: <280 KB/sec per client)\n\n2. **Monitoring & Metrics**:\n   - Extend existing LatencyMonitor for physics messages\n   - Track bandwidth per message type\n   - Add physics-specific stats: bodies active/sleeping, update rate\n   - Log high latency warnings (>100ms)\n\n3. **Determinism Testing**:\n   - Create test script that spawns identical scenarios on server\n   - Verify same initial conditions → same final state after 10 seconds\n   - Test edge cases: simultaneous spawns, rapid force field toggles\n\n4. **Load Testing**:\n   - Set up 2 clients + 500 balls scenario\n   - Measure frame times, network bandwidth, server CPU usage\n   - Identify bottlenecks and optimize hot paths\n   - Document performance results in .taskmaster/docs/\n\n5. **Error Handling**:\n   - Handle WebSocket disconnection during physics simulation\n   - Graceful degradation: disable ghost prediction if server lags\n   - Add reconnection recovery (full state sync on reconnect)\n\n**Success Criteria**:\n- Bandwidth reduced by >50% compared to full state broadcasting\n- Server maintains 60 Hz simulation with 500 balls across 2 clients\n- Determinism test passes 100% of time\n- Perceived latency <50ms for ghost spawns\n- No visual artifacts during reconnection",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Delta Compression Optimization",
            "description": "Optimize real-time synchronization by implementing delta compression to reduce bandwidth usage. This involves sending only changed properties like position, velocity, and rotation, skipping sleeping objects, and batching deltas.",
            "dependencies": [],
            "details": "Modify the WebSocket message handlers to track and send only deltas for changed properties (position, velocity, rotation). Implement logic to skip objects with velocity < 0.01. Batch multiple deltas into a single message per broadcast. Measure and ensure bandwidth reduction to <280 KB/sec per client.",
            "status": "done",
            "testStrategy": "Measure bandwidth usage during multiplayer sessions with multiple balls and verify reduction compared to full state broadcasting."
          },
          {
            "id": 2,
            "title": "Add Monitoring and Metrics for Performance",
            "description": "Extend the existing LatencyMonitor to track bandwidth, latency, and physics-specific stats for better performance insights.",
            "dependencies": [],
            "details": "Integrate monitoring for physics messages, track bandwidth per message type, add stats for active/sleeping bodies and update rates. Implement logging for high latency warnings (>100ms). Ensure metrics are accessible for debugging and optimization.",
            "status": "done",
            "testStrategy": "Run sessions with varying loads and check logs for accurate metrics and warnings."
          },
          {
            "id": 3,
            "title": "Create Determinism Testing Framework",
            "description": "Develop a test script to ensure deterministic behavior in physics simulations across server and clients.",
            "dependencies": [],
            "details": "Build a test script that spawns identical scenarios on the server, verifies that same initial conditions lead to the same final state after 10 seconds. Include tests for edge cases like simultaneous spawns and rapid force field toggles.",
            "status": "done",
            "testStrategy": "Execute the test script multiple times and confirm 100% pass rate for determinism."
          },
          {
            "id": 4,
            "title": "Perform Load Testing with Multiple Clients",
            "description": "Set up and execute load testing scenarios with 2 clients and 500+ balls to identify and optimize bottlenecks.",
            "dependencies": [],
            "details": "Configure a test environment with 2 clients and 500 balls, measure frame times, network bandwidth, and server CPU usage. Identify hot paths and optimize them. Document results in .taskmaster/docs/.",
            "status": "done",
            "testStrategy": "Analyze performance metrics during load tests and ensure server maintains 60 Hz simulation."
          },
          {
            "id": 5,
            "title": "Implement Error Handling for Disconnections",
            "description": "Add robust error handling for WebSocket disconnections and reconnection recovery during physics simulations.",
            "dependencies": [],
            "details": "Handle disconnections gracefully by disabling ghost prediction if server lags. Implement full state sync on reconnection. Ensure no visual artifacts and perceived latency <50ms for ghost spawns.",
            "status": "done",
            "testStrategy": "Simulate disconnections and reconnections, verify graceful degradation and accurate state recovery."
          }
        ]
      },
      {
        "id": 5,
        "title": "Phase 4: Component System & Extensibility",
        "description": "Demonstrate extensibility by implementing gravity adjustment UI and one post-MVP component (emitter or magnet). Document the component API for future additions, perform performance profiling, and create developer documentation.",
        "details": "**Objective**: Prove architecture supports easy addition of new physics features.\n\n**Key Deliverables**:\n\n1. **Gravity Adjustment Feature**:\n   - UI slider in physics control panel (range: -20 to +20 m/s²)\n   - Backend handler: `physics-adjust-gravity` message\n   - Update global gravity in ECS acceleration system\n   - Broadcast gravity change to all clients\n   - Persist gravity setting in physics_canvas_settings table\n\n2. **Post-MVP Component** (choose one):\n   - **Emitter**: Shoots balls at interval (rate, direction, velocity)\n   - **Magnet**: Attracts/repels balls within radius (strength, polarity)\n   - Implement full backend component lifecycle\n   - Create frontend visualization and controls\n\n3. **Developer Documentation** (.taskmaster/docs/PHYSICS_COMPONENTS.md):\n   - How to add new component types\n   - Component lifecycle: creation → force application → destruction\n   - Frontend rendering guide for component visualizations\n   - Example: Step-by-step emitter implementation walkthrough\n\n4. **Performance Profiling**:\n   - Profile backend physics loop with SBCL profiler\n   - Identify most expensive operations (collision detection, force application)\n   - Document results and optimization opportunities\n   - Create performance baseline for future comparison\n\n5. **Architecture Validation**:\n   - Review: Can magnets be added in <4 hours using existing API?\n   - Review: Can custom force field shapes be added easily?\n   - Document any API gaps or friction points\n\n**Success Criteria**:\n- Gravity slider works smoothly in real-time\n- Post-MVP component fully functional (emitter shoots balls OR magnet attracts)\n- Developer docs enable new team member to add component in <1 day\n- Performance profiling identifies top 3 optimization opportunities\n- No major refactoring needed for post-MVP component",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "low",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Gravity Adjustment UI and Backend",
            "description": "Add a UI slider in the physics control panel for adjusting gravity from -20 to +20 m/s², implement the backend handler for 'physics-adjust-gravity' message, update the global gravity in ECS acceleration system, broadcast changes to all clients, and persist the setting in the physics_canvas_settings table.",
            "dependencies": [],
            "details": "Create a slider component in the frontend physics control panel with range -20 to 20. On the backend, add a WebSocket message handler to receive gravity adjustments, update the global gravity value used by the ECS apply-acceleration-system, broadcast the new gravity value to all connected clients, and update the database table for persistence. Ensure real-time updates without lag.",
            "status": "done",
            "testStrategy": "Manually test slider interaction, verify backend updates gravity in ECS system, check broadcasting to clients, and confirm persistence by restarting the server."
          },
          {
            "id": 2,
            "title": "Implement Emitter Post-MVP Component",
            "description": "Develop the emitter component that shoots balls at specified intervals, including rate, direction, and velocity controls. Implement the full backend lifecycle for creation, force application, and destruction, along with frontend visualization and controls.",
            "dependencies": [],
            "details": "Define the emitter as a new physics component class in the backend, with properties for emission rate, direction, and velocity. Add methods for spawning balls periodically in the physics loop. On the frontend, create UI controls for configuring the emitter and render its visualization (e.g., an icon or shape). Integrate with the component system to handle creation via WebSocket messages and destruction.",
            "status": "done",
            "testStrategy": "Spawn an emitter, verify balls are emitted at the correct rate and trajectory, test UI controls for adjustments, and ensure component can be destroyed without errors."
          },
          {
            "id": 3,
            "title": "Create Developer Documentation for Component API",
            "description": "Write comprehensive documentation in .taskmaster/docs/PHYSICS_COMPONENTS.md explaining how to add new component types, the component lifecycle, frontend rendering guides, and a step-by-step example for implementing an emitter.",
            "dependencies": [
              2
            ],
            "details": "Document the base physics-component class, lifecycle methods (creation, force application, destruction), API for registering new components, and guidelines for frontend visualizations. Include a detailed walkthrough of adding an emitter, with code snippets for backend and frontend integration. Ensure the docs are clear enough for a new developer to add a component in under a day.",
            "status": "done",
            "testStrategy": "Have a team member follow the documentation to add a simple component and verify it works as expected."
          },
          {
            "id": 4,
            "title": "Perform Performance Profiling of Physics Loop",
            "description": "Use SBCL profiler to analyze the backend physics loop, identify the most expensive operations like collision detection and force application, document results, and suggest optimization opportunities while establishing a performance baseline.",
            "dependencies": [
              1,
              2
            ],
            "details": "Instrument the physics simulation code with profiling tools, run simulations with various loads (e.g., multiple balls and components), measure execution times for key functions, and compile a report highlighting top bottlenecks. Compare against target frame times and note areas for improvement, such as optimizing collision algorithms or reducing force calculations.",
            "status": "done",
            "testStrategy": "Run profiling under different scenarios (e.g., 100 balls vs. 500 balls), validate that profiling tools capture accurate data, and ensure optimizations suggested do not break functionality."
          },
          {
            "id": 5,
            "title": "Validate Architecture for Extensibility",
            "description": "Review the API to assess if magnets can be added in under 4 hours, evaluate ease of adding custom force field shapes, and document any gaps or friction points in the component system.",
            "dependencies": [
              2,
              3
            ],
            "details": "Conduct a code review and mock implementation of a magnet component using the existing API, timing the process. Attempt to add a simple custom force field shape (e.g., a circle) and note any required changes. Compile findings into a report on API strengths, weaknesses, and recommendations for improvements to support future extensibility.",
            "status": "done",
            "testStrategy": "Time the addition of a magnet component, verify it integrates seamlessly, and test custom force fields for functionality and performance."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-10-17T21:53:49.245Z",
      "updated": "2025-10-18T02:52:08.075Z",
      "description": "Tasks for phys-engine context"
    }
  }
}