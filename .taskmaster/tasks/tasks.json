{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up project structure and dependencies",
        "description": "Initialize the backend and frontend project structures, install required libraries and tools as specified in the technical stack.",
        "details": "For backend: Use Roswell to set up SBCL Common Lisp project with ASDF system definition. Install Hunchentoot, Hunchensocket, cl-sqlite, Jonathan, Ironclad, Bordeaux-threads via Quicklisp. For frontend: Initialize Vite project with PixiJS v7, vanilla JavaScript ES6+. Create directory structures as per architecture (backend/src/, frontend/src/). Ensure Docker setup with Debian base.",
        "testStrategy": "Verify backend loads in REPL with (ql:quickload :collabcanvas). Check frontend builds with npm run build. Confirm all dependencies are installed without errors.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize backend project structure with Roswell and SBCL",
            "description": "Set up the Common Lisp project using Roswell to initialize SBCL with ASDF system definition and create the backend/src/ directory structure.",
            "dependencies": [],
            "details": "Use Roswell to create a new SBCL project named 'collabcanvas' with ASDF system definition. Ensure the project structure includes backend/src/ for source files. Verify that the ASDF system loads correctly in the REPL.",
            "status": "done",
            "testStrategy": "Load the project in SBCL REPL and check that the ASDF system is defined without errors.",
            "updatedAt": "2025-10-13T21:24:51.583Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Install backend dependencies via Quicklisp",
            "description": "Install the required Common Lisp libraries including Hunchentoot, Hunchensocket, cl-sqlite, Jonathan, Ironclad, and Bordeaux-threads using Quicklisp.",
            "dependencies": [
              1
            ],
            "details": "After setting up the backend project, use Quicklisp to install Hunchentoot for web server, Hunchensocket for WebSockets, cl-sqlite for database, Jonathan for JSON handling, Ironclad for cryptography, and Bordeaux-threads for threading. Ensure all packages are available and loadable.",
            "status": "done",
            "testStrategy": "Run (ql:quickload :collabcanvas) in the REPL and confirm all dependencies load without errors.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:24:52.880Z"
          },
          {
            "id": 3,
            "title": "Initialize frontend project with Vite and PixiJS",
            "description": "Set up the frontend project using Vite for build tooling and initialize with PixiJS v7 and vanilla JavaScript ES6+, creating the frontend/src/ directory.",
            "dependencies": [],
            "details": "Use npm or yarn to initialize a Vite project in the frontend directory. Install PixiJS v7 as a dependency. Create the frontend/src/ structure for source files. Configure Vite for vanilla JS ES6+ development.",
            "status": "done",
            "testStrategy": "Run npm run build in the frontend directory and verify that the build completes successfully with PixiJS integrated.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:24:54.220Z"
          },
          {
            "id": 4,
            "title": "Install frontend dependencies",
            "description": "Ensure all frontend dependencies are installed, focusing on PixiJS v7 and any additional tools required for the project.",
            "dependencies": [
              3
            ],
            "details": "After initializing the Vite project, install PixiJS v7 and confirm that the package.json includes all necessary dependencies for vanilla JS ES6+ development. Check for any peer dependencies and resolve them.",
            "status": "done",
            "testStrategy": "Check that npm install completes without errors and that PixiJS can be imported in a test JS file.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:24:55.568Z"
          },
          {
            "id": 5,
            "title": "Set up Docker environment with Debian base",
            "description": "Create a Docker setup using Debian base image to containerize the project, ensuring both backend and frontend can run within the container.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Write a Dockerfile with Debian base image. Include instructions to install SBCL, Roswell, Node.js, and other necessary tools. Copy project files and set up commands to run the backend and frontend. Ensure the container can build and run the application.",
            "status": "done",
            "testStrategy": "Build the Docker image and run the container, verifying that both backend and frontend start without errors.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:24:56.916Z"
          }
        ],
        "updatedAt": "2025-10-13T21:24:56.916Z"
      },
      {
        "id": 2,
        "title": "Implement database schema and setup",
        "description": "Create and initialize the SQLite database with the required tables for users, sessions, and canvas states.",
        "details": "Use cl-sqlite to execute the schema.sql file creating users, sessions, and canvas_states tables. Include indexes for performance. Ensure database file is created in data/ directory. Implement utility functions in database.lisp for connecting and executing queries.",
        "testStrategy": "Run SQLite commands to verify tables exist and constraints are enforced. Insert test data and query to confirm integrity.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create schema.sql file with table definitions",
            "description": "Define the SQL schema for users, sessions, and canvas_states tables including columns, data types, and constraints.",
            "dependencies": [],
            "details": "Write a schema.sql file that includes CREATE TABLE statements for users (id, email, username, password_hash), sessions (id, user_id, session_id, expires_at), and canvas_states (id, session_id, state_json). Add PRIMARY KEY and UNIQUE constraints, and indexes for performance on frequently queried columns like email and session_id.",
            "status": "pending",
            "testStrategy": "Validate the SQL syntax by attempting to execute it in a SQLite environment and check for errors.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement database connection utility",
            "description": "Create functions in database.lisp to establish a connection to the SQLite database.",
            "dependencies": [
              1
            ],
            "details": "In database.lisp, define a function to connect to the SQLite database file located in the data/ directory, using cl-sqlite. Ensure the connection is reusable and handle any connection errors gracefully.",
            "status": "pending",
            "testStrategy": "Call the connection function and verify that the database file is created in data/ if it doesn't exist, and that subsequent calls reuse the connection.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Execute schema.sql to initialize database",
            "description": "Run the schema.sql file to create the tables and indexes in the database.",
            "dependencies": [
              2
            ],
            "details": "Implement a function in database.lisp that reads and executes the schema.sql file using the established database connection. Ensure all tables are created with their indexes and constraints.",
            "status": "pending",
            "testStrategy": "After execution, query the database to confirm that tables users, sessions, and canvas_states exist with the correct columns and indexes.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement query execution utilities",
            "description": "Add functions for executing SQL queries and statements in database.lisp.",
            "dependencies": [
              3
            ],
            "details": "Define utility functions for executing SELECT, INSERT, UPDATE, and DELETE queries, handling parameters securely to prevent SQL injection. Include functions for fetching results and handling transactions.",
            "status": "pending",
            "testStrategy": "Write and execute test queries to insert sample data into the tables and retrieve it, verifying that the utilities work correctly and data integrity is maintained.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Verify database setup and file location",
            "description": "Ensure the database file is correctly placed and the setup is complete.",
            "dependencies": [
              4
            ],
            "details": "Check that the SQLite database file is created in the data/ directory. Run a final verification to ensure all tables, indexes, and constraints are properly set up and functional.",
            "status": "pending",
            "testStrategy": "Use SQLite commands to inspect the database file, confirm table structures, and perform basic operations to ensure everything is working as expected.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-13T21:24:58.407Z"
      },
      {
        "id": 3,
        "title": "Implement authentication backend",
        "description": "Develop the authentication system including user registration, login, logout, and session management using SHA-256 hashing.",
        "details": "In auth.lisp, implement functions for hashing passwords with Ironclad, creating sessions, validating logins. Add HTTP endpoints /api/register, /api/login, /api/logout using Hunchentoot. Store sessions in SQLite with 24-hour expiry. Handle unique constraints for email and username.",
        "testStrategy": "Use curl to test registration, login, and logout endpoints. Verify session persistence and expiry. Check database for correct data insertion.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up database schema for users and sessions",
            "description": "Create SQLite tables for users (with email, username, hashed password) and sessions (with session ID, user ID, expiry timestamp). Ensure unique constraints on email and username.",
            "dependencies": [],
            "details": "In the database setup, define a 'users' table with columns: id (primary key), email (unique), username (unique), password_hash (text). Define a 'sessions' table with columns: id (primary key), user_id (foreign key to users), session_id (unique), created_at (timestamp), expires_at (timestamp). Use SQLite pragmas for foreign keys.\n<info added on 2025-10-13T20:19:17.572Z>\nInstead of creating new tables, this subtask should confirm that Task 2 successfully created the users and sessions tables with the correct columns and constraints. Query the SQLite database schema using PRAGMA table_info or similar to validate the structure: users table with id (primary key), email (unique), username (unique), password_hash (text); sessions table with id (primary key), user_id (foreign key to users), session_id (unique), created_at (timestamp), expires_at (timestamp). Ensure foreign key constraints are enabled and unique constraints are in place on email and username. Raise errors if the schema does not match expectations.\n</info added on 2025-10-13T20:19:17.572Z>",
            "status": "pending",
            "testStrategy": "Verify table creation by querying the database schema and inserting test data to confirm unique constraints.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement password hashing function",
            "description": "Develop a function to hash passwords using SHA-256 with Ironclad library.",
            "dependencies": [
              1
            ],
            "details": "In auth.lisp, define a function hash-password that takes a plain password string, uses Ironclad to compute SHA-256 hash, and returns the hex-encoded string. Ensure it handles UTF-8 encoding properly.",
            "status": "pending",
            "testStrategy": "Unit test the function with known inputs and verify outputs match expected SHA-256 hashes.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement user registration endpoint",
            "description": "Create the /api/register HTTP endpoint to handle user registration with email, username, and password.",
            "dependencies": [
              1,
              2
            ],
            "details": "Using Hunchentoot, add a POST handler for /api/register that parses JSON body for email, username, password. Validate inputs, hash password, insert into users table, handle unique constraint violations by returning appropriate error responses.",
            "status": "pending",
            "testStrategy": "Use curl to send POST requests with valid and invalid data, check for successful registration and error messages for duplicates.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement login endpoint with session creation",
            "description": "Create the /api/login HTTP endpoint to validate credentials and create a session.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Add a POST handler for /api/login that takes email/username and password. Query user by email or username, verify password hash, generate a unique session ID, insert into sessions table with 24-hour expiry, return session ID in response.",
            "status": "pending",
            "testStrategy": "Test login with correct and incorrect credentials using curl, verify session creation in database and response contains session ID.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement logout endpoint and session management",
            "description": "Create the /api/logout HTTP endpoint to invalidate sessions.",
            "dependencies": [
              4
            ],
            "details": "Add a POST handler for /api/logout that takes session ID, deletes the session from the database. Optionally, implement session validation middleware for protected endpoints to check expiry.",
            "status": "pending",
            "testStrategy": "Login to get a session, call logout, verify session is removed from database, and test that expired sessions are invalidated.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-13T21:24:59.652Z"
      },
      {
        "id": 4,
        "title": "Implement authentication frontend",
        "description": "Create the login/register modal UI and logic for handling authentication on the client side.",
        "details": "In auth.js, build modal with tabs for login/register, fields for email, password, username. Use fetch API to call backend endpoints. Store sessionId in localStorage. Block canvas access until authenticated. Handle errors and display messages.",
        "testStrategy": "Open app, attempt registration and login. Verify modal blocks canvas, session persists on refresh. Test invalid credentials error handling.",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create modal UI structure with tabs",
            "description": "Build the basic HTML structure for the authentication modal including tabs for login and register.",
            "dependencies": [],
            "details": "In auth.js, create a modal element with two tabs: one for login and one for register. Use CSS to style the modal as an overlay that appears when authentication is required. Ensure the modal is hidden by default and can be toggled.",
            "status": "done",
            "testStrategy": "Open the app and verify the modal appears with login and register tabs visible.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:27:24.151Z"
          },
          {
            "id": 2,
            "title": "Add form fields for login and register",
            "description": "Implement input fields for email, password, and username in the respective tabs.",
            "dependencies": [
              1
            ],
            "details": "In the login tab, add fields for email and password. In the register tab, add fields for email, password, and username. Include submit buttons for each form. Validate that required fields are filled before submission.",
            "status": "done",
            "testStrategy": "Switch between tabs and confirm fields are present and functional.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:10.289Z"
          },
          {
            "id": 3,
            "title": "Implement fetch API calls to backend endpoints",
            "description": "Set up logic to send POST requests to /api/login and /api/register using fetch API.",
            "dependencies": [
              2
            ],
            "details": "On form submission, collect form data and use fetch to call the appropriate backend endpoint. Handle the response asynchronously. Prepare for storing sessionId on success.",
            "status": "done",
            "testStrategy": "Submit forms with valid data and check network requests in browser dev tools.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:11.618Z"
          },
          {
            "id": 4,
            "title": "Handle authentication success and session storage",
            "description": "Process successful login/register responses by storing sessionId and unblocking canvas access.",
            "dependencies": [
              3
            ],
            "details": "Upon successful response, store the sessionId in localStorage. Hide the modal and allow access to the canvas. Check for existing sessionId on app load to skip modal if already authenticated.",
            "status": "done",
            "testStrategy": "Register and login, then refresh the page to verify session persists and canvas is accessible.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:12.950Z"
          },
          {
            "id": 5,
            "title": "Implement error handling and message display",
            "description": "Add logic to display error messages for failed authentication attempts.",
            "dependencies": [
              3
            ],
            "details": "On failed responses, parse error messages from the backend and display them in the modal. Clear messages on successful attempts. Ensure the modal remains open on errors.",
            "status": "done",
            "testStrategy": "Attempt login/register with invalid credentials and verify error messages appear.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:14.350Z"
          }
        ],
        "updatedAt": "2025-10-13T21:28:14.350Z"
      },
      {
        "id": 5,
        "title": "Set up WebSocket server infrastructure",
        "description": "Establish the WebSocket server with room management for canvas collaboration.",
        "details": "In websocket.lisp, create canvas-room class with thread-safe client lists. Implement connection handling, message routing for auth, cursor, object operations. Use Hunchensocket for WebSocket acceptor. Add functions for broadcasting messages to room members.",
        "testStrategy": "Start server and connect via browser console WebSocket. Send test messages and verify routing and broadcasting. Check room creation and client addition/removal.",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Hunchensocket WebSocket acceptor",
            "description": "Initialize the WebSocket server using Hunchensocket library in websocket.lisp.",
            "dependencies": [],
            "details": "Configure Hunchensocket to create a WebSocket acceptor that listens on a specified port, handling the basic setup for WebSocket connections.",
            "status": "pending",
            "testStrategy": "Start the server and verify that it listens on the port without errors, using a simple connection test.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create canvas-room class with thread-safe client lists",
            "description": "Define the canvas-room class to manage rooms for canvas collaboration.",
            "dependencies": [
              1
            ],
            "details": "In websocket.lisp, implement a canvas-room class that includes thread-safe lists for managing connected clients, ensuring safe concurrent access.",
            "status": "pending",
            "testStrategy": "Instantiate the class and perform basic operations like adding/removing clients in a multi-threaded environment to check for race conditions.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement WebSocket connection handling",
            "description": "Handle client connections and disconnections for the WebSocket server.",
            "dependencies": [
              2
            ],
            "details": "Add logic to accept incoming WebSocket connections, associate them with canvas rooms, and manage client addition/removal from room lists upon connect/disconnect.",
            "status": "pending",
            "testStrategy": "Connect multiple clients via browser console and verify they are added to the room; disconnect and check removal.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement message routing for auth, cursor, and object operations",
            "description": "Set up routing for different types of WebSocket messages.",
            "dependencies": [
              3
            ],
            "details": "In websocket.lisp, create handlers for message types including authentication, cursor updates, and object operations, parsing incoming messages and dispatching to appropriate functions.",
            "status": "pending",
            "testStrategy": "Send test messages of each type from a client and verify they are routed correctly, logging the handling process.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add broadcasting functions for room members",
            "description": "Implement functions to broadcast messages to all clients in a room.",
            "dependencies": [
              4
            ],
            "details": "Create utility functions in websocket.lisp that iterate over the thread-safe client lists in a canvas-room and send messages to all connected members.",
            "status": "pending",
            "testStrategy": "Connect multiple clients to a room, send a broadcast message, and verify all clients receive it via console logs.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-13T21:25:01.037Z"
      },
      {
        "id": 6,
        "title": "Implement canvas rendering with PixiJS",
        "description": "Set up the PixiJS application for the infinite canvas with basic rendering.",
        "details": "In canvas.js, initialize PIXI.Application with full viewport. Create Container for world space. Implement grid rendering at 50px intervals. Set up event listeners for mouse interactions. Define screenToWorld and worldToScreen conversion functions.",
        "testStrategy": "Load canvas, verify PixiJS renders grid correctly. Check coordinate conversions with console logs. Ensure canvas fills viewport without scrollbars.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize PIXI.Application with full viewport",
            "description": "Set up the PIXI.Application instance to fill the entire viewport without scrollbars.",
            "dependencies": [],
            "details": "In canvas.js, create a new PIXI.Application with options for width and height set to window.innerWidth and window.innerHeight, and append its view to the document body. Ensure it resizes dynamically with window resize events.",
            "status": "pending",
            "testStrategy": "Load the canvas and verify that PixiJS application renders and fills the viewport completely without any scrollbars appearing.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Container for world space",
            "description": "Establish a PIXI.Container to represent the infinite world space for objects.",
            "dependencies": [
              1
            ],
            "details": "After initializing the PIXI.Application, create a new PIXI.Container instance and add it to the application's stage. This container will hold all world-space objects and transformations.",
            "status": "pending",
            "testStrategy": "Check that the container is added to the stage and can hold child objects by adding a test sprite and confirming it renders.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement grid rendering at 50px intervals",
            "description": "Render a visual grid on the canvas to aid in object placement and navigation.",
            "dependencies": [
              2
            ],
            "details": "In the world container, create PIXI.Graphics to draw horizontal and vertical lines at 50px intervals in world coordinates. Update the grid rendering on zoom and pan events to maintain visibility.",
            "status": "pending",
            "testStrategy": "Zoom and pan the canvas, verify the grid lines appear at correct 50px intervals and adjust dynamically with transformations.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Set up event listeners for mouse interactions",
            "description": "Add mouse event handlers for basic interactions like clicking and dragging.",
            "dependencies": [
              1
            ],
            "details": "Attach event listeners to the PIXI.Application view for 'mousedown', 'mousemove', and 'mouseup' events. Store mouse positions and states to handle interactions such as panning or selecting.",
            "status": "pending",
            "testStrategy": "Click and drag on the canvas, use console logs to verify that mouse events are captured and positions are recorded accurately.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Define screenToWorld and worldToScreen conversion functions",
            "description": "Implement utility functions to convert between screen and world coordinates.",
            "dependencies": [
              2
            ],
            "details": "Create functions screenToWorld(x, y) and worldToScreen(x, y) that account for the world container's position, scale, and rotation. Use these for accurate object placement and interaction in world space.",
            "status": "pending",
            "testStrategy": "Use console logs to test coordinate conversions by logging screen positions and their world equivalents, ensuring accuracy during zoom and pan.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-13T21:25:02.354Z"
      },
      {
        "id": 7,
        "title": "Implement pan and zoom functionality",
        "description": "Add pan and zoom controls to the canvas for navigation.",
        "details": "In canvas.js, handle middle-click or Alt+left-click drag for pan. Implement mouse wheel zoom with cursor centering, range 0.1x to 10x. Update viewport tracking. Ensure 60 FPS performance using requestAnimationFrame.",
        "testStrategy": "Test pan with middle-click and Alt+drag, verify smooth movement. Zoom in/out with wheel, check cursor centering and FPS via DevTools. Confirm no frame drops with rapid interactions.",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up event listeners for pan and zoom",
            "description": "Initialize event listeners in canvas.js for mouse events to handle pan and zoom interactions.",
            "dependencies": [],
            "details": "Add event listeners for mousedown, mousemove, mouseup, and wheel events on the canvas element. Track mouse state variables like isPanning, lastMouseX, lastMouseY, and zoomLevel. Ensure listeners are attached when the canvas is initialized.",
            "status": "done",
            "testStrategy": "Verify that event listeners are attached by checking console logs on mouse interactions.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:27:39.201Z"
          },
          {
            "id": 2,
            "title": "Implement pan functionality",
            "description": "Handle middle-click or Alt+left-click drag to pan the canvas view.",
            "dependencies": [
              1
            ],
            "details": "In the mousedown event, check for middle button or Alt+left-click to set isPanning to true and record initial mouse position. In mousemove, if isPanning, calculate delta movement and update the viewport offset. Reset on mouseup. Prevent default drag behavior.",
            "status": "done",
            "testStrategy": "Test middle-click drag and Alt+left-click drag to ensure the canvas pans smoothly without selecting text or other elements.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:15.758Z"
          },
          {
            "id": 3,
            "title": "Implement zoom functionality",
            "description": "Add mouse wheel zoom with cursor centering and enforce zoom range from 0.1x to 10x.",
            "dependencies": [
              1
            ],
            "details": "In the wheel event, calculate zoom factor based on deltaY, clamp between 0.1 and 10. Adjust zoom level and recompute viewport to center on cursor position. Use transform or scale on the canvas rendering context. Update zoomLevel variable.",
            "status": "done",
            "testStrategy": "Scroll mouse wheel in and out, check that zoom scales from 0.1x to 10x and centers on cursor. Verify zoom stops at limits.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:17.092Z"
          },
          {
            "id": 4,
            "title": "Update viewport tracking",
            "description": "Maintain and update viewport properties like offset and zoom level for accurate rendering.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create a viewport object with properties: offsetX, offsetY, zoom. Update these in pan and zoom handlers. Use these to transform world coordinates to screen coordinates in rendering functions. Ensure viewport is reset or initialized properly.",
            "status": "done",
            "testStrategy": "After pan and zoom, inspect viewport values and confirm they match expected changes based on mouse movements.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:18.386Z"
          },
          {
            "id": 5,
            "title": "Optimize for 60 FPS performance",
            "description": "Ensure smooth performance using requestAnimationFrame for updates.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Wrap pan and zoom updates in requestAnimationFrame to limit to 60 FPS. Debounce rapid events if necessary. Profile with DevTools to confirm no frame drops during interactions. Optimize rendering by only updating changed parts if possible.",
            "status": "done",
            "testStrategy": "Use DevTools Performance tab to record interactions, verify frame rate stays at 60 FPS with no drops during rapid pan and zoom.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:20.031Z"
          }
        ],
        "updatedAt": "2025-10-13T21:28:20.031Z"
      },
      {
        "id": 8,
        "title": "Implement object creation",
        "description": "Enable creation of rectangles and circles on the canvas via click-and-drag.",
        "details": "In canvas.js, add tool modes for rectangle ('R') and circle ('C'). On mouse down, start creation; on mouse up, finalize object with properties (id, type, x, y, width/height/radius, color). Use PIXI.Graphics for rendering. Generate unique IDs.",
        "testStrategy": "Switch to rectangle tool, click-drag to create. Repeat for circle. Verify objects appear with correct properties. Check keyboard shortcuts switch modes.",
        "priority": "high",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add tool modes for rectangle and circle creation",
            "description": "Implement tool modes in canvas.js to switch between rectangle ('R') and circle ('C') creation modes using keyboard shortcuts.",
            "dependencies": [],
            "details": "Modify the canvas.js file to include a mode variable that can be set to 'rectangle' or 'circle' based on key presses 'R' and 'C'. Ensure the mode affects the creation behavior.",
            "status": "pending",
            "testStrategy": "Press 'R' and 'C' keys and verify the mode changes via console logs or UI indicators.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Handle mouse down event to start object creation",
            "description": "Add event listener for mouse down to initiate the creation of a rectangle or circle based on the current tool mode.",
            "dependencies": [
              1
            ],
            "details": "In canvas.js, attach a mousedown event listener to the canvas. On mousedown, record the starting point (x, y) and create a temporary PIXI.Graphics object for previewing the shape being drawn.",
            "status": "pending",
            "testStrategy": "Switch to rectangle mode, click on canvas, and check if a temporary graphic appears at the click position.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Handle mouse move event to update shape during drag",
            "description": "Implement mouse move event to dynamically update the dimensions of the rectangle or circle as the user drags.",
            "dependencies": [
              2
            ],
            "details": "Add a mousemove event listener that, while dragging, calculates width/height for rectangle or radius for circle based on current mouse position and starting point, then redraws the temporary PIXI.Graphics object.",
            "status": "pending",
            "testStrategy": "Start dragging after mousedown, move mouse, and verify the shape resizes in real-time on the canvas.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Handle mouse up event to finalize object creation",
            "description": "On mouse up, finalize the object by assigning properties and adding it to the canvas permanently.",
            "dependencies": [
              3
            ],
            "details": "In the mouseup event listener, remove the temporary graphic, create a new PIXI.Graphics object with final dimensions, assign properties like id, type, x, y, width/height/radius, color, and add it to the canvas stage.",
            "status": "pending",
            "testStrategy": "Complete a click-drag action, release mouse, and confirm a permanent object appears with correct size and properties.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement unique ID generation for objects",
            "description": "Add functionality to generate unique IDs for each created object to ensure no duplicates.",
            "dependencies": [
              4
            ],
            "details": "Create a function in canvas.js that generates unique IDs, perhaps using a counter or timestamp-based method. Assign this ID to each new object upon finalization in the mouseup handler.",
            "status": "pending",
            "testStrategy": "Create multiple objects and verify each has a unique ID by inspecting object properties or logging them.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-14T02:52:42.112Z"
      },
      {
        "id": 9,
        "title": "Implement object manipulation",
        "description": "Add selection, dragging, multi-select, and deletion for objects.",
        "details": "In canvas.js, implement select mode ('V') for clicking to select, Shift+click for multi-select. Enable dragging selected objects. Add Delete key handler for removal. Update object positions in world coordinates.",
        "testStrategy": "Create objects, select single/multiple, drag to new positions. Verify positions update correctly. Delete selected objects and confirm removal.",
        "priority": "high",
        "dependencies": [
          "8"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement select mode activation",
            "description": "Add keyboard shortcut 'V' to activate select mode in canvas.js.",
            "dependencies": [],
            "details": "Modify canvas.js to listen for the 'V' key press event and set the current tool mode to 'select'. Ensure this mode allows for object selection without creating new objects.",
            "status": "pending",
            "testStrategy": "Press 'V' key and verify select mode is activated, preventing object creation.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement single object selection",
            "description": "Enable clicking on objects to select them in select mode.",
            "dependencies": [
              1
            ],
            "details": "In canvas.js, add mouse click event handler in select mode to detect clicks on objects using PIXI's hit detection. Mark the clicked object as selected and visually indicate selection (e.g., highlight).",
            "status": "pending",
            "testStrategy": "Create an object, enter select mode, click on it, and verify it is selected and highlighted.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement multi-select with Shift+click",
            "description": "Allow selecting multiple objects by holding Shift and clicking.",
            "dependencies": [
              2
            ],
            "details": "Extend the click handler in canvas.js to check for Shift key during click. If Shift is held, add the clicked object to the selection without deselecting others. Maintain a list of selected objects.",
            "status": "pending",
            "testStrategy": "Create multiple objects, select one, then Shift+click another, and verify both are selected.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement dragging of selected objects",
            "description": "Enable dragging selected objects to new positions.",
            "dependencies": [
              3
            ],
            "details": "In canvas.js, add mouse down, move, and up event handlers for dragging. On mouse down on selected objects, initiate drag. Update positions during move and finalize on mouse up, converting screen coordinates to world coordinates.",
            "status": "pending",
            "testStrategy": "Select an object, drag it to a new position, and verify the position updates correctly in world coordinates.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement deletion of selected objects",
            "description": "Add Delete key handler to remove selected objects.",
            "dependencies": [
              3
            ],
            "details": "In canvas.js, add a keydown event listener for the Delete key. When pressed, remove all selected objects from the canvas and update the object list. Ensure positions are handled in world coordinates if needed.",
            "status": "pending",
            "testStrategy": "Select one or more objects, press Delete key, and verify they are removed from the canvas.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-14T02:52:43.333Z"
      },
      {
        "id": 10,
        "title": "Implement WebSocket client",
        "description": "Develop the client-side WebSocket connection and message handling.",
        "details": "In websocket.js, create WebSocketClient class to connect to ws://host/ws/{canvas-id}. Handle auth message on connect. Implement send/receive for cursor, object operations. Add reconnection logic and throttling for cursor updates (30/sec).",
        "testStrategy": "Connect to server, send auth, verify auth-success. Send test object-create message and check server response. Test reconnection after disconnect.",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create WebSocketClient class structure",
            "description": "Set up the basic WebSocketClient class in websocket.js with constructor and initial properties.",
            "dependencies": [],
            "details": "In websocket.js, define a WebSocketClient class with a constructor that takes host, canvasId, and authToken. Initialize properties like ws (WebSocket instance), isConnected (boolean), and message handlers. Ensure the class is exportable for use in other modules.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:27:55.378Z"
          },
          {
            "id": 2,
            "title": "Implement WebSocket connection and authentication",
            "description": "Establish the WebSocket connection to the server and handle the initial authentication message.",
            "dependencies": [
              1
            ],
            "details": "In the WebSocketClient class, add a connect() method that creates a new WebSocket connection to ws://host/ws/{canvas-id}. On connection open, send an auth message with the authToken. Listen for auth-success or auth-failure responses and handle accordingly, updating connection status.",
            "status": "done",
            "testStrategy": "Connect to a test server, verify WebSocket opens, send auth message, and check for auth-success response.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:21.428Z"
          },
          {
            "id": 3,
            "title": "Implement message sending and receiving for cursor and object operations",
            "description": "Add methods to send and receive messages for cursor updates and object manipulations.",
            "dependencies": [
              2
            ],
            "details": "In the WebSocketClient class, implement sendMessage() method to send JSON messages for cursor positions and object operations (create, update, delete). Add onMessage handler to parse incoming messages and dispatch to appropriate handlers for cursor updates and object changes. Ensure messages are properly formatted as JSON.",
            "status": "done",
            "testStrategy": "Send a test cursor update message and verify it's received. Send an object-create message and check the response.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:22.890Z"
          },
          {
            "id": 4,
            "title": "Add reconnection logic",
            "description": "Implement automatic reconnection when the WebSocket connection is lost.",
            "dependencies": [
              2
            ],
            "details": "In the WebSocketClient class, add an onClose handler that attempts to reconnect after a delay (e.g., exponential backoff). Track reconnection attempts and stop after a maximum number. Re-authenticate upon successful reconnection. Provide a method to manually disconnect.",
            "status": "done",
            "testStrategy": "Disconnect the WebSocket manually, verify automatic reconnection occurs, and auth is re-sent.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:24.212Z"
          },
          {
            "id": 5,
            "title": "Implement throttling for cursor updates",
            "description": "Add throttling to limit cursor update messages to 30 per second.",
            "dependencies": [
              3
            ],
            "details": "In the WebSocketClient class, implement a throttling mechanism using a timer or library to ensure cursor position updates are sent at most 30 times per second. Buffer or drop excess updates. Integrate this into the cursor sending logic to prevent flooding the server.",
            "status": "done",
            "testStrategy": "Simulate rapid cursor movements and verify that no more than 30 updates are sent per second.",
            "parentId": "undefined",
            "updatedAt": "2025-10-13T21:28:25.505Z"
          }
        ],
        "updatedAt": "2025-10-13T21:28:25.505Z"
      },
      {
        "id": 11,
        "title": "Implement real-time synchronization for objects",
        "description": "Sync object creation, updates, and deletions across all connected clients.",
        "details": "Integrate WebSocketClient with CanvasManager: on local object create/update/delete, send message. On receive, update canvas. Broadcast via server. Use last-write-wins for conflicts.",
        "testStrategy": "Open two browser windows, create/update/delete objects in one, verify immediate sync in the other. Check latency <100ms with network tools.",
        "priority": "high",
        "dependencies": [
          "9",
          "10"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate WebSocketClient for sending object change messages",
            "description": "Modify CanvasManager to send WebSocket messages whenever an object is created, updated, or deleted locally.",
            "dependencies": [],
            "details": "In CanvasManager, hook into object creation, update, and deletion events to serialize the object data (id, type, position, etc.) into a JSON message and send it via WebSocketClient to the server.",
            "status": "pending",
            "testStrategy": "Use browser console to verify messages are sent on object actions, check network tab for WebSocket frames.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement handling of incoming WebSocket messages for canvas updates",
            "description": "Update CanvasManager to listen for incoming WebSocket messages and apply the received object changes to the canvas.",
            "dependencies": [
              1
            ],
            "details": "Add a WebSocket message handler in CanvasManager that parses incoming JSON messages for object create, update, or delete operations, and updates the local canvas state accordingly, ensuring UI reflects changes.",
            "status": "pending",
            "testStrategy": "Send manual WebSocket messages from server and observe canvas updates in real-time without local actions.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Set up server-side broadcasting of object change messages",
            "description": "Implement server logic to broadcast received WebSocket messages to all connected clients except the sender.",
            "dependencies": [
              2
            ],
            "details": "In the server code, upon receiving a message from a client, relay it to all other connected WebSocket clients, ensuring efficient broadcasting without echoing back to the originator.",
            "status": "pending",
            "testStrategy": "Connect multiple clients, perform an action on one, and verify the message is received by others via server logs or client-side logs.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement last-write-wins conflict resolution",
            "description": "Add logic to handle concurrent updates by prioritizing the latest timestamped change.",
            "dependencies": [
              3
            ],
            "details": "Attach timestamps to all object change messages. In the message handler, compare timestamps on conflicts (e.g., simultaneous updates to the same object) and apply the most recent one, discarding older changes.",
            "status": "pending",
            "testStrategy": "Simulate conflicts by rapidly updating the same object from two clients and verify only the latest change persists.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Test end-to-end real-time synchronization",
            "description": "Perform comprehensive testing to ensure synchronization works across clients with low latency.",
            "dependencies": [
              4
            ],
            "details": "Open multiple browser windows, create, update, and delete objects in one, and verify immediate reflection in others. Use network tools to confirm latency under 100ms and handle edge cases like disconnections.",
            "status": "pending",
            "testStrategy": "Follow the test strategy from the parent task: Open two browser windows, perform actions in one, check sync in the other, measure latency.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-14T02:52:44.596Z"
      },
      {
        "id": 12,
        "title": "Implement cursor synchronization",
        "description": "Enable real-time cursor position sharing with presence.",
        "details": "In websocket.js, send cursor updates on mouse move (throttled). On receive, render remote cursors with username labels in unique colors. Update presence list on connect/disconnect.",
        "testStrategy": "Move mouse in one window, verify cursor appears in others with <50ms latency. Check presence list updates on join/leave.",
        "priority": "medium",
        "dependencies": [
          "10"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up mouse move event listener with throttling",
            "description": "Implement a throttled mouse move event listener in the canvas to capture cursor positions efficiently.",
            "dependencies": [],
            "details": "In canvas.js, add an event listener for mousemove events on the canvas element. Use a throttling mechanism (e.g., lodash.throttle or custom implementation) to limit updates to every 50ms or less to avoid excessive sending.",
            "status": "pending",
            "testStrategy": "Move mouse rapidly and verify that position updates are throttled, not sent on every pixel movement.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Send cursor position updates via WebSocket",
            "description": "Modify websocket.js to send cursor position data on throttled mouse moves.",
            "dependencies": [
              1
            ],
            "details": "In websocket.js, on each throttled mouse move, send a message containing the current cursor x, y coordinates, username, and a unique color identifier via the WebSocket connection.",
            "status": "pending",
            "testStrategy": "Move mouse and use browser dev tools to inspect WebSocket messages, confirming position data is sent with username and color.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Receive and parse cursor updates from WebSocket",
            "description": "Handle incoming WebSocket messages for cursor positions from other users.",
            "dependencies": [
              2
            ],
            "details": "In websocket.js, add a message handler to receive cursor update messages, parse the JSON payload to extract position, username, and color, and store or update a list of remote cursors.",
            "status": "pending",
            "testStrategy": "Open multiple browser windows, move mouse in one, and check console logs in others for received messages with correct data.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Render remote cursors with username labels and unique colors",
            "description": "Display remote cursors on the canvas with labels and colors.",
            "dependencies": [
              3
            ],
            "details": "In canvas.js, for each remote cursor in the list, render a cursor icon (e.g., a small arrow or dot) at the received position, add a text label with the username, and apply the unique color. Update positions in real-time as new messages arrive.",
            "status": "pending",
            "testStrategy": "With multiple users, move cursors and verify they appear in other windows with labels, colors, and <50ms latency using browser performance tools.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Update presence list on user connect and disconnect",
            "description": "Maintain and display a list of online users based on WebSocket connections.",
            "dependencies": [
              3
            ],
            "details": "In websocket.js, on WebSocket open (connect), send a join message with username. On close (disconnect), send a leave message. Maintain a presence list and update the UI (e.g., a sidebar) to show current online users.",
            "status": "pending",
            "testStrategy": "Open/close browser windows and check that the presence list updates immediately on join/leave, reflecting accurate user counts.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-14T02:52:45.813Z"
      },
      {
        "id": 13,
        "title": "Implement state persistence",
        "description": "Save and load canvas state to/from SQLite database.",
        "details": "In canvas-state.lisp, implement save function with debounced updates (500ms). Load state on connection via GET /api/canvas/state. Store as JSON blob in canvas_states table.",
        "testStrategy": "Create objects, refresh page, verify state persists. Disconnect all users, reconnect, check state loads. Confirm debouncing prevents excessive saves.",
        "priority": "high",
        "dependencies": [
          "2",
          "11"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create canvas_states table in SQLite",
            "description": "Set up the database schema for storing canvas state as JSON blobs.",
            "dependencies": [],
            "details": "Create a table named 'canvas_states' with columns: id (primary key, auto-increment), state_json (text for JSON blob), and timestamp (datetime for last update). Ensure the table is created in the SQLite database used by the application.",
            "status": "pending",
            "testStrategy": "Run a database query to verify the table exists with correct columns.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement debounced save function in canvas-state.lisp",
            "description": "Develop a function to save the current canvas state to the database with debouncing to prevent excessive saves.",
            "dependencies": [
              1
            ],
            "details": "In canvas-state.lisp, create a save-canvas-state function that serializes the canvas state to JSON and inserts/updates it in the canvas_states table. Implement debouncing using a timer (500ms delay) to batch saves and avoid overloading the database on rapid changes.",
            "status": "pending",
            "testStrategy": "Simulate rapid canvas changes and check that saves occur only after 500ms of inactivity, verifying database entries.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement load state function for GET /api/canvas/state",
            "description": "Create a backend endpoint to retrieve and return the persisted canvas state.",
            "dependencies": [
              1
            ],
            "details": "In canvas-state.lisp, add a handler for GET /api/canvas/state that queries the canvas_states table for the latest state JSON, parses it, and returns it in the response. Handle cases where no state exists (return empty or default state).",
            "status": "pending",
            "testStrategy": "Use curl or a browser to call the endpoint and verify it returns the correct JSON state or default when no data is present.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate saving on canvas state changes",
            "description": "Connect the save function to trigger whenever the canvas state is modified.",
            "dependencies": [
              2
            ],
            "details": "Modify the canvas manipulation code (e.g., in canvas.js or related Lisp functions) to call the debounced save function whenever objects are created, moved, or deleted. Ensure the state includes all necessary object properties for accurate restoration.",
            "status": "pending",
            "testStrategy": "Create and modify objects on the canvas, then check the database to confirm the state is saved correctly after debouncing.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate loading on client connection",
            "description": "Ensure the canvas state is loaded from the database when a user connects or refreshes the page.",
            "dependencies": [
              3
            ],
            "details": "In the client-side code (e.g., canvas.js), add logic to fetch the state via GET /api/canvas/state on page load or connection, and populate the canvas with the loaded objects. Handle authentication if required, and merge or replace existing state appropriately.",
            "status": "pending",
            "testStrategy": "Refresh the page after making changes, verify that the canvas reloads with the persisted state. Test with multiple users or disconnections.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-14T02:52:47.049Z"
      },
      {
        "id": 14,
        "title": "Implement user interface components",
        "description": "Build the UI for toolbar, presence list, and status bar.",
        "details": "In HTML/CSS/JS, create toolbar for tools (select, rectangle, circle), color picker. Add presence list in top-right. Implement status bar for tool, position, zoom. Ensure dark theme consistency.",
        "testStrategy": "Verify toolbar switches tools, presence shows online users, status updates correctly. Check UI doesn't obstruct canvas and is responsive.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create toolbar with tool buttons and color picker",
            "description": "Design and implement the toolbar containing buttons for select, rectangle, and circle tools, along with a color picker component.",
            "dependencies": [],
            "details": "In HTML, add a div for the toolbar. Use CSS for styling with dark theme. In JS, create buttons for each tool and a color input. Attach event listeners to switch tool modes in canvas.js.",
            "status": "pending",
            "testStrategy": "Click each tool button and verify the active tool changes. Select a color and confirm it applies to new objects.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement presence list in top-right corner",
            "description": "Build the presence list component to display online users in the top-right area of the interface.",
            "dependencies": [
              1
            ],
            "details": "Add a div in the top-right of the page layout. Use JS to fetch and display user list from backend. Style with dark theme CSS. Update list on user join/leave events.",
            "status": "pending",
            "testStrategy": "Simulate multiple users logging in and verify the list updates in real-time. Check positioning doesn't overlap with other UI elements.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop status bar for tool, position, and zoom info",
            "description": "Create the status bar at the bottom to show current tool, mouse position, and zoom level.",
            "dependencies": [
              1
            ],
            "details": "Insert a status bar div at the bottom of the page. In JS, update text content based on current tool, mouse coordinates, and zoom factor. Ensure responsive design and dark theme.",
            "status": "pending",
            "testStrategy": "Switch tools and move mouse; verify status bar updates accurately. Zoom in/out and check zoom display changes.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Apply dark theme consistency across UI components",
            "description": "Ensure all toolbar, presence list, and status bar elements adhere to the dark theme color scheme.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Define CSS variables for dark theme colors (e.g., background, text, borders). Apply these to all UI elements created. Test for consistency in visibility and aesthetics.",
            "status": "pending",
            "testStrategy": "Inspect UI in browser dev tools for color consistency. Verify readability and contrast in dark mode.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate UI components into main layout",
            "description": "Position and integrate the toolbar, presence list, and status bar into the overall page layout without obstructing the canvas.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Use CSS flexbox or grid to arrange components: toolbar top-left, presence top-right, status bottom. Ensure canvas remains central and unobstructed. Make layout responsive.",
            "status": "pending",
            "testStrategy": "Resize browser window and confirm UI elements adjust properly. Verify canvas interaction isn't blocked by UI overlays.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-14T02:52:48.264Z"
      },
      {
        "id": 15,
        "title": "Deploy application to Fly.io",
        "description": "Containerize and deploy the application to Fly.io for public access.",
        "details": "Create Dockerfile as specified. Build frontend and backend. Configure fly.toml. Use fly deploy. Ensure health check endpoint.",
        "testStrategy": "Access deployed URL, test full flow: register, login, create objects, sync with another user. Verify performance and no errors in logs.",
        "priority": "high",
        "dependencies": [
          "13",
          "14"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Dockerfile and containerize the application",
            "description": "Develop a Dockerfile to containerize both the frontend and backend components of the application, ensuring all dependencies are included and the app can run in a containerized environment.",
            "dependencies": [],
            "details": "Use a Debian base image, install necessary tools like SBCL, Quicklisp, Node.js for Vite build. Copy backend and frontend code, run builds for both, expose necessary ports (e.g., 8080 for backend), and set the entrypoint to start the server. Ensure the Dockerfile follows best practices for multi-stage builds if applicable.",
            "status": "pending",
            "testStrategy": "Build the Docker image locally and run it to verify the application starts without errors, checking logs for successful initialization."
          },
          {
            "id": 2,
            "title": "Configure Fly.io deployment settings",
            "description": "Set up the fly.toml configuration file with necessary settings for deploying the containerized application to Fly.io, including app name, region, and health checks.",
            "dependencies": [
              1
            ],
            "details": "Create or edit fly.toml to specify the app name, source directory, build command (if needed), services with internal port mapping, health check endpoint (e.g., /health), and any environment variables required for the application. Ensure compatibility with Fly.io's deployment requirements.",
            "status": "pending",
            "testStrategy": "Validate the fly.toml file using Fly CLI commands like 'fly config validate' to ensure no syntax errors and proper configuration."
          },
          {
            "id": 3,
            "title": "Deploy to Fly.io and verify functionality",
            "description": "Execute the deployment to Fly.io using the configured settings and perform end-to-end testing to ensure the application is publicly accessible and fully functional.",
            "dependencies": [
              2
            ],
            "details": "Run 'fly deploy' to push the containerized app to Fly.io. Monitor the deployment logs for success. Once deployed, access the public URL and test the full application flow including user registration, login, canvas object creation, and synchronization between users. Check application logs for any errors.",
            "status": "pending",
            "testStrategy": "Access the deployed URL and perform manual tests: register a user, log in, create and manipulate canvas objects, verify real-time sync with another user session. Monitor performance and check for no errors in Fly.io logs or console."
          }
        ],
        "updatedAt": "2025-10-14T02:52:04.930Z"
      },
      {
        "id": 16,
        "title": "Database Schema Updates for Version Tracking",
        "description": "Modify the database schema to add version tracking fields to canvas objects and create a conflict log table as specified in the PRD.",
        "details": "Execute the provided SQL statements to alter the canvas_objects table by adding 'version' (INTEGER DEFAULT 1), 'last_modified_by' (INTEGER REFERENCES users(id)), and 'last_modified_at' (TIMESTAMP DEFAULT CURRENT_TIMESTAMP) columns. Create the object_conflicts table with the specified schema including id (SERIAL PRIMARY KEY), canvas_id (TEXT NOT NULL), object_id (TEXT NOT NULL), user_id (INTEGER REFERENCES users(id)), client_version (INTEGER NOT NULL), server_version (INTEGER NOT NULL), attempted_changes (JSON), conflict_type (TEXT), resolved_at (TIMESTAMP), and resolution_type (TEXT). Ensure the database supports JSON for attempted_changes. Use transactions to apply changes safely.",
        "testStrategy": "Unit test the schema changes by inserting sample data into canvas_objects and object_conflicts tables, verifying that version increments correctly and foreign key constraints are enforced. Integration test with existing queries to ensure no performance regression.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Alter canvas_objects table and create object_conflicts table",
            "description": "Modify the database schema by adding version tracking fields to the canvas_objects table and creating the new object_conflicts table as specified.",
            "dependencies": [],
            "details": "Execute SQL statements to alter the canvas_objects table by adding 'version' (INTEGER DEFAULT 1), 'last_modified_by' (INTEGER REFERENCES users(id)), and 'last_modified_at' (TIMESTAMP DEFAULT CURRENT_TIMESTAMP) columns. Create the object_conflicts table with id (SERIAL PRIMARY KEY), canvas_id (TEXT NOT NULL), object_id (TEXT NOT NULL), user_id (INTEGER REFERENCES users(id)), client_version (INTEGER NOT NULL), server_version (INTEGER NOT NULL), attempted_changes (JSON), conflict_type (TEXT), resolved_at (TIMESTAMP), and resolution_type (TEXT). Ensure JSON support for attempted_changes. Use transactions for safe application.",
            "status": "pending",
            "testStrategy": "Insert sample data into both tables and verify constraints and data integrity."
          },
          {
            "id": 2,
            "title": "Validate database schema changes",
            "description": "Ensure the schema modifications are correct and do not introduce regressions in the database.",
            "dependencies": [
              1
            ],
            "details": "After applying the schema changes, run validation checks including verifying table structures, foreign key constraints, and JSON support. Test with sample inserts and queries to confirm the database behaves as expected without performance issues.",
            "status": "pending",
            "testStrategy": "Perform unit tests by inserting data and checking version increments, and integration tests with existing queries to ensure no regressions."
          }
        ]
      },
      {
        "id": 17,
        "title": "Implement Object Version Management in Backend",
        "description": "Extend the backend canvas-state.lisp to handle version tracking for canvas objects, ensuring versions increment on updates.",
        "details": "In canvas-state.lisp, modify the object update functions to read and increment the version field. For each object, store the version in memory cache and persist to database. Implement a function to retrieve the current version of an object. Use optimistic locking by checking the version before applying changes. Pseudo-code: (defun update-object (object-id updates client-version) (let ((current-version (get-object-version object-id))) (if (= client-version current-version) (progn (apply-updates object-id updates) (increment-version object-id) t) nil)))",
        "testStrategy": "Unit tests for version increment logic and retrieval. Mock database interactions to verify version checks prevent stale updates.",
        "priority": "high",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Modify Object Update Functions for Version Tracking",
            "description": "Update the object update functions in canvas-state.lisp to read and increment the version field for each canvas object.",
            "dependencies": [],
            "details": "In canvas-state.lisp, locate the existing update functions (e.g., for position, properties). Add logic to retrieve the current version, increment it after successful updates, and persist the new version to the database. Ensure the version is stored as an integer field in the object structure.",
            "status": "pending",
            "testStrategy": "Unit tests to verify version increments correctly on updates, using mock objects and database interactions."
          },
          {
            "id": 2,
            "title": "Implement Version Caching in Memory",
            "description": "Add in-memory caching for object versions to improve performance and reduce database queries.",
            "dependencies": [
              1
            ],
            "details": "Integrate a memory cache (e.g., using a hash table in Lisp) to store object versions. On updates, update the cache synchronously with database persistence. Implement cache invalidation or refresh mechanisms if needed for consistency.",
            "status": "pending",
            "testStrategy": "Integration tests to check cache updates on version changes, simulating multiple updates and verifying cache accuracy."
          },
          {
            "id": 3,
            "title": "Add Optimistic Locking Logic",
            "description": "Implement optimistic locking by checking client-provided versions against current versions before applying updates.",
            "dependencies": [
              1,
              2
            ],
            "details": "Modify the update-object function as per the pseudo-code: check if client-version matches current-version, apply updates only if they match, then increment version. Return success/failure indicators. Handle version mismatches by rejecting stale updates.",
            "status": "pending",
            "testStrategy": "Unit tests for locking logic, including scenarios with matching and mismatching versions, ensuring no updates on conflicts."
          }
        ]
      },
      {
        "id": 18,
        "title": "Update WebSocket Protocol for Version Fields",
        "description": "Modify websocket.lisp to include version fields in update messages and handle new conflict-related message types.",
        "details": "Update the WebSocket message handlers in websocket.lisp to parse and send version fields in 'object-update' messages. Add handlers for 'object-conflict' and 'resolve-conflict' message types. Implement sending 'object-update-success' and 'object-conflict' responses. Pseudo-code: (defun handle-object-update (message) (let ((object-id (getf message :object-id)) (version (getf message :version)) (updates (getf message :updates))) (if (update-object object-id updates version) (send-success object-id (1+ version)) (send-conflict object-id version (get-server-version object-id) ...))))",
        "testStrategy": "Integration tests for WebSocket message flows, simulating client-server interactions with version mismatches to ensure correct conflict detection and notifications.",
        "priority": "high",
        "dependencies": [
          17
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update WebSocket Message Handlers for Version Fields",
            "description": "Modify the existing WebSocket message handlers in websocket.lisp to parse and include version fields in 'object-update' messages, ensuring proper extraction of object-id, version, and updates from incoming messages.",
            "dependencies": [],
            "details": "In websocket.lisp, update the handle-object-update function to extract the :version field from the message plist. Modify the update-object function call to pass the version parameter for version checking. Ensure the handler correctly processes the message structure as per the pseudo-code provided, integrating with the existing message routing logic.",
            "status": "pending",
            "testStrategy": "Unit tests for message parsing, verifying that version fields are correctly extracted and passed to update functions. Simulate incoming messages with version data to check handler behavior."
          },
          {
            "id": 2,
            "title": "Add Handlers for New Conflict-Related Message Types",
            "description": "Implement new message handlers in websocket.lisp for 'object-conflict' and 'resolve-conflict' message types to manage version conflicts in collaborative updates.",
            "dependencies": [
              1
            ],
            "details": "Add functions like handle-object-conflict and handle-resolve-conflict in websocket.lisp. For 'object-conflict', parse incoming conflict notifications and prepare for resolution. For 'resolve-conflict', handle client-side resolution messages by updating the server state accordingly. Integrate these into the main message routing dispatcher, ensuring they work with the room management system.",
            "status": "pending",
            "testStrategy": "Integration tests simulating conflict scenarios: send conflicting updates and verify that 'object-conflict' messages are triggered and handled correctly. Test resolution flows to ensure state consistency."
          },
          {
            "id": 3,
            "title": "Implement Sending of Update Success and Conflict Responses",
            "description": "Add functionality to send 'object-update-success' and 'object-conflict' response messages from the server in websocket.lisp based on update outcomes.",
            "dependencies": [
              2
            ],
            "details": "Implement send-success and send-conflict functions that broadcast or send targeted messages to clients. For success, include the updated object-id and new version (e.g., 1+ version). For conflicts, send the object-id, client version, and server version. Ensure these are called from the handle-object-update function as per the pseudo-code, using the WebSocket broadcasting mechanisms established in the server infrastructure.",
            "status": "pending",
            "testStrategy": "End-to-end tests for message flows: Simulate successful updates and verify 'object-update-success' is sent. Trigger version mismatches to confirm 'object-conflict' responses are dispatched correctly, checking client-side receipt."
          }
        ]
      },
      {
        "id": 19,
        "title": "Develop Conflict Detection Engine",
        "description": "Create a conflict detection engine that compares versions and logs conflicts when detected.",
        "details": "In a new or extended module (e.g., conflict-engine.lisp), implement version comparison logic. When an update is attempted with a stale version, log the conflict to the object_conflicts table with details like client_version, server_version, attempted_changes, and conflict_type. Pseudo-code: (defun detect-conflict (object-id client-version) (let ((server-version (get-server-version object-id))) (unless (= client-version server-version) (log-conflict object-id client-version server-version ...) t))) Integrate this into the update process.",
        "testStrategy": "Unit tests for conflict detection algorithm, ensuring it correctly identifies version mismatches. Test logging by verifying database entries after simulated conflicts.",
        "priority": "high",
        "dependencies": [
          16,
          17,
          18
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Version Comparison Logic",
            "description": "Develop the core logic to compare client and server versions for detecting conflicts in the conflict detection engine.",
            "dependencies": [],
            "details": "In the conflict-engine.lisp module, implement a function to retrieve the server version for a given object ID and compare it with the client version. Use the provided pseudo-code as a basis: (defun detect-conflict (object-id client-version) (let ((server-version (get-server-version object-id))) (unless (= client-version server-version) ... t))). Ensure the comparison handles integer versions accurately and returns true if a conflict is detected.",
            "status": "pending",
            "testStrategy": "Unit tests to verify correct detection of version mismatches, including edge cases like equal versions and large version numbers."
          },
          {
            "id": 2,
            "title": "Implement Conflict Logging",
            "description": "Create functionality to log detected conflicts to the database with necessary details.",
            "dependencies": [
              1
            ],
            "details": "Extend the conflict-engine.lisp module to include a log-conflict function that inserts records into the object_conflicts table. Include fields such as object_id, client_version, server_version, attempted_changes, and conflict_type. Use database utilities from database.lisp to execute the insert query securely, handling any potential database errors.",
            "status": "pending",
            "testStrategy": "Integration tests simulating conflicts and verifying that database entries are created correctly with all required fields populated."
          },
          {
            "id": 3,
            "title": "Integrate Conflict Detection with Update Process",
            "description": "Incorporate the conflict detection engine into the existing update workflow to check for conflicts before applying changes.",
            "dependencies": [
              1,
              2
            ],
            "details": "Modify the update process in the relevant module (likely canvas.lisp or similar) to call the detect-conflict function before proceeding with any object updates. If a conflict is detected, prevent the update and ensure the conflict is logged. Integrate seamlessly with WebSocket message handling for real-time conflict detection during collaborative operations.",
            "status": "pending",
            "testStrategy": "End-to-end tests using WebSocket connections to simulate update attempts with stale versions, confirming conflicts are detected, logged, and updates are blocked appropriately."
          }
        ]
      },
      {
        "id": 20,
        "title": "Implement Conflict Notification System",
        "description": "Set up real-time notifications for conflicts to affected clients via WebSocket.",
        "details": "Extend websocket.lisp to send 'object-conflict' messages to the client when a conflict is detected, including serverState, attemptedChanges, and conflictingUser. Ensure notifications are pushed immediately. For successful updates, broadcast 'object-update-success' to all connected clients for real-time sync. Pseudo-code: (defun notify-conflict (client-socket object-id ...) (send-message client-socket (make-conflict-message object-id ...)))",
        "testStrategy": "Integration tests with multiple WebSocket clients to verify conflict notifications are sent correctly and only to affected users. End-to-end tests for real-time sync of non-conflicting updates.",
        "priority": "high",
        "dependencies": [
          18,
          19
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Extend WebSocket for Conflict Messages",
            "description": "Modify websocket.lisp to send 'object-conflict' messages to the affected client when a conflict is detected, including details like serverState, attemptedChanges, and conflictingUser.",
            "dependencies": [],
            "details": "Update the WebSocket implementation in websocket.lisp to include a function that detects conflicts and immediately sends targeted 'object-conflict' messages to the specific client socket involved in the conflict. Ensure the message format includes object-id, serverState, attemptedChanges, and conflictingUser for proper client-side handling.",
            "status": "pending",
            "testStrategy": "Integration tests with multiple WebSocket clients to verify conflict notifications are sent correctly and only to affected users."
          },
          {
            "id": 2,
            "title": "Implement Broadcasting of Update Successes",
            "description": "Add functionality to broadcast 'object-update-success' messages to all connected clients when an update succeeds, ensuring real-time synchronization.",
            "dependencies": [
              1
            ],
            "details": "Extend websocket.lisp to broadcast 'object-update-success' messages to all connected WebSocket clients upon successful object updates. This should include the updated object details to allow clients to sync their states in real-time without conflicts.",
            "status": "pending",
            "testStrategy": "End-to-end tests for real-time sync of non-conflicting updates across multiple clients."
          }
        ]
      },
      {
        "id": 21,
        "title": "Design and Implement Conflict Resolution UI",
        "description": "Create frontend UI components for detecting and resolving conflicts, including visual indicators and resolution modal.",
        "details": "In the frontend JavaScript, add a modal or sidebar that appears on receiving 'object-conflict' WebSocket message. Display side-by-side diffs of client and server states. Provide buttons for 'overwrite', 'discard', or 'merge' resolutions. On resolution, send 'resolve-conflict' message. Add visual indicators (e.g., red border) on conflicting objects. Use libraries like React for UI components if applicable. Pseudo-code: (function handleConflict(message) { showModal(message.objectId, message.serverState, message.attemptedChanges); }) (function resolveConflict(resolution) { sendWebSocket({type: 'resolve-conflict', resolution: resolution, ...}); })",
        "testStrategy": "UI unit tests for modal rendering and button interactions. Integration tests simulating WebSocket conflicts to verify UI appears and resolutions are sent correctly.",
        "priority": "high",
        "dependencies": [
          20
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design the Conflict Resolution Modal",
            "description": "Design the UI layout and structure for the modal or sidebar that appears when a conflict is detected, including placeholders for diff display and buttons.",
            "dependencies": [],
            "details": "Create wireframes or mockups for the modal, ensuring it is responsive and user-friendly. Include areas for displaying object ID, side-by-side diffs, and resolution options. Use React components if applicable, and ensure accessibility standards are met.",
            "status": "pending",
            "testStrategy": "UI design reviews and mockup validations with stakeholders to ensure usability."
          },
          {
            "id": 2,
            "title": "Implement Side-by-Side Diff Display",
            "description": "Implement the functionality to display side-by-side diffs of client and server states within the modal.",
            "dependencies": [],
            "details": "Develop code to render differences between client and server states, highlighting changes in color (e.g., green for additions, red for deletions). Integrate with the modal component, using libraries like diff-match-patch if needed. Ensure the display is scrollable for large diffs.",
            "status": "pending",
            "testStrategy": "Unit tests for diff rendering with sample data, verifying correct highlighting and layout."
          },
          {
            "id": 3,
            "title": "Add Resolution Buttons and Actions",
            "description": "Add buttons for 'overwrite', 'discard', or 'merge' resolutions, and handle user interactions.",
            "dependencies": [],
            "details": "Implement buttons in the modal that trigger resolution actions. For merge, provide a simple interface if needed. On button click, prepare the resolution data. Ensure buttons are disabled during processing to prevent multiple submissions.",
            "status": "pending",
            "testStrategy": "UI interaction tests to verify button clicks trigger correct actions and modal updates."
          },
          {
            "id": 4,
            "title": "Integrate with WebSocket for Conflict Handling",
            "description": "Integrate the UI components with WebSocket messages for receiving conflicts and sending resolutions.",
            "dependencies": [],
            "details": "Add event listeners for 'object-conflict' WebSocket messages to trigger the modal display. Implement sending 'resolve-conflict' messages upon resolution. Also, add visual indicators like red borders on conflicting objects in the canvas.",
            "status": "pending",
            "testStrategy": "Integration tests simulating WebSocket messages to ensure modal appears, indicators show, and resolutions are sent correctly."
          }
        ]
      },
      {
        "id": 22,
        "title": "Add Object Locking Visualization",
        "description": "Implement frontend features to show which objects are being edited by others, with user avatars or names.",
        "details": "Extend the frontend to display user information on objects currently being edited. Subscribe to WebSocket updates for lock status. Show avatars/names on locked objects in real-time. Use CSS overlays or tooltips. Pseudo-code: (function updateLockStatus(objectId, user) { addOverlay(objectId, user.avatar, user.name); }) Integrate with existing canvas rendering.",
        "testStrategy": "UI tests for overlay display on locked objects. End-to-end tests with multiple users to verify real-time updates of lock statuses.",
        "priority": "medium",
        "dependencies": [
          21
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Subscribe to WebSocket Updates for Lock Status",
            "description": "Implement WebSocket subscription to receive real-time updates on object lock statuses from the server.",
            "dependencies": [],
            "details": "Extend the WebSocketClient to listen for lock status messages. On receiving updates, parse the objectId and user information (avatar, name). Store lock states in a local map for quick access. Ensure subscription handles connection drops and reconnections gracefully.",
            "status": "pending",
            "testStrategy": "Unit tests for WebSocket message parsing and state updates. Integration tests to simulate server messages and verify local lock map updates."
          },
          {
            "id": 2,
            "title": "Implement CSS Overlays for Locked Objects",
            "description": "Create CSS overlays or tooltips to display user avatars and names on locked objects.",
            "dependencies": [
              1
            ],
            "details": "Design and implement CSS classes for overlays (e.g., positioned absolutely over canvas objects). Include elements for user avatar images and names. Use JavaScript to dynamically add/remove overlays based on lock status updates from the WebSocket subscription.",
            "status": "pending",
            "testStrategy": "UI tests to verify overlays appear correctly on locked objects with proper avatar and name display. Test overlay positioning and removal when locks are released."
          },
          {
            "id": 3,
            "title": "Integrate Lock Visualization with Canvas Rendering",
            "description": "Integrate the lock overlays into the existing canvas rendering system to show real-time lock status.",
            "dependencies": [
              2
            ],
            "details": "Modify the canvas rendering logic in canvas.js to check lock status before rendering each object. Call the updateLockStatus function to apply overlays. Ensure overlays update in real-time without disrupting canvas performance, using efficient DOM manipulation.",
            "status": "pending",
            "testStrategy": "End-to-end tests with multiple users: Create objects, lock them, and verify overlays appear in real-time across clients. Performance tests to ensure no rendering lag."
          }
        ]
      },
      {
        "id": 23,
        "title": "Implement Resolution Workflows and Undo",
        "description": "Enhance the conflict resolution UI with preview, undo, and advanced merge options.",
        "details": "Add preview functionality before applying resolutions, allowing users to see the final state. Implement undo after resolution by storing previous states. For merges, provide a manual merge interface for compatible changes. Pseudo-code: (function previewResolution(resolution) { renderPreview(mergeStates(clientState, serverState, resolution)); }) (function undoResolution(objectId) { revertToPreviousState(objectId); })",
        "testStrategy": "UI interaction tests for preview and undo features. Scenario-based tests for merge workflows, ensuring data integrity post-resolution.",
        "priority": "medium",
        "dependencies": [
          21
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Preview Functionality for Resolutions",
            "description": "Add preview functionality before applying resolutions to allow users to see the final merged state.",
            "dependencies": [],
            "details": "In the conflict resolution UI, implement a previewResolution function that takes a resolution object and renders a preview of the merged states using clientState, serverState, and the resolution. Use the provided pseudo-code as a base: (function previewResolution(resolution) { renderPreview(mergeStates(clientState, serverState, resolution)); }). Ensure the preview is non-destructive and updates in real-time as users adjust resolutions.",
            "status": "pending",
            "testStrategy": "UI tests to verify preview renders correctly and matches expected merged state without applying changes."
          },
          {
            "id": 2,
            "title": "Implement Undo Mechanism for Resolutions",
            "description": "Implement undo functionality after resolution by storing and reverting to previous states.",
            "dependencies": [
              1
            ],
            "details": "Add an undoResolution function that stores previous states before applying resolutions and allows reverting to them using objectId. Base on pseudo-code: (function undoResolution(objectId) { revertToPreviousState(objectId); }). Integrate state storage in the backend or client-side to maintain data integrity, ensuring undo works even after page refreshes if needed.",
            "status": "pending",
            "testStrategy": "Scenario tests: Apply resolution, undo, and verify state reverts correctly. Check data integrity post-undo."
          },
          {
            "id": 3,
            "title": "Create Manual Merge Interface for Compatible Changes",
            "description": "Provide a manual merge interface for compatible changes in conflict resolution.",
            "dependencies": [
              1
            ],
            "details": "Develop a UI component for manual merging of compatible changes, allowing users to select and combine elements from client and server states. Include options for side-by-side comparison and manual editing. Ensure it integrates with the preview functionality for a seamless workflow.",
            "status": "pending",
            "testStrategy": "Interaction tests: Simulate compatible conflicts, use merge interface to combine changes, and verify the merged result is accurate."
          },
          {
            "id": 4,
            "title": "Integrate Preview, Undo, and Merge into Conflict Resolution UI",
            "description": "Integrate all new features (preview, undo, merge) into the overall conflict resolution UI workflow.",
            "dependencies": [
              2,
              3
            ],
            "details": "Update the conflict resolution UI to incorporate the preview, undo, and manual merge features. Ensure the UI handles user interactions smoothly, such as triggering previews on resolution changes, enabling undo buttons post-resolution, and displaying merge options for compatible conflicts. Maintain high user experience and data integrity as per complexity analysis.",
            "status": "pending",
            "testStrategy": "End-to-end UI tests covering the full workflow: preview changes, apply resolution, undo if needed, and use merge options. Verify no data loss or corruption."
          }
        ]
      },
      {
        "id": 24,
        "title": "Conduct Comprehensive Testing",
        "description": "Perform unit, integration, and end-to-end testing for the object-level locking system, including load and edge case testing.",
        "details": "Run unit tests for all new functions (version management, conflict detection). Integration tests for WebSocket and database interactions. End-to-end tests simulating concurrent editing, conflicts, and resolutions with 100+ users. Test network failures and race conditions. Use tools like Jest for frontend and Lisp testing frameworks for backend.",
        "testStrategy": "Achieve 100% coverage on critical paths. Measure performance metrics like <10ms conflict checks and <100ms latency. Validate success criteria: 80% reduction in blocking, zero silent overwrites.",
        "priority": "high",
        "dependencies": [
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Unit Testing for Object-Level Locking Functions",
            "description": "Run unit tests for all new functions related to version management and conflict detection in the object-level locking system.",
            "dependencies": [],
            "details": "Use Jest for frontend unit tests and Lisp testing frameworks for backend. Cover functions like version management, conflict detection, ensuring 100% coverage on critical paths. Measure performance metrics such as <10ms for conflict checks.",
            "status": "pending",
            "testStrategy": "Achieve 100% code coverage on unit tests for new functions, validate success criteria like zero silent overwrites."
          },
          {
            "id": 2,
            "title": "Integration Testing for WebSocket and Database Interactions",
            "description": "Perform integration tests to verify interactions between WebSocket communications and database operations in the locking system.",
            "dependencies": [
              1
            ],
            "details": "Test WebSocket and database integrations for lock acquisition, release, and conflict resolution. Ensure seamless data flow and handle race conditions. Use profiling tools to maintain <100ms latency.",
            "status": "pending",
            "testStrategy": "Integration tests with mocked environments to verify correct handling of concurrent operations and data consistency."
          },
          {
            "id": 3,
            "title": "End-to-End Testing for Concurrent Editing Scenarios",
            "description": "Conduct end-to-end tests simulating real-world usage with concurrent editing, conflicts, and resolutions involving multiple users.",
            "dependencies": [
              2
            ],
            "details": "Simulate 100+ users performing concurrent edits, triggering conflicts and resolutions. Test real-time sync via WebSocket broadcasts for successful updates and conflict notifications. Validate 80% reduction in blocking.",
            "status": "pending",
            "testStrategy": "End-to-end tests with multiple browser instances or simulated clients to confirm real-time updates and conflict handling."
          },
          {
            "id": 4,
            "title": "Load Testing for Scalability and Performance",
            "description": "Execute load tests to assess the system's performance under high user load and object volume.",
            "dependencies": [
              3
            ],
            "details": "Test with 1000+ objects and 100+ users to verify scalability. Monitor conflict rates, resolution times, and ensure <5% latency increase. Implement caching and indexing as needed for optimization.",
            "status": "pending",
            "testStrategy": "Load tests in a production-like environment, measuring metrics like memory usage (<20% increase) and query performance."
          },
          {
            "id": 5,
            "title": "Edge Case Validation for Network Failures and Race Conditions",
            "description": "Validate the system against edge cases including network failures, race conditions, and unusual user behaviors.",
            "dependencies": [
              4
            ],
            "details": "Test scenarios like network disconnections, rapid successive edits causing race conditions, and invalid inputs. Ensure the system handles these gracefully without data loss or silent overwrites.",
            "status": "pending",
            "testStrategy": "Edge case tests simulating failures and anomalies, verifying system resilience and adherence to success criteria."
          }
        ]
      },
      {
        "id": 25,
        "title": "Performance Optimization and Monitoring",
        "description": "Optimize the system for performance and add monitoring for conflicts and usage metrics.",
        "details": "Implement caching for version data to reduce database queries. Add indexing on version and last_modified_at columns. Monitor conflict rates, resolution times, and performance degradation. Use profiling tools to ensure <5% latency increase. Pseudo-code: (defun cache-version (object-id version) (setf (gethash object-id *version-cache*) version)) Integrate analytics for collaboration patterns.",
        "testStrategy": "Load tests with 1000+ objects and 100+ users to verify scalability. Monitor metrics in production-like environment to confirm <20% memory increase and maintained query performance.",
        "priority": "medium",
        "dependencies": [
          24
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Caching for Version Data",
            "description": "Implement caching mechanism for version data to reduce database queries, including adding indexing on version and last_modified_at columns.",
            "dependencies": [],
            "details": "In the system module, add a cache structure (e.g., hash table) for storing version data keyed by object-id. Implement functions to cache and retrieve versions, ensuring thread-safety. Add database indexing on version and last_modified_at columns to optimize queries. Integrate the pseudo-code provided: (defun cache-version (object-id version) (setf (gethash object-id *version-cache*) version)). Ensure cache invalidation on updates.",
            "status": "pending",
            "testStrategy": "Unit tests for cache operations including hit/miss ratios and database query reduction verification."
          },
          {
            "id": 2,
            "title": "Add Monitoring for Conflicts and Usage Metrics",
            "description": "Set up monitoring for conflict rates, resolution times, performance degradation, and integrate analytics for collaboration patterns.",
            "dependencies": [
              1
            ],
            "details": "Extend the conflict detection module to log metrics such as conflict rates, resolution times, and performance degradation. Integrate analytics to track collaboration patterns, such as user interactions and update frequencies. Use tools to collect and store these metrics in a database or external service. Ensure real-time monitoring capabilities for production environments.",
            "status": "pending",
            "testStrategy": "Load tests with 1000+ objects and 100+ users to monitor metrics in a production-like environment, confirming maintained query performance and <20% memory increase."
          },
          {
            "id": 3,
            "title": "Profile Performance to Ensure Latency Goals",
            "description": "Use profiling tools to analyze system performance and ensure no more than 5% latency increase after optimizations.",
            "dependencies": [
              1,
              2
            ],
            "details": "Employ profiling tools (e.g., built-in Lisp profilers or external tools) to measure latency before and after implementing caching and monitoring. Run benchmarks on key operations like version retrieval and conflict detection. Adjust implementations as needed to meet the <5% latency increase threshold. Document profiling results and integrate continuous profiling in the development pipeline.",
            "status": "pending",
            "testStrategy": "Benchmark tests comparing pre- and post-optimization latency on core functions, ensuring <5% increase and verifying scalability under load."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-10-14T14:40:42.116Z",
      "updated": "2025-10-14T18:52:29.375Z",
      "description": "Tasks for master context"
    }
  },
  "perf": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement Cursor Update Batching",
        "description": "Batch cursor updates on the backend and throttle sending on the frontend to reduce network traffic and ensure <50ms latency.",
        "details": "On the backend, create a message-queue struct with cursor-batch and object-batch. Implement queue-cursor-update to add updates to the batch and flush-cursor-batch to send batched updates every 50ms. On the frontend, create a CursorThrottle class that throttles updates to max 20/sec using setInterval. Ensure batch messages include all cursor positions and latency remains <50ms.",
        "testStrategy": "Unit test the batching logic to verify updates are queued and flushed correctly. Integration test with multiple clients to measure latency and ensure it stays under 50ms. Load test with 5 concurrent users to confirm no lag.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Backend Message Queue for Cursor Batching",
            "description": "Create a backend message-queue struct that includes cursor-batch and object-batch components. Implement functions to queue cursor updates and flush batches every 50ms to reduce network traffic.",
            "dependencies": [],
            "details": "On the backend, define a message-queue struct with arrays for cursor-batch and object-batch. Implement queue-cursor-update to append updates to the cursor-batch. Implement flush-cursor-batch to send the batched updates via WebSocket or similar every 50ms using a timer. Ensure the batch includes all cursor positions and handles multiple updates efficiently.",
            "status": "done",
            "testStrategy": "Unit test the queue and flush functions to verify updates are batched and sent at the correct intervals.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T15:59:40.899Z"
          },
          {
            "id": 2,
            "title": "Implement Frontend Cursor Throttling Logic",
            "description": "Create a CursorThrottle class on the frontend to limit cursor updates to a maximum of 20 per second using setInterval, ensuring low latency.",
            "dependencies": [],
            "details": "On the frontend, develop a CursorThrottle class that uses setInterval to throttle cursor position updates to no more than 20 per second. Capture cursor movements, buffer them, and send batched updates at the throttled rate. Integrate with the backend batching to maintain overall latency under 50ms.",
            "status": "done",
            "testStrategy": "Unit test the throttling mechanism to ensure it limits updates to 20/sec and handles rapid cursor movements without exceeding the rate.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T15:59:42.195Z"
          },
          {
            "id": 3,
            "title": "Conduct Comprehensive Testing Including Latency Measurements",
            "description": "Perform unit, integration, and load testing to verify batching and throttling work correctly, with a focus on measuring and ensuring latency remains under 50ms.",
            "dependencies": [],
            "details": "Execute unit tests for backend batching and frontend throttling. Run integration tests with multiple clients to simulate real-world usage. Conduct load tests with 5 concurrent users to measure latency using tools like performance.now(). Ensure all tests confirm latency <50ms and no network overload.",
            "status": "done",
            "testStrategy": "Use automated testing frameworks for unit and integration tests; employ load testing tools to measure latency percentiles and verify compliance with <50ms requirement under various conditions.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T15:59:43.450Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down the task into backend queue implementation, frontend throttling logic, and comprehensive testing including latency measurements.",
        "updatedAt": "2025-10-14T15:59:43.450Z"
      },
      {
        "id": 2,
        "title": "Implement Delta Compression for Object Updates",
        "description": "Send only changed fields for object updates to reduce bandwidth by 60-80%.",
        "details": "On the backend, create create-object-delta function to compare old and new objects and return only changed properties like x, y, width, height, rotation, color. On the frontend, implement applyDelta method to update only the changed properties on the object. Send full object state on creation and deltas thereafter.",
        "testStrategy": "Unit test delta creation to ensure only changed fields are included. Integration test to verify deltas are applied correctly across clients. Measure bandwidth usage before and after implementation to confirm 60-80% reduction.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Backend Delta Creation Function",
            "description": "Create the create-object-delta function on the backend to compare old and new objects and return only changed properties such as x, y, width, height, rotation, and color.",
            "dependencies": [],
            "details": "On the backend, implement a function that takes old and new object states, performs a deep comparison to identify changed fields, and returns a delta object containing only the modified properties. Ensure the function handles nested objects if necessary and is efficient for real-time updates.",
            "status": "done",
            "testStrategy": "Unit test the delta creation to ensure only changed fields are included and no unchanged fields are present.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Frontend Delta Application and Bandwidth Testing",
            "description": "Implement the applyDelta method on the frontend to update only the changed properties on objects and measure bandwidth reduction.",
            "dependencies": [
              1
            ],
            "details": "On the frontend, create an applyDelta method that merges the delta into the existing object state without overwriting unchanged fields. Send full object state on creation and deltas thereafter. Conduct bandwidth measurement tests by comparing network usage before and after implementation to confirm 60-80% reduction.",
            "status": "done",
            "testStrategy": "Integration test to verify deltas are applied correctly across clients. Measure bandwidth usage before and after implementation using network profiling tools to confirm the 60-80% reduction.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Separate into backend delta creation, frontend delta application, and bandwidth measurement testing."
      },
      {
        "id": 3,
        "title": "Implement Priority Queue for Messages",
        "description": "Prioritize cursor and presence updates over object updates to prevent cursor lag.",
        "details": "On the backend, create a priority-queue struct with high-priority (cursors, presence), normal-priority (object updates), and low-priority queues. Implement process-message-queue to process high-priority first, then normal with a limit. Ensure message ordering within priorities.",
        "testStrategy": "Unit test queue processing to verify priority order. Integration test during heavy object updates to ensure cursor updates are not delayed. Performance test to confirm no cursor lag with high object update frequency.",
        "priority": "medium",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Priority Queue Structure",
            "description": "Create a priority-queue struct with three levels: high-priority for cursors and presence updates, normal-priority for object updates, and low-priority queues to manage message ordering.",
            "dependencies": [],
            "details": "Implement a data structure using arrays or linked lists for each priority level, ensuring FIFO ordering within each priority. Include methods to enqueue messages with their priority and dequeue based on priority order.",
            "status": "done",
            "testStrategy": "Unit test the queue structure to verify correct enqueuing and dequeuing across priorities.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Message Processing Logic",
            "description": "Develop process-message-queue function to process high-priority messages first, then normal-priority with a limit, ensuring no lag in cursor updates.",
            "dependencies": [
              1
            ],
            "details": "Write logic to iterate through high-priority queue completely, then process up to a configurable limit from normal-priority, and optionally low-priority. Maintain message ordering within priorities using timestamps or sequence numbers.",
            "status": "done",
            "testStrategy": "Unit test the processing logic to confirm priority order and limits are respected.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Test Priority Handling Under High Load",
            "description": "Perform testing to ensure priority queue prevents cursor lag during heavy object updates and concurrent presence changes.",
            "dependencies": [
              1,
              2
            ],
            "details": "Set up load tests simulating high-frequency object updates while monitoring cursor and presence update delays. Use performance metrics to verify that high-priority messages are processed without significant lag.",
            "status": "done",
            "testStrategy": "Integration and performance tests under simulated high load to measure latency and confirm no cursor lag.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Divide into queue structure design, processing logic, and priority testing under high load."
      },
      {
        "id": 4,
        "title": "Implement Object Culling for Rendering",
        "description": "Only render objects visible in the viewport plus padding to maintain 60 FPS with 500+ objects.",
        "details": "In CanvasManager, add setupViewportCulling to listen for viewport moved/zoomed events and call updateVisibleObjects. Implement updateVisibleObjects to calculate visible bounds with 200px padding and set obj.visible and obj.renderable based on intersection. Use getVisibleBounds and isIntersecting helper functions.",
        "testStrategy": "Unit test bounds calculation and intersection logic. Integration test by creating 500+ objects and verifying only visible ones are rendered. Performance test to ensure 60 FPS during pan/zoom operations.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Viewport Calculation and Culling Logic",
            "description": "Add setupViewportCulling to listen for viewport events and implement updateVisibleObjects to calculate bounds with padding and set object visibility.",
            "dependencies": [],
            "details": "In CanvasManager, add setupViewportCulling method to listen for viewport moved/zoomed events and call updateVisibleObjects. Implement updateVisibleObjects to calculate visible bounds with 200px padding using getVisibleBounds, and set obj.visible and obj.renderable based on intersection using isIntersecting helper functions.",
            "status": "done",
            "testStrategy": "Unit test bounds calculation and intersection logic.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Performance Testing with Many Objects",
            "description": "Test rendering performance with 500+ objects to ensure 60 FPS during pan/zoom operations.",
            "dependencies": [
              1
            ],
            "details": "Create integration tests by generating 500+ objects and verifying only visible ones are rendered. Perform performance tests to measure FPS during pan/zoom operations, ensuring it maintains 60 FPS with the culling logic in place.",
            "status": "done",
            "testStrategy": "Integration test with 500+ objects to verify visibility. Performance test for 60 FPS during pan/zoom.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:02:47.879Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Split into viewport calculation, culling logic, and performance testing with many objects.",
        "updatedAt": "2025-10-14T16:02:47.879Z"
      },
      {
        "id": 5,
        "title": "Add FPS Monitoring",
        "description": "Track and log FPS to detect drops below 55 and provide performance stats.",
        "details": "Create PerformanceMonitor class that uses app.ticker to track FPS in a history array of max 60 entries. Log warnings when FPS < 55, including object count and average FPS. Provide getStats method for current, average, min, max FPS.",
        "testStrategy": "Unit test FPS tracking accuracy. Integration test by simulating load and checking logs for warnings. Manual test to access stats via console and verify no performance impact from monitoring.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create PerformanceMonitor Class Structure",
            "description": "Set up the basic PerformanceMonitor class with necessary properties and initialization.",
            "dependencies": [],
            "details": "Define the PerformanceMonitor class with properties for FPS history array (max 60 entries), current FPS, and methods stubs for tracking and stats. Ensure it integrates with app.ticker for updates.",
            "status": "done",
            "testStrategy": "Unit test class instantiation and property initialization.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:18:10.090Z"
          },
          {
            "id": 2,
            "title": "Implement FPS Tracking with Ticker",
            "description": "Use app.ticker to calculate and track FPS in real-time.",
            "dependencies": [
              1
            ],
            "details": "In the PerformanceMonitor class, add a ticker listener that calculates FPS based on delta time from the ticker. Update the current FPS value on each tick and prepare for adding to history.",
            "status": "done",
            "testStrategy": "Unit test FPS calculation accuracy by mocking ticker events.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:18:11.375Z"
          },
          {
            "id": 3,
            "title": "Add FPS History Array Management",
            "description": "Maintain a history array of FPS values with a maximum of 60 entries.",
            "dependencies": [
              2
            ],
            "details": "Implement logic to add current FPS to the history array on each update, ensuring the array does not exceed 60 entries by removing oldest values. Calculate average FPS from the history.",
            "status": "done",
            "testStrategy": "Unit test array management, including adding, removing, and average calculation.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:18:12.803Z"
          },
          {
            "id": 4,
            "title": "Implement Warning Logging for Low FPS",
            "description": "Log warnings when FPS drops below 55, including object count and average FPS.",
            "dependencies": [
              3
            ],
            "details": "Add logic to check if current FPS is below 55, and if so, log a warning message that includes the current object count (assuming access to object count) and the average FPS from history. Use console.warn or similar.",
            "status": "done",
            "testStrategy": "Integration test by simulating low FPS scenarios and verifying logs are generated correctly.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:18:14.154Z"
          },
          {
            "id": 5,
            "title": "Provide getStats Method for FPS Statistics",
            "description": "Implement getStats method to return current, average, min, and max FPS.",
            "dependencies": [
              3
            ],
            "details": "Create the getStats method that computes and returns an object with current FPS, average FPS (from history), minimum FPS, and maximum FPS from the history array. Ensure calculations are accurate and efficient.",
            "status": "done",
            "testStrategy": "Unit test the getStats method with various history arrays to verify correct stats output.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:18:15.523Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": "2025-10-14T16:18:15.523Z"
      },
      {
        "id": 6,
        "title": "Optimize Remote Cursor Rendering",
        "description": "Use shared textures for cursors to improve performance with multiple remote cursors.",
        "details": "In createRemoteCursor, create a shared cursorTexture once using PIXI.Graphics for the cursor shape. Use PIXI.Sprite with tint for color instead of individual graphics. Add username label as PIXI.Text. Ensure smooth movement at 60 FPS with 10+ cursors.",
        "testStrategy": "Unit test texture sharing and sprite creation. Performance test rendering 10+ cursors to confirm no FPS drop. Visual test to ensure cursors are readable and performant.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Shared Cursor Texture",
            "description": "Generate a single shared texture for the cursor shape using PIXI.Graphics to avoid recreating graphics for each cursor.",
            "dependencies": [],
            "details": "In the PIXI application, create a function to draw a cursor shape (e.g., arrow or pointer) using PIXI.Graphics, render it to a texture once, and store it as a shared resource. This texture will be reused for all remote cursors to optimize memory and rendering performance.",
            "status": "done",
            "testStrategy": "Unit test to verify the texture is created correctly and can be reused without errors.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Refactor createRemoteCursor to Use Shared Texture and Sprite",
            "description": "Update the createRemoteCursor function to use the shared texture with PIXI.Sprite and apply tint for color variations instead of individual graphics.",
            "dependencies": [
              1
            ],
            "details": "Modify createRemoteCursor to instantiate a PIXI.Sprite using the shared cursorTexture, set its tint property for different colors based on user, and position it accordingly. Remove any code that creates individual PIXI.Graphics for each cursor to reduce overhead.",
            "status": "done",
            "testStrategy": "Unit test sprite creation and tint application to ensure colors are applied correctly.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Username Label to Remote Cursors",
            "description": "Attach a PIXI.Text label displaying the username to each remote cursor for identification.",
            "dependencies": [
              2
            ],
            "details": "In createRemoteCursor, create a PIXI.Text object with the username, style it appropriately (e.g., font size, color), and add it as a child to the cursor sprite. Position the text relative to the cursor (e.g., above or beside it) to ensure readability.",
            "status": "done",
            "testStrategy": "Visual test to confirm labels are displayed correctly and do not overlap or obscure the cursor.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Smooth Cursor Movement",
            "description": "Ensure cursor positions are updated smoothly to achieve 60 FPS movement with multiple cursors.",
            "dependencies": [
              2
            ],
            "details": "Update the cursor update logic to interpolate positions between received updates for fluid animation. Use requestAnimationFrame or PIXI's ticker to animate cursor movement, ensuring it handles 10+ cursors without dropping below 60 FPS.",
            "status": "done",
            "testStrategy": "Performance test rendering and animating 10+ cursors to measure FPS and confirm smooth movement.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Optimize and Test Overall Rendering Performance",
            "description": "Conduct performance optimizations and tests to ensure the system maintains 60 FPS with 10+ remote cursors.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Profile the rendering pipeline, optimize any bottlenecks in texture usage, sprite management, and animation. Run comprehensive tests including unit tests for components, performance benchmarks for FPS, and visual checks for readability and performance.",
            "status": "done",
            "testStrategy": "Performance test with 10+ cursors to confirm no FPS drop; visual test for readability; integration test to ensure all components work together seamlessly.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": ""
      },
      {
        "id": 7,
        "title": "Implement Memory Cleanup on Disconnect",
        "description": "Properly clean up user data and objects on disconnect to prevent memory leaks.",
        "details": "On backend, in handle-client-disconnect, remove client from room, broadcast user-left, and clean up user data. On frontend, handleUserLeft to destroy cursors (keeping shared texture), remove from activeUsers, and update UI. Add startPeriodicCleanup to remove orphaned objects every minute.",
        "testStrategy": "Unit test cleanup functions. Integration test connect/disconnect cycles to verify memory stability. Run 24-hour session test to ensure no memory growth.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Backend Disconnect Handling",
            "description": "Handle client disconnection on the backend by removing the client from the room, broadcasting user-left events, and cleaning up associated user data to prevent memory leaks.",
            "dependencies": [],
            "details": "In the handle-client-disconnect function, ensure the client is removed from the room structure, broadcast a user-left event to other clients, and perform thorough cleanup of user-specific data such as session variables and temporary caches. This prevents orphaned references that could lead to memory accumulation.",
            "status": "done",
            "testStrategy": "Unit test the cleanup functions to verify that user data is properly removed upon disconnect.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:16:03.329Z"
          },
          {
            "id": 2,
            "title": "Implement Frontend Memory Cleanup",
            "description": "On the frontend, handle user-left events to destroy cursors while preserving shared textures, remove users from active lists, and update the UI accordingly.",
            "dependencies": [],
            "details": "In the handleUserLeft function, destroy individual cursor objects but keep shared textures intact to avoid unnecessary reloading. Remove the disconnected user from the activeUsers array and update any UI elements that display user presence. Ensure no references to the user remain in the DOM or memory.",
            "status": "done",
            "testStrategy": "Integration test connect/disconnect cycles to verify that frontend memory is stable and no leaks occur during repeated user joins and leaves.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:16:04.616Z"
          },
          {
            "id": 3,
            "title": "Add Periodic Memory Cleanup and Long-Term Testing",
            "description": "Implement a periodic cleanup mechanism to remove orphaned objects every minute and conduct thorough testing to ensure no memory growth over time.",
            "dependencies": [],
            "details": "Add a startPeriodicCleanup function that runs every minute to scan for and remove orphaned objects, such as unused PIXI elements or stale data structures. Integrate this into the application's main loop. Conduct a 24-hour session test to monitor memory usage and confirm no gradual leaks occur under sustained load.",
            "status": "done",
            "testStrategy": "Run a 24-hour session test to ensure no memory growth, combined with memory profiling to detect any leaks during periodic cleanup operations.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:16:05.909Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Separate into backend disconnect handling, frontend cleanup, and long-term memory testing.",
        "updatedAt": "2025-10-14T16:16:05.909Z"
      },
      {
        "id": 8,
        "title": "Implement Object Deletion with Proper Cleanup",
        "description": "Ensure deleted objects are fully removed from memory and textures are managed.",
        "details": "In deleteObject, use obj.destroy with options to destroy children but keep shared textures. Remove from objects and selectedObjects maps. For bulk delete, process multiple IDs and broadcast deletions once. Ensure no orphaned PIXI objects.",
        "testStrategy": "Unit test deletion and bulk operations. Memory profiling test to confirm no leaks after deletions. Integration test to verify objects are removed across clients.",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Single and Bulk Object Deletion Logic",
            "description": "Develop the core logic for deleting individual objects and handling bulk deletions, ensuring proper cleanup of PIXI objects and removal from maps.",
            "dependencies": [],
            "details": "In the deleteObject function, use obj.destroy with options to destroy children but preserve shared textures. Remove the object from both objects and selectedObjects maps. For bulk delete, process an array of IDs, perform deletions, and broadcast the deletions once to avoid multiple broadcasts. Ensure no orphaned PIXI objects remain in the scene graph.",
            "status": "done",
            "testStrategy": "Unit tests for deleteObject and bulkDelete functions to verify objects are removed from maps and destroyed correctly. Integration tests to confirm broadcasts are sent properly for bulk operations.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Memory Leak Verification for Object Deletion",
            "description": "Add mechanisms to verify that deleted objects are fully removed from memory and no leaks occur, including texture management checks.",
            "dependencies": [
              1
            ],
            "details": "After deletion, implement checks to ensure PIXI objects are not retained in memory. Use memory profiling tools or custom checks to confirm textures are managed properly (shared ones kept, others released). Add logging or assertions to detect orphaned objects. Integrate with the deletion logic to run verifications post-deletion.",
            "status": "done",
            "testStrategy": "Memory profiling tests using tools like Chrome DevTools to confirm no leaks after deletions. Unit tests for verification functions to ensure they detect potential issues. Integration tests to verify no orphaned objects in the PIXI stage after bulk deletions.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break into deletion logic, bulk operations, and memory leak verification."
      },
      {
        "id": 9,
        "title": "Add Rate Limiting and Input Validation",
        "description": "Protect against abuse with rate limiting and validate input to prevent invalid data.",
        "details": "On backend, create rate-limiter struct with message count and window. Implement check-rate-limit to allow max 100 messages/sec, resetting window. Add validate-object-update and validate-canvas-state for bounds checking. Reject invalid data with errors.",
        "testStrategy": "Unit test rate limiter and validation functions. Load test to attempt DoS and verify limits are enforced. Integration test invalid inputs are rejected with error messages.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Rate Limiter Struct and Logic",
            "description": "Create a rate-limiter struct with message count and window, and implement check-rate-limit to allow max 100 messages/sec, resetting the window as needed.",
            "dependencies": [],
            "details": "On the backend, define a rate-limiter struct that tracks message counts within a time window. Implement the check-rate-limit function to enforce a maximum of 100 messages per second, automatically resetting the window when the time period expires. Ensure thread-safety for concurrent access.",
            "status": "done",
            "testStrategy": "Unit test the rate limiter to verify it correctly allows up to 100 messages per second and resets the window appropriately.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add Input Validation Functions",
            "description": "Implement validate-object-update and validate-canvas-state functions to perform bounds checking on input data.",
            "dependencies": [],
            "details": "Add validation functions on the backend to check bounds for object updates and canvas states. These functions should verify that provided values are within acceptable ranges, such as position coordinates, sizes, and other properties, to prevent invalid data from being processed.",
            "status": "done",
            "testStrategy": "Unit test the validation functions to ensure they correctly identify and flag invalid inputs based on defined bounds.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Conduct Abuse and DoS Testing",
            "description": "Perform load testing to simulate abuse scenarios, including attempts at DoS attacks, and verify that rate limits are enforced.",
            "dependencies": [
              1
            ],
            "details": "Set up load tests that attempt to exceed the rate limits by sending high volumes of messages. Monitor the system to ensure the rate limiter blocks excessive requests and prevents DoS conditions. Use tools to simulate concurrent high-traffic scenarios.",
            "status": "done",
            "testStrategy": "Load test to attempt DoS and verify that limits are enforced, preventing system overload.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Error Handling for Invalid Data",
            "description": "Add error handling mechanisms to reject invalid data and return appropriate error messages to clients.",
            "dependencies": [
              2
            ],
            "details": "Integrate error responses into the validation functions so that when invalid data is detected, the system rejects it and sends back clear error messages indicating what was wrong (e.g., out-of-bounds values). Ensure errors are logged and communicated properly without exposing sensitive information.",
            "status": "done",
            "testStrategy": "Integration test to verify that invalid inputs are rejected with appropriate error messages.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Divide into rate limiter implementation, validation functions, abuse testing, and error handling."
      },
      {
        "id": 10,
        "title": "Optimize Database Access with Pooling and Indexing",
        "description": "Implement connection pooling and add indexes to improve query performance.",
        "details": "Create db-pool struct with 10 connections and thread-safe access using bt:make-lock. Implement with-db-connection macro for reusing connections. Add SQL indexes on canvas_id, session_id, user_id, email. Optimize save-canvas-state-optimized with transactions and INSERT OR REPLACE.",
        "testStrategy": "Unit test connection pooling for reuse and thread-safety. Performance test query execution times to ensure <10ms. Load test database operations to confirm no contention or leaks.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Database Connection Pooling",
            "description": "Set up a connection pool to manage database connections efficiently with thread-safe access.",
            "dependencies": [],
            "details": "Create a db-pool struct with 10 connections and ensure thread-safe access using bt:make-lock. Implement the with-db-connection macro to allow reusing connections from the pool, preventing connection exhaustion and improving concurrency.",
            "status": "done",
            "testStrategy": "Unit test connection pooling for reuse and thread-safety, verifying that connections are properly acquired and released without leaks.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:24:32.583Z"
          },
          {
            "id": 2,
            "title": "Add SQL Indexes on Key Columns",
            "description": "Create indexes on frequently queried columns to speed up database lookups.",
            "dependencies": [],
            "details": "Add SQL indexes on canvas_id, session_id, user_id, and email columns in the relevant database tables. This will reduce query execution time by allowing faster searches and joins on these fields.",
            "status": "done",
            "testStrategy": "Performance test query execution times after indexing to ensure they remain under 10ms, comparing before and after metrics.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:24:33.878Z"
          },
          {
            "id": 3,
            "title": "Optimize Canvas State Saving with Transactions",
            "description": "Enhance the save-canvas-state-optimized function using transactions and efficient insert operations.",
            "dependencies": [],
            "details": "Modify save-canvas-state-optimized to use database transactions for atomic operations and employ INSERT OR REPLACE statements to handle updates and inserts efficiently, minimizing overhead and ensuring data consistency.",
            "status": "done",
            "testStrategy": "Unit test the transaction logic to verify atomicity and correctness of INSERT OR REPLACE operations under various scenarios.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:24:35.189Z"
          },
          {
            "id": 4,
            "title": "Perform Performance and Load Testing",
            "description": "Conduct comprehensive testing to validate database performance under load and ensure no issues.",
            "dependencies": [],
            "details": "Execute load tests on database operations to confirm there is no contention, connection leaks, or performance degradation. Monitor query times to maintain sub-10ms performance even under high concurrency.",
            "status": "done",
            "testStrategy": "Load test database operations to confirm no contention or leaks, and performance test query execution times to ensure they stay under 10ms with simulated high-load conditions.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:24:36.586Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Split into pooling setup, indexing, transaction optimization, and performance/load testing.",
        "updatedAt": "2025-10-14T16:24:36.586Z"
      },
      {
        "id": 11,
        "title": "Implement Performance Monitoring for Latency",
        "description": "Track message latency and provide stats for optimization.",
        "details": "Create LatencyMonitor class to track round-trip latency for messages using performance.now() and messageId. Record latencies in history, warn on >100ms. Provide getStats for percentiles (p50, p95, p99).",
        "testStrategy": "Unit test latency tracking. Integration test with message sending to verify stats accuracy. Performance profiling to ensure monitoring adds minimal overhead.",
        "priority": "medium",
        "dependencies": [
          "1",
          "2",
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define LatencyMonitor Class Structure",
            "description": "Create the basic LatencyMonitor class with constructor, properties for storing latency history, and initial setup.",
            "dependencies": [],
            "details": "Initialize the class with a Map or array to store message IDs and their start times. Include a history array to record completed latencies. Set up any necessary imports for performance.now().",
            "status": "done",
            "testStrategy": "Unit test the class instantiation and basic properties.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:29:30.329Z"
          },
          {
            "id": 2,
            "title": "Implement Latency Start Tracking",
            "description": "Add a method to start tracking latency for a message using performance.now() and messageId.",
            "dependencies": [
              1
            ],
            "details": "Create a startLatency(messageId) method that records the current performance.now() timestamp associated with the messageId in the tracking map.",
            "status": "done",
            "testStrategy": "Unit test the startLatency method to verify timestamps are recorded correctly.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:29:31.795Z"
          },
          {
            "id": 3,
            "title": "Implement Latency End Tracking and Recording",
            "description": "Add a method to stop tracking and calculate round-trip latency, then record it in history.",
            "dependencies": [
              2
            ],
            "details": "Create an endLatency(messageId) method that calculates the latency by subtracting the start time from current performance.now(), removes the entry from tracking map, and pushes the latency to the history array.",
            "status": "done",
            "testStrategy": "Unit test the endLatency method to ensure accurate latency calculation and recording.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:29:33.524Z"
          },
          {
            "id": 4,
            "title": "Add Warning for High Latency",
            "description": "Implement logic to warn when recorded latency exceeds 100ms.",
            "dependencies": [
              3
            ],
            "details": "In the endLatency method or a separate check, compare the calculated latency against 100ms and log a warning if exceeded. Use console.warn or a custom logging mechanism.",
            "status": "done",
            "testStrategy": "Unit test the warning logic by simulating latencies above and below 100ms.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:29:35.440Z"
          },
          {
            "id": 5,
            "title": "Implement getStats Method for Percentiles",
            "description": "Create a getStats method that computes and returns p50, p95, and p99 percentiles from the latency history.",
            "dependencies": [
              4
            ],
            "details": "Implement getStats() to sort the history array, calculate the percentiles using appropriate formulas (e.g., for p50, median; for p95, 95th percentile), and return an object with p50, p95, p99 values.",
            "status": "done",
            "testStrategy": "Unit test getStats with sample latency data to verify correct percentile calculations.",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T16:29:36.829Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": "2025-10-14T16:29:36.829Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-14T16:29:36.830Z",
      "taskCount": 11,
      "completedCount": 10,
      "tags": [
        "perf"
      ],
      "created": "2025-10-14T16:32:33.526Z",
      "description": "Tasks for perf context",
      "updated": "2025-10-14T16:32:33.527Z"
    }
  },
  "woo": {
    "tasks": [
      {
        "id": "1",
        "title": "Add Clack/Woo Dependencies to ASD File",
        "description": "Update collabcanvas.asd to include new dependencies like clack, woo, lack, lack-middleware-static, lack-middleware-cors, and websocket-driver.",
        "details": "Modify the :depends-on section in collabcanvas.asd to add the required libraries: :clack, :woo, :lack, :lack-middleware-static, :lack-middleware-cors, :websocket-driver. Ensure compatibility with existing dependencies. Use Quicklisp for loading.",
        "testStrategy": "Run (ql:quickload :collabcanvas) and verify no errors occur during loading.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Backup the current collabcanvas.asd file",
            "description": "Create a backup copy of the existing collabcanvas.asd file to ensure we can revert changes if needed.",
            "dependencies": [],
            "details": "Use a file copy command or editor to duplicate collabcanvas.asd, naming it something like collabcanvas.asd.backup, to preserve the original state before modifications.",
            "status": "pending",
            "testStrategy": "Verify the backup file exists and matches the original content.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Review existing dependencies in collabcanvas.asd",
            "description": "Examine the current :depends-on section to understand what dependencies are already listed.",
            "dependencies": [
              1
            ],
            "details": "Open collabcanvas.asd and locate the :depends-on list. Note down all current dependencies to check for potential conflicts with the new ones being added.",
            "status": "pending",
            "testStrategy": "Manually inspect the file and confirm the list of existing dependencies.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add new Clack/Woo dependencies to the ASD file",
            "description": "Insert the required libraries into the :depends-on section of collabcanvas.asd.",
            "dependencies": [
              2
            ],
            "details": "Edit the :depends-on list to include :clack, :woo, :lack, :lack-middleware-static, :lack-middleware-cors, and :websocket-driver. Ensure they are added in a logical order and formatted correctly.",
            "status": "pending",
            "testStrategy": "Check the file syntax after editing to ensure it's valid Lisp code.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Verify compatibility with existing dependencies",
            "description": "Check for any conflicts or incompatibilities between new and existing dependencies.",
            "dependencies": [
              3
            ],
            "details": "Review Quicklisp documentation or run a quick compatibility check by attempting to load the updated ASD file. Ensure no version conflicts or missing prerequisites.",
            "status": "pending",
            "testStrategy": "Attempt a dry-run load or check Quicklisp for dependency resolution.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Test loading the updated ASD file with Quicklisp",
            "description": "Run Quicklisp to load the project and verify all dependencies are resolved without errors.",
            "dependencies": [
              4
            ],
            "details": "Execute (ql:quickload :collabcanvas) in a Lisp REPL and monitor for any loading errors. Confirm that all new dependencies are successfully loaded.",
            "status": "pending",
            "testStrategy": "Run the quickload command and assert no errors are thrown during the process.",
            "parentId": "undefined"
          }
        ],
        "complexity": 2,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this is a straightforward file modification.",
        "updatedAt": "2025-10-15T21:34:18.711Z"
      },
      {
        "id": "2",
        "title": "Install and Test New Dependencies",
        "description": "Install the new Quicklisp libraries and test basic functionality, with explicit mandatory libev installation as a prerequisite for Woo.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "details": "CRITICAL: libev is a REQUIRED system dependency for Woo (not optional). Install libev BEFORE attempting to load Woo. Platform-specific instructions: Linux: sudo apt-get update; sudo apt-get install -y libev-dev gcc libc6-dev. macOS: brew install libev. Verify libev is installed by checking for /usr/include/ev.h (Linux) or /usr/local/include/ev.h (macOS); if missing, Woo will fail to compile with cryptic errors. Note: Windows is NOT supported by Woo due to libev; use WSL2 or Docker for Windows development. Only after libev is confirmed installed: ros -e '(ql:quickload :woo)'; ros -e '(ql:quickload :clack)'; ros -e '(ql:quickload :lack)'; ros -e '(ql:quickload :websocket-driver)'; ros -e '(ql:quickload :fast-http)'; ros -e '(ql:quickload :quri)'.",
        "testStrategy": "Check that each library loads without errors and basic functions like (clack:clackup) are available. Test basic functionality by checking that (find-package :woo) returns non-nil.",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Individual Dependencies Separately",
            "description": "Install libev as a mandatory prerequisite, then install each new Quicklisp dependency one by one, including system-level packages like libev and Quicklisp libraries such as woo, clack, lack, websocket-driver, fast-http, and quri.",
            "dependencies": [],
            "details": "First, install libev on the system: For Linux, run 'sudo apt-get update; sudo apt-get install -y libev-dev gcc libc6-dev'. For macOS, run 'brew install libev'. Verify libev is installed by checking for /usr/include/ev.h (Linux) or /usr/local/include/ev.h (macOS); if missing, Woo will fail to compile with cryptic errors. Note: Windows is NOT supported by Woo due to libev; use WSL2 or Docker for Windows development. Only after libev is confirmed installed, use ros commands to quickload each Quicklisp library individually: (ql:quickload :woo), (ql:quickload :clack), (ql:quickload :lack), (ql:quickload :websocket-driver), (ql:quickload :fast-http), (ql:quickload :quri). Ensure each loads without errors before proceeding to the next.",
            "status": "pending",
            "testStrategy": "Verify each quickload command completes successfully without throwing errors in the REPL, and confirm libev installation via file existence checks.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Test Installed Dependencies Collectively",
            "description": "Perform collective testing of all installed dependencies to ensure they work together and basic functionality is available.",
            "dependencies": [
              1
            ],
            "details": "After installing all dependencies, run a collective test by attempting to load the project with (ql:quickload :collabcanvas) and check for basic functions like (clack:clackup) being available. Verify that no compatibility issues arise when loading multiple libraries simultaneously. Test basic functionality by checking that (find-package :woo) returns non-nil.",
            "status": "pending",
            "testStrategy": "Execute (ql:quickload :collabcanvas) and confirm no errors; test basic Clack functions in a REPL to ensure they are callable without issues; verify (find-package :woo) returns non-nil.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break down into subtasks for installing each dependency separately and then testing them collectively.",
        "updatedAt": "2025-10-15T21:35:41.143Z"
      },
      {
        "id": "3",
        "title": "Create New Source Files",
        "description": "Create src/app.lisp, src/websocket-adapter.lisp, and src/server.lisp with initial structures.",
        "details": "Create app.lisp with make-app function using lack:builder. Create websocket-adapter.lisp with ws-connection struct and handler stubs. Create server.lisp with start-server, stop-server functions. Keep old files intact.",
        "testStrategy": "Verify files compile without syntax errors using (compile-file).",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Ensure src directory exists",
            "description": "Check and create the src directory if it does not exist to hold the new Lisp source files.",
            "dependencies": [],
            "details": "Verify the existence of the src directory in the project root. If it does not exist, create it using mkdir or equivalent command to prepare for file creation.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create src/app.lisp with make-app function",
            "description": "Create the app.lisp file in the src directory, implementing the make-app function using lack:builder.",
            "dependencies": [
              1
            ],
            "details": "In src/app.lisp, define a package and export the make-app function. Use lack:builder to construct the application with initial middleware stubs. Ensure the file follows Lisp syntax and includes necessary imports.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create src/websocket-adapter.lisp with ws-connection struct",
            "description": "Create the websocket-adapter.lisp file with the ws-connection struct and handler stubs.",
            "dependencies": [
              1
            ],
            "details": "In src/websocket-adapter.lisp, define a package, create the ws-connection struct with fields like id, socket, etc., and add placeholder functions for handlers such as on-open, on-message, on-close. Include necessary imports for websocket-driver.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create src/server.lisp with start-server and stop-server functions",
            "description": "Create the server.lisp file implementing start-server and stop-server functions.",
            "dependencies": [
              1
            ],
            "details": "In src/server.lisp, define a package and implement start-server to initialize and run the Clack server with Woo, and stop-server to gracefully shut it down. Include error handling and ensure integration with the app from app.lisp.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Compile all new source files to verify syntax",
            "description": "Compile the newly created Lisp files to ensure they have no syntax errors.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Use (compile-file) on each of src/app.lisp, src/websocket-adapter.lisp, and src/server.lisp. Check for any compilation errors or warnings. This step confirms the initial structures are syntactically correct before further development.",
            "status": "pending",
            "testStrategy": "Run (compile-file) on each file and verify no errors are reported in the output.",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as creating initial file structures is straightforward.",
        "updatedAt": "2025-10-15T21:39:30.824Z"
      },
      {
        "id": "4",
        "title": "Verify Woo Server Startup with Minimal App",
        "description": "Test starting Woo with a simple 'hello world' Clack app.",
        "details": "Create a minimal Clack app that returns a simple response. Use clack:clackup with :server :woo to start on a test port. Check server logs for successful startup.",
        "testStrategy": "Start the server, make a curl request to the endpoint, and verify response. Stop server and confirm no errors.",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Minimal Clack App",
            "description": "Develop a simple 'hello world' Clack application that returns a basic response.",
            "dependencies": [],
            "details": "Write a minimal Clack app using defun make-app that defines a route returning a simple string like 'Hello, World!'. Ensure it uses standard Clack structure.",
            "status": "pending",
            "testStrategy": "Verify the app can be loaded without errors in the Lisp environment.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configure Woo Server Integration",
            "description": "Set up the Clack app to use Woo as the server backend.",
            "dependencies": [
              1
            ],
            "details": "Modify the clack:clackup call to include :server :woo parameter. Ensure Woo is properly loaded as a dependency.",
            "status": "pending",
            "testStrategy": "Check that the configuration does not throw errors when initializing.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Start Server on Test Port",
            "description": "Launch the Woo server on a designated test port.",
            "dependencies": [
              2
            ],
            "details": "Use clack:clackup with the configured app and specify a test port (e.g., 8080). Handle any startup parameters appropriately.",
            "status": "pending",
            "testStrategy": "Monitor for successful server initialization without exceptions.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Check Server Logs for Startup Success",
            "description": "Examine server logs to confirm the Woo server started successfully.",
            "dependencies": [
              3
            ],
            "details": "After starting the server, review the output logs for indicators of successful startup, such as 'Server started' messages or absence of errors.",
            "status": "pending",
            "testStrategy": "Parse logs programmatically or manually to assert startup confirmation.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Perform Curl Request and Verify Response",
            "description": "Make an HTTP request to the server and validate the response.",
            "dependencies": [
              3
            ],
            "details": "Use curl to send a GET request to the test port endpoint and check that the response matches the expected 'hello world' output. Stop the server afterward.",
            "status": "pending",
            "testStrategy": "Automate the curl request in a test script and assert the response body and status code.",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as this is a focused testing task.",
        "updatedAt": "2025-10-15T21:41:39.667Z"
      },
      {
        "id": "5",
        "title": "Convert HTTP Handlers to Clack Format",
        "description": "Port handle-register, handle-login, handle-logout, handle-session-check, handle-canvas-state, and handle-health to accept env and return values.",
        "details": "For each handler, change signature to (defun handler (env)), use getf to access env data, parse body with parse-request-body, and return (values status headers body). Update route-handler to call these.",
        "testStrategy": "Unit test each handler with mock env plist, checking status and body.",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Convert Authentication Handlers to Clack Format",
            "description": "Port handle-register, handle-login, and handle-logout to accept env parameter and return values in Clack format.",
            "dependencies": [],
            "details": "For each handler (handle-register, handle-login, handle-logout), change the function signature to (defun handler (env)), use getf to access data from the env plist, parse the request body using parse-request-body, and return (values status headers body). Ensure all authentication logic remains intact.",
            "status": "pending",
            "testStrategy": "Unit test each handler with a mock env plist, verifying correct status codes and response bodies for various inputs.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Convert Utility Handlers to Clack Format",
            "description": "Port handle-session-check, handle-canvas-state, and handle-health to accept env parameter and return values in Clack format.",
            "dependencies": [],
            "details": "For each handler (handle-session-check, handle-canvas-state, handle-health), change the function signature to (defun handler (env)), use getf to access data from the env plist, parse the request body using parse-request-body where applicable, and return (values status headers body). Maintain existing functionality for session checks, canvas state, and health endpoints.",
            "status": "pending",
            "testStrategy": "Unit test each handler with a mock env plist, checking status codes, headers, and body content for expected behaviors.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate Handlers into Route Handler",
            "description": "Update the route-handler function to call the newly formatted handlers and handle their return values.",
            "dependencies": [
              1,
              2
            ],
            "details": "Modify the route-handler to invoke the updated handler functions (handle-register, handle-login, handle-logout, handle-session-check, handle-canvas-state, handle-health) with the env parameter, and properly process the returned (values status headers body) to construct the full HTTP response. Ensure routing logic directs requests correctly to each handler.",
            "status": "pending",
            "testStrategy": "Integration test by simulating route-handler calls with mock env data, verifying that responses are correctly formatted and match expected outputs for all endpoints.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Expand into subtasks for each handler (e.g., one for handle-register, one for handle-login, etc.) and a final integration subtask.",
        "updatedAt": "2025-10-15T21:44:01.230Z"
      },
      {
        "id": "6",
        "title": "Create Utility Functions for Request Parsing",
        "description": "Implement parse-request-body and json-response functions.",
        "details": "Define parse-request-body to read from (getf env :raw-body) and parse JSON. Define json-response to return proper values with to-json-string. Integrate into handlers.",
        "testStrategy": "Test parse-request-body with sample JSON input and verify output. Test json-response with data and check HTTP response format.",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define parse-request-body function",
            "description": "Implement the parse-request-body function to read and parse JSON from the request body.",
            "dependencies": [],
            "details": "Create a function named parse-request-body that takes an environment (env) and uses (getf env :raw-body) to retrieve the raw body, then parses it as JSON using appropriate Lisp JSON parsing library.",
            "status": "pending",
            "testStrategy": "Test with sample JSON strings to ensure correct parsing and error handling for invalid JSON.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Define json-response function",
            "description": "Implement the json-response function to format and return JSON responses.",
            "dependencies": [],
            "details": "Create a function named json-response that takes data and uses to-json-string to convert it to JSON, then returns it in a proper HTTP response format with appropriate headers.",
            "status": "pending",
            "testStrategy": "Test with various data types and verify the output is valid JSON and includes correct Content-Type header.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate parse-request-body into request handlers",
            "description": "Update existing request handlers to use the new parse-request-body function for parsing incoming JSON data.",
            "dependencies": [
              1
            ],
            "details": "Modify the handler functions in the application to call parse-request-body instead of manual parsing, ensuring it handles the env parameter correctly and integrates seamlessly with the request processing flow.",
            "status": "pending",
            "testStrategy": "Simulate requests with JSON bodies and check that handlers correctly parse and process the data.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate json-response into response handlers",
            "description": "Update existing response handlers to use the new json-response function for formatting outgoing JSON responses.",
            "dependencies": [
              2
            ],
            "details": "Modify the response generation parts of handlers to use json-response, ensuring it sets proper status codes, headers, and body content for JSON API responses.",
            "status": "pending",
            "testStrategy": "Test API endpoints by sending requests and verifying that responses are properly formatted JSON with correct HTTP status.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Test overall integration and error handling",
            "description": "Perform end-to-end testing of the utility functions integrated into the handlers.",
            "dependencies": [
              3,
              4
            ],
            "details": "Run comprehensive tests including valid and invalid JSON inputs, edge cases like empty bodies, and ensure error handling is robust, logging any issues appropriately in the server logs.",
            "status": "pending",
            "testStrategy": "Use curl or similar tools to make requests to the server, check logs for errors, and validate response formats.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as implementing two utility functions is contained.",
        "updatedAt": "2025-10-15T21:44:31.053Z"
      },
      {
        "id": "7",
        "title": "Test All HTTP Endpoints",
        "description": "Test migrated HTTP routes with curl or integration tests.",
        "details": "Start Clack server, send requests to /api/register, /api/login, /health, etc., using curl. Verify responses match expected JSON and status codes.",
        "testStrategy": "Integration test: Start server, perform full HTTP flow (register, login), stop server. Check logs for no errors.",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Test Individual HTTP Endpoints",
            "description": "Test each HTTP endpoint separately using curl to verify correct responses, status codes, and JSON formats for routes like /api/register, /api/login, /health, etc.",
            "dependencies": [],
            "details": "Start the Clack server on a test port. For each endpoint, send curl requests with appropriate data (e.g., POST for register/login). Check response status codes (e.g., 200 for success, 400 for errors) and JSON body content. Document any mismatches and ensure no server errors in logs.",
            "status": "pending",
            "testStrategy": "Manual curl testing: Send requests and manually verify outputs against expected results.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Perform Combined Integration Test",
            "description": "Execute a full integration test simulating user flow: register, login, and other interactions to ensure the entire HTTP system works cohesively.",
            "dependencies": [
              1
            ],
            "details": "Start the Clack server. Perform a sequence of requests: register a new user, then login with those credentials, check session, and test other endpoints like /health. Verify the full flow succeeds without errors, checking logs for any issues. Stop the server after testing.",
            "status": "pending",
            "testStrategy": "Integration test: Automate or manually run the full HTTP flow, validate responses, and ensure no errors in server logs.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break down into subtasks for testing individual endpoints and a combined integration test.",
        "updatedAt": "2025-10-15T21:45:59.751Z"
      },
      {
        "id": "8",
        "title": "Implement WebSocket Upgrade Handler",
        "description": "Add WebSocket middleware to Clack app and implement handle-websocket-upgrade.",
        "details": "In make-app, add (:websocket ...) middleware. Implement handle-websocket-upgrade to validate canvas-id, create ws-connection, register pending connection, and return 101.",
        "testStrategy": "Unit test handle-websocket-upgrade with mock env, checking status 101 for valid canvas-id and 400 for invalid.",
        "priority": "high",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add WebSocket Middleware to Clack App",
            "description": "Integrate WebSocket middleware into the Clack application setup to enable WebSocket upgrade handling.",
            "dependencies": [],
            "details": "In the make-app function, add the (:websocket ...) middleware to the middleware stack. Ensure it is properly configured to handle WebSocket connections and upgrades.",
            "status": "pending",
            "testStrategy": "Verify that the middleware is loaded and the app starts without errors, checking for WebSocket support in the app configuration.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement handle-websocket-upgrade Function",
            "description": "Create the handle-websocket-upgrade function to process WebSocket upgrade requests, validate inputs, and manage connections.",
            "dependencies": [],
            "details": "Implement handle-websocket-upgrade to validate the canvas-id from the request, create a ws-connection object, register it as a pending connection, and return a 101 status code for successful upgrades. Handle invalid canvas-ids by returning 400.",
            "status": "pending",
            "testStrategy": "Unit test with mock environment, asserting 101 status for valid canvas-id and 400 for invalid ones, ensuring proper connection registration.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Expand into subtasks for adding middleware and implementing the handler logic separately.",
        "updatedAt": "2025-10-15T21:50:46.211Z"
      },
      {
        "id": "9",
        "title": "Convert Canvas Room to Use New Connection Objects",
        "description": "Update room management to use ws-connection structs instead of Hunchensocket objects.",
        "details": "Modify room structures to store ws-connection instances. Update functions like add-connection-to-room, remove-connection-from-room to work with new structs.",
        "testStrategy": "Unit test room operations: create room, add/remove connections, verify counts and broadcasts.",
        "priority": "high",
        "dependencies": [
          "8"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update Room Structures to Use ws-connection Objects",
            "description": "Modify the room data structures in the canvas application to store ws-connection instances instead of Hunchensocket objects, ensuring compatibility with the new connection handling system.",
            "dependencies": [],
            "details": "Locate the room struct or class definitions in the codebase (likely in room.lisp or similar). Change the fields that previously held Hunchensocket objects to now hold ws-connection structs. Update any initialization code to create or assign ws-connection instances. Ensure that the room can handle multiple connections properly.",
            "status": "pending",
            "testStrategy": "Unit test room creation and initialization to verify that ws-connection objects are stored correctly and room counts are accurate.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Modify Room Management Functions for New Connection Objects",
            "description": "Update the functions responsible for adding and removing connections from rooms to operate with ws-connection structs instead of Hunchensocket objects.",
            "dependencies": [
              1
            ],
            "details": "Identify and modify functions such as add-connection-to-room and remove-connection-from-room. Change their parameters and logic to work with ws-connection structs, including updating any broadcasting or messaging mechanisms. Ensure error handling for invalid connections and maintain thread safety if applicable.",
            "status": "pending",
            "testStrategy": "Unit test the add and remove functions with mock ws-connection objects, verifying correct addition/removal, updated room counts, and proper broadcasting of messages to remaining connections.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break down into subtasks for updating room structures and modifying management functions.",
        "updatedAt": "2025-10-15T21:51:05.530Z"
      },
      {
        "id": "10",
        "title": "Port WebSocket Message Handlers",
        "description": "Implement handle-websocket-message, handle-auth-message, and dispatch-message for new API.",
        "details": "In handle-websocket-message, parse JSON, check auth, dispatch to handlers. Implement send-to-socket and broadcast-to-room using websocket-driver:send. Port cursor-update, object-create/update/delete handlers.",
        "testStrategy": "Integration test: Connect WebSocket client, send auth message, verify auth-success. Send updates and check broadcasts to multiple clients.",
        "priority": "high",
        "dependencies": [
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement WebSocket Message Parsing",
            "description": "Parse incoming JSON messages in the handle-websocket-message function to extract message type and payload.",
            "dependencies": [
              10
            ],
            "details": "Modify handle-websocket-message to use a JSON parsing library (e.g., cl-json) to decode the incoming WebSocket message string into a Lisp object, extracting fields like 'type' and 'data'. Ensure error handling for malformed JSON by sending appropriate error responses back to the client. This sets the foundation for further processing in auth and dispatch steps.",
            "status": "pending",
            "testStrategy": "Unit test with mock WebSocket messages to verify correct parsing of valid JSON and error handling for invalid JSON.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Authentication Message Handling",
            "description": "Add authentication checks in handle-auth-message to validate user credentials and manage session state.",
            "dependencies": [
              10
            ],
            "details": "In handle-auth-message, verify the auth token or credentials from the parsed message against the canvas access rules. If valid, update the ws-connection struct with auth status and user info; if invalid, send an auth-failure message. Integrate with existing auth logic from the old system, ensuring compatibility with canvas-id validation.",
            "status": "pending",
            "testStrategy": "Unit test handle-auth-message with mock auth data, checking for correct auth-success or auth-failure responses.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Message Dispatching and Port Handlers",
            "description": "Dispatch parsed messages to appropriate handlers and port cursor-update, object-create/update/delete handlers using websocket-driver.",
            "dependencies": [
              10
            ],
            "details": "Implement dispatch-message to route messages based on type (e.g., cursor-update, object-create). Port the handlers from the old API, adapting them to use websocket-driver:send for send-to-socket and broadcast-to-room functions. Ensure broadcasting sends updates to all clients in the room except the sender, and handle object CRUD operations with proper state synchronization.",
            "status": "pending",
            "testStrategy": "Integration test: Simulate WebSocket connections, send various message types, and verify correct dispatching, handler execution, and broadcasts to multiple clients.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Expand into subtasks for implementing message parsing, auth handling, and dispatching/porting specific handlers.",
        "updatedAt": "2025-10-15T21:52:45.089Z"
      },
      {
        "id": "11",
        "title": "Tune Woo for Production Workload",
        "description": "Configure Woo parameters, add metrics, and optimize for concurrency based on Fukamachi's best practices, including production clackup configuration, Linux kernel tuning, SBCL runtime tuning, connection monitoring, performance testing, and database pool thread safety.",
        "status": "done",
        "dependencies": [
          "10"
        ],
        "priority": "medium",
        "details": "Configure Woo with production-optimized parameters: (clack:clackup app :server :woo :address \"0.0.0.0\" :port 8080 :debug nil :worker-num 1 :backlog 4096 :max-request-per-child nil :use-thread nil). Use single worker due to SQLite limitations. Add Linux kernel tuning: ulimit -n 65535; sysctl -w net.core.somaxconn=4096; sysctl -w net.ipv4.tcp_max_syn_backlog=4096. Include SBCL runtime tuning: (sb-ext:gc :full t); (setf (sb-ext:bytes-consed-between-gcs) 67108864); (setf sb-thread:*deadlock-detection* t). Implement real-time connection monitoring with stats logging every 60 seconds. Ensure SQLite connection pool is thread-safe. Load test with wrk and thor, targeting HTTP 5000+ req/sec, WebSocket 100+ connections with <10ms latency, memory <500MB, CPU <30%.",
        "testStrategy": "Performance test using wrk for HTTP (wrk -t4 -c100 -d30s http://localhost:8080/health) and thor for WebSocket (thor ws://localhost:8080/ws/test-canvas --amount 100 --messages 1000). Measure and document metrics in performance report: latency <10ms, memory <500MB for 100 connections (<5MB per connection), messages/sec >10,000, CPU <30%. Compare to Fukamachi's benchmarks aligning with Go's performance.",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Woo Parameters",
            "description": "Set up the clackup options for Woo server including worker number, backlog, threading settings, and additional production optimizations. Ensure the database pool is thread-safe for SQLite.",
            "dependencies": [],
            "details": "In the server configuration, set :server :woo, :address \"0.0.0.0\", :port 8080, :debug nil, :worker-num 1, :backlog 4096, :max-request-per-child nil, :use-thread nil. Add Linux kernel tuning in deployment scripts: ulimit -n 65535; sysctl -w net.core.somaxconn=4096; sysctl -w net.ipv4.tcp_max_syn_backlog=4096. Include SBCL runtime tuning: (sb-ext:gc :full t); (setf (sb-ext:bytes-consed-between-gcs) 67108864); (setf sb-thread:*deadlock-detection* t). Ensure SQLite connection pool uses single connection with write serialization or mutex locks for thread safety.",
            "status": "pending",
            "testStrategy": "Verify server starts without errors with the new settings, kernel tunings applied, and SBCL optimizations in place.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add Connection Stats Monitoring",
            "description": "Implement real-time monitoring for connection statistics in the Woo server, following Fukamachi's pattern.",
            "dependencies": [
              1
            ],
            "details": "Implement get-connection-stats function to track :timestamp, :total-connections (hash-table-count *ws-connections*), :total-rooms (hash-table-count *canvas-rooms*), :memory-mb (/ (sb-ext:dynamic-space-size) 1048576), :threads (length (bt:all-threads)). Create a background thread to log stats every 60 seconds using (bt:make-thread ... :name \"stats-logger\"). Integrate into Woo event loop for real-time metrics.",
            "status": "pending",
            "testStrategy": "Check that metrics are logged correctly every 60 seconds during server operation, including connection counts, memory usage, and thread info.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Perform Load Testing",
            "description": "Conduct comprehensive load testing on the Woo server to ensure it handles production workloads efficiently, aligning with Fukamachi's benchmarks.",
            "dependencies": [
              2
            ],
            "details": "Use wrk for HTTP load testing (wrk -t4 -c100 -d30s http://localhost:8080/health) and thor for WebSocket testing (thor ws://localhost:8080/ws/test-canvas --amount 100 --messages 1000). Simulate 100+ concurrent connections and measure latency, memory usage, message throughput, and CPU. Aim for HTTP 5000+ req/sec, WebSocket <10ms latency, memory <500MB (<5MB per connection), CPU <30%. Document all metrics in a performance report comparing to Go's web server performance.",
            "status": "pending",
            "testStrategy": "Run load tests and verify metrics meet targets: HTTP 5000+ req/sec with 100 concurrent connections, WebSocket 100+ connections with <10ms latency, memory <500MB, CPU <30%. Generate performance report with detailed comparisons.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down into subtasks for configuration, adding metrics, and performance/load testing.",
        "updatedAt": "2025-10-15T21:55:51.763Z"
      },
      {
        "id": "12",
        "title": "Perform Cutover and Cleanup",
        "description": "Update main.lisp to use new server, remove Hunchentoot code, update docs, and deploy.",
        "details": "Change main.lisp to call start-server from server.lisp. Delete old setup-routes, hunchensocket classes. Remove old deps from ASD. Update README, architecture docs. Test end-to-end, deploy to staging/production.",
        "testStrategy": "Full integration test: Run application, connect clients, verify all features. Monitor for 24 hours in staging, check metrics against targets.",
        "priority": "high",
        "dependencies": [
          "11"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update main.lisp to integrate new server",
            "description": "Modify main.lisp to call the start-server function from server.lisp instead of the old Hunchentoot setup.",
            "dependencies": [],
            "details": "Locate main.lisp in the project root, replace any direct Hunchentoot server initialization with a call to (start-server) from server.lisp. Ensure the file compiles without errors and integrates properly with the new server architecture.",
            "status": "pending",
            "testStrategy": "Compile main.lisp and verify it loads without errors using (load \"main.lisp\").",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Remove old Hunchentoot code and dependencies",
            "description": "Delete obsolete Hunchentoot-related code and remove old dependencies from the ASD file.",
            "dependencies": [
              1
            ],
            "details": "In main.lisp, delete old setup-routes functions and hunchensocket classes. Edit collabcanvas.asd to remove old dependencies like Hunchentoot from the :depends-on section. Ensure the project still loads correctly after removals.",
            "status": "pending",
            "testStrategy": "Run (ql:quickload :collabcanvas) after changes and check for any loading errors or missing dependencies.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Update README and architecture documentation",
            "description": "Revise the README and architecture docs to reflect the new server setup and removal of Hunchentoot.",
            "dependencies": [
              2
            ],
            "details": "Update README.md to describe the new Clack/Woo server instead of Hunchentoot, including setup instructions. Modify architecture docs to explain the new server.lisp, app.lisp, and websocket-adapter.lisp components. Ensure docs are accurate and up-to-date.",
            "status": "pending",
            "testStrategy": "Review updated docs for clarity and accuracy, and verify links or references to old code are removed.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Conduct end-to-end testing and deploy to staging/production",
            "description": "Perform full integration testing and deploy the updated application to staging and production environments.",
            "dependencies": [
              3
            ],
            "details": "Run the application, connect clients, and verify all features work as expected. Monitor in staging for 24 hours, checking metrics against targets. If successful, deploy to production following standard procedures.",
            "status": "pending",
            "testStrategy": "Full integration test: Run application, connect clients, verify all features. Monitor for 24 hours in staging, check metrics against targets.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Expand into subtasks for updating main.lisp, removing old code, updating docs, and deployment/testing.",
        "updatedAt": "2025-10-15T21:59:24.500Z"
      },
      {
        "id": "13",
        "title": "Create Production-Ready Docker Configuration for CollabCanvas with Woo",
        "description": "Implement a production-ready Docker setup based on Fukamachi's battle-tested template, including Dockerfile, entrypoint script, and supporting files to containerize CollabCanvas with Woo server for deployment.",
        "details": "Following Fukamachi's proven Docker pattern for Lisp applications, create a Dockerfile starting from fukamachi/sbcl base image with environment variable PORT set to 5000. Include RUN commands to update apt and install necessary dependencies like libev-dev, gcc, libc6-dev, and SQLite-related packages (e.g., libsqlite3-dev), then clean up package lists. Set WORKDIR to /app and COPY entrypoint.sh to /srv. Install Clack and Woo via Roswell (ros install clack woo). Set ENTRYPOINT to /srv/entrypoint.sh and CMD to [\"app.lisp\"]. For entrypoint.sh, create an executable bash script that executes clackup with Woo server, debug nil, address 0.0.0.0, port from $PORT, and passes additional arguments. To integrate frontend, use a multi-stage build: first stage builds frontend with Vite (npm run build) and copies dist to a scratch stage, then copies to the final image. Ensure SQLite is installed for database operations, and add logic in entrypoint.sh to initialize database schema on first run if needed (e.g., check for DB file and run migration script). Handle SIGTERM gracefully by trapping signals and calling stop-server if applicable. Support environment variables like PORT, DATABASE_URL, etc. Create .dockerignore to exclude node_modules, .git, etc. Provide docker-compose.yml for local testing with services for app and possibly database. Include documentation in README or separate file on building (docker build -t collabcanvas .), running (docker run -p 5000:5000 collabcanvas), and environment setup. Adhere to best practices: use non-root user, minimize layers, leverage Docker caching, and ensure compatibility with Woo's production tuning from Task 11.",
        "testStrategy": "Build the Docker image with 'docker build -t collabcanvas .' and verify no errors occur. Run the container with 'docker run -p 5000:5000 collabcanvas' and check that the server starts successfully by monitoring logs for Woo startup messages. Perform health checks by curling the /health endpoint and confirming a 200 response with expected JSON. Test frontend asset serving by accessing static files via HTTP and verifying they load correctly. Validate WebSocket functionality by connecting a client (e.g., via wscat) to the /ws endpoint and sending/receiving messages, ensuring connections persist through the container. Test graceful shutdown by sending SIGTERM (docker stop) and confirming the process exits cleanly without errors in logs. Use docker-compose up for integrated testing, including database initialization if applicable, and run performance checks with tools like wrk for HTTP load and thor for WebSocket stress to ensure metrics align with production expectations (e.g., latency <10ms under load). Document all test results and any issues resolved.",
        "status": "done",
        "dependencies": [
          "11"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create backend/Dockerfile following Fukamachi's template",
            "description": "Develop a Dockerfile based on Fukamachi's battle-tested template for Lisp applications, using the fukamachi/sbcl base image, installing necessary dependencies like libev-dev, gcc, libc6-dev, and SQLite packages, setting up Roswell to install Clack and Woo, copying application files, and implementing a multi-stage build to include frontend assets for a production-ready container.",
            "dependencies": [],
            "details": "Start with FROM fukamachi/sbcl and set ENV PORT=5000. Include RUN apt-get update && apt-get install -y libev-dev gcc libc6-dev libsqlite3-dev && rm -rf /var/lib/apt/lists/*. Set WORKDIR /app. COPY entrypoint.sh /srv. RUN ros install clack woo. COPY collabcanvas.asd src/ /app/. For multi-stage: Use a builder stage for frontend (FROM node:alpine, COPY package.json, RUN npm install, COPY ., RUN npm run build). Then FROM scratch, COPY --from=builder /app/dist /app/static. Finally, set ENTRYPOINT /srv/entrypoint.sh and CMD [\"app.lisp\"]. Ensure non-root user and minimize layers.",
            "status": "pending",
            "testStrategy": "Build the image with docker build -t collabcanvas . and verify it completes without errors, checking layer sizes for optimization.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create backend/entrypoint.sh with initialization logic",
            "description": "Create an executable entrypoint script that handles database initialization, environment variables, graceful shutdown, and starts the Woo server via clackup.",
            "dependencies": [
              1
            ],
            "details": "Write a bash script as entrypoint.sh, make it executable with chmod +x. Include logic to check for database file and run schema initialization if needed (e.g., if [ ! -f $DB_PATH ]; then sqlite3 $DB_PATH < schema.sql; fi). Handle environment variables like PORT, DATABASE_URL, DEBUG. Trap SIGTERM for graceful shutdown (trap 'stop-server' TERM). Use exec clackup --server woo --debug nil --address 0.0.0.0 --port $PORT app.lisp. Log startup info like 'Starting CollabCanvas on port $PORT'. Ensure it passes additional arguments if any.",
            "status": "pending",
            "testStrategy": "Test the script manually by running it in a container and checking logs for initialization messages, database creation, and proper server startup.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create backend/.dockerignore",
            "description": "Create a .dockerignore file to exclude unnecessary files from the Docker build context, improving build efficiency and security.",
            "dependencies": [],
            "details": "List exclusions such as .git/, node_modules/, *.fasl, test/, data/, and development artifacts. Ensure to include necessary files like src/, collabcanvas.asd, db/schema.sql, and entrypoint.sh. This prevents sensitive or large files from being copied into the image, reducing build time and image size.",
            "status": "pending",
            "testStrategy": "After creating, run docker build and verify that excluded files are not present in the build context by checking the build output or inspecting the image layers.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create docker-compose.yml for local testing",
            "description": "Develop a docker-compose.yml file to define services for local development and testing, including the CollabCanvas app and any necessary databases.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Define a service named collabcanvas with build context from ., ports mapping like 8080:8080, environment variables (PORT=8080, DATABASE_URL=sqlite:///app/data/db.sqlite), volumes for mounting source code or data. Optionally add a database service if needed. Include healthcheck with test curl command. Ensure it supports development workflow with hot reloading if possible.",
            "status": "pending",
            "testStrategy": "Run docker-compose up and verify the service starts, ports are exposed, and health checks pass by accessing the app via browser or curl.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Test Docker build and run locally",
            "description": "Perform local testing of the Docker setup by building the image, running the container, and verifying functionality including health endpoints, WebSocket connections, and graceful shutdown.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Execute docker build -t collabcanvas:latest . to build the image. Then run docker run -p 5000:5000 collabcanvas. Test with curl to /health endpoint. Check WebSocket functionality. Verify frontend assets are served. Test shutdown with docker stop and ensure no errors. Also test with docker-compose up for integrated testing.",
            "status": "pending",
            "testStrategy": "Monitor logs during build and run for errors. Use curl for HTTP requests, a WebSocket client for connections, and check response times and data integrity.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Document Docker deployment process",
            "description": "Create comprehensive documentation for building, running, and deploying the Dockerized CollabCanvas application, including environment setup and troubleshooting.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Add a Docker section to README.md or create a separate docs/docker.md. Document environment variables (PORT, DATABASE_URL, etc.). Provide build commands (docker build -t collabcanvas .), run commands (docker run -p 5000:5000 collabcanvas), and docker-compose usage. Include troubleshooting for common issues like port conflicts or dependency errors. Add notes for production deployment on platforms like Fly.io, emphasizing Woo's tuning from Task 11.",
            "status": "pending",
            "testStrategy": "Review the documentation for completeness by following the steps manually and ensuring all commands work as described, updating based on any discrepancies found.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-15T22:01:59.328Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-15T22:01:59.330Z",
      "taskCount": 13,
      "completedCount": 13,
      "tags": [
        "woo"
      ]
    }
  }
}